<!DOCTYPE html><html lang="zh-CN" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>window 对象 - JavaScript 教程 - 网道</title><!-- link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" --><link rel="stylesheet" href="../assets/css/app.min.css"><link rel="stylesheet" href="https://apps.bdimg.com/libs/fontawesome/4.4.0/css/font-awesome.css"><!-- link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css"--><!-- link rel="stylesheet" href="../assets/css/share.min.css" --><meta property="og:type" content="article"><meta property="og:title" content="window 对象"><link rel="apple-touch-icon" sizes="57x57" href="../assets/icons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="../assets/icons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="../assets/icons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="../assets/icons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="../assets/icons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="../assets/icons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="../assets/icons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="../assets/icons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="../assets/icons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="../assets/icons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="../assets/icons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="../assets/icons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="../assets/icons/favicon-16x16.png"><link rel="manifest" href="../assets/icons/manifest.json"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="../assets/icons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"></head><body><nav class="navbar is-light" role="navigation" id="navbar" aria-label="main navigation"><div class="container"><div class="navbar-brand"><a href="/" class="navbar-item title has-text-grey has-text-weight-light is-5">网道 / WangDoc.com </a><a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false"><span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span></a></div><div class="navbar-menu" id="navMenu"><div class="navbar-end"><div class="navbar-item"><form action="https://sourcegraph.com/search" target="_blank" method="get" onsubmit='this.q.value="repo:^github.com/wangdoc/javascript-tutorial$ "+this.origin.value'><p class="control has-icons-right"><input class="input" type="text" name="origin" placeholder="搜索..."> <span class="icon is-small is-right"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"><path fill="#ddd" d="M23.822 20.88l-6.353-6.354c.93-1.465 1.467-3.2 1.467-5.059.001-5.219-4.247-9.467-9.468-9.467s-9.468 4.248-9.468 9.468c0 5.221 4.247 9.469 9.468 9.469 1.768 0 3.421-.487 4.839-1.333l6.396 6.396 3.119-3.12zm-20.294-11.412c0-3.273 2.665-5.938 5.939-5.938 3.275 0 5.94 2.664 5.94 5.938 0 3.275-2.665 5.939-5.94 5.939-3.274 0-5.939-2.664-5.939-5.939z"/></svg></span></p><input type="hidden" name="q" value=""> <input type="hidden" name="patternType" value="literal"></form></div><a class="navbar-item is-hidden-desktop-only" target="_blank" href="https://github.com/wangdoc/javascript-tutorial"><span class="icon" style="color: #333;"><i class="fa fa-lg fa-github"></i></span></a></div></div></div></nav><section class="section main article"><div class="container"><div class="columns"><div class="column is-8"><nav class="breadcrumb is-size-5-desktop" aria-label="breadcrumbs"><ul><li><a href="../index.html"><span class="icon"><i class="fa fa-home"></i></span> &nbsp;JavaScript 教程</a></li><li><a href="../bom/index.html">浏览器模型</a></li><li class="is-active"><a class="has-text-grey" href="../bom/window.html">window 对象</a></li></ul></nav><nav class="level level-previous-next is-size-5 is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="../bom/engine.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> 浏览器模型概述</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="../bom/navigator.html">Navigator 对象，Screen 对象 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><article class="content is-size-4-desktop"><h1 class="title">window 对象</h1><div class="page-meta"><p>网道（WangDoc.com），互联网文档计划</p></div><h2 id="概述">概述 <a class="markdownIt-Anchor" href="#概述">#</a></h2><p>浏览器里面，<code>window</code>对象（注意，<code>w</code>为小写）指当前的浏览器窗口。它也是当前页面的顶层对象，即最高一层的对象，所有其他对象都是它的下属。一个变量如果未声明，那么默认就是顶层对象的属性。</p><pre class="hljs"><code>a = <span class="hljs-number">1</span>;
<span class="hljs-built_in">window</span>.a <span class="hljs-comment">// 1</span>
</code></pre><p>上面代码中，<code>a</code>是一个没有声明就直接赋值的变量，它自动成为顶层对象的属性。</p><p><code>window</code>有自己的实体含义，其实不适合当作最高一层的顶层对象，这是一个语言的设计失误。最早，设计这门语言的时候，原始设想是语言内置的对象越少越好，这样可以提高浏览器的性能。因此，语言设计者 Brendan Eich 就把<code>window</code>对象当作顶层对象，所有未声明就赋值的变量都自动变成<code>window</code>对象的属性。这种设计使得编译阶段无法检测出未声明变量，但到了今天已经没有办法纠正了。</p><h2 id="window-对象的属性">window 对象的属性 <a class="markdownIt-Anchor" href="#window-对象的属性">#</a></h2><h3 id="windowname">window.name <a class="markdownIt-Anchor" href="#windowname">#</a></h3><p><code>window.name</code>属性是一个字符串，表示当前浏览器窗口的名字。窗口不一定需要名字，这个属性主要配合超链接和表单的<code>target</code>属性使用。</p><pre class="hljs"><code><span class="hljs-built_in">window</span>.name = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.name)
<span class="hljs-comment">// &quot;Hello World!&quot;</span>
</code></pre><p>该属性只能保存字符串，如果写入的值不是字符串，会自动转成字符串。各个浏览器对这个值的储存容量有所不同，但是一般来说，可以高达几MB。</p><p>只要浏览器窗口不关闭，这个属性是不会消失的。举例来说，访问<code>a.com</code>时，该页面的脚本设置了<code>window.name</code>，接下来在同一个窗口里面载入了<code>b.com</code>，新页面的脚本可以读到上一个网页设置的<code>window.name</code>。页面刷新也是这种情况。一旦浏览器窗口关闭后，该属性保存的值就会消失，因为这时窗口已经不存在了。</p><h3 id="windowclosed，windowopener">window.closed，window.opener <a class="markdownIt-Anchor" href="#windowclosed，windowopener">#</a></h3><p><code>window.closed</code>属性返回一个布尔值，表示窗口是否关闭。</p><pre class="hljs"><code><span class="hljs-built_in">window</span>.closed <span class="hljs-comment">// false</span>
</code></pre><p>上面代码检查当前窗口是否关闭。这种检查意义不大，因为只要能运行代码，当前窗口肯定没有关闭。这个属性一般用来检查，使用脚本打开的新窗口是否关闭。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> popup = <span class="hljs-built_in">window</span>.open();

<span class="hljs-keyword">if</span> ((popup !== <span class="hljs-literal">null</span>) &amp;&amp; !popup.closed) {
  <span class="hljs-comment">// 窗口仍然打开着</span>
}
</code></pre><p><code>window.opener</code>属性表示打开当前窗口的父窗口。如果当前窗口没有父窗口（即直接在地址栏输入打开），则返回<code>null</code>。</p><pre class="hljs"><code><span class="hljs-built_in">window</span>.open().opener === <span class="hljs-built_in">window</span> <span class="hljs-comment">// true</span>
</code></pre><p>上面表达式会打开一个新窗口，然后返回<code>true</code>。</p><p>如果两个窗口之间不需要通信，建议将子窗口的<code>opener</code>属性显式设为<code>null</code>，这样可以减少一些安全隐患。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> newWin = <span class="hljs-built_in">window</span>.open(<span class="hljs-string">&#x27;example.html&#x27;</span>, <span class="hljs-string">&#x27;newWindow&#x27;</span>, <span class="hljs-string">&#x27;height=400,width=400&#x27;</span>);
newWin.opener = <span class="hljs-literal">null</span>;
</code></pre><p>上面代码中，子窗口的<code>opener</code>属性设为<code>null</code>，两个窗口之间就没办法再联系了。</p><p>通过<code>opener</code>属性，可以获得父窗口的全局属性和方法，但只限于两个窗口同源的情况（参见《同源限制》一章），且其中一个窗口由另一个打开。<code>&lt;a&gt;</code>元素添加<code>rel=&quot;noopener&quot;</code>属性，可以防止新打开的窗口获取父窗口，减轻被恶意网站修改父窗口 URL 的风险。</p><pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://an.evil.site&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;noopener&quot;</span>&gt;</span>
恶意网站
<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
</code></pre><h3 id="windowself，windowwindow">window.self，window.window <a class="markdownIt-Anchor" href="#windowself，windowwindow">#</a></h3><p><code>window.self</code>和<code>window.window</code>属性都指向窗口本身。这两个属性只读。</p><pre class="hljs"><code><span class="hljs-built_in">window</span>.self === <span class="hljs-built_in">window</span> <span class="hljs-comment">// true</span>
<span class="hljs-built_in">window</span>.window === <span class="hljs-built_in">window</span> <span class="hljs-comment">// true</span>
</code></pre><h3 id="windowframes，windowlength">window.frames，window.length <a class="markdownIt-Anchor" href="#windowframes，windowlength">#</a></h3><p><code>window.frames</code>属性返回一个类似数组的对象，成员为页面内所有框架窗口，包括<code>frame</code>元素和<code>iframe</code>元素。<code>window.frames[0]</code>表示页面中第一个框架窗口。</p><p>如果<code>iframe</code>元素设置了<code>id</code>或<code>name</code>属性，那么就可以用属性值，引用这个<code>iframe</code>窗口。比如<code>&lt;iframe name=&quot;myIFrame&quot;&gt;</code>可以用<code>frames['myIFrame']</code>或者<code>frames.myIFrame</code>来引用。</p><p><code>frames</code>属性实际上是<code>window</code>对象的别名。</p><pre class="hljs"><code>frames === <span class="hljs-built_in">window</span> <span class="hljs-comment">// true</span>
</code></pre><p>因此，<code>frames[0]</code>也可以用<code>window[0]</code>表示。但是，从语义上看，<code>frames</code>更清晰，而且考虑到<code>window</code>还是全局对象，因此推荐表示多窗口时，总是使用<code>frames[0]</code>的写法。更多介绍请看下文的《多窗口操作》部分。</p><p><code>window.length</code>属性返回当前网页包含的框架总数。如果当前网页不包含<code>frame</code>和<code>iframe</code>元素，那么<code>window.length</code>就返回<code>0</code>。</p><pre class="hljs"><code><span class="hljs-built_in">window</span>.frames.length === <span class="hljs-built_in">window</span>.length <span class="hljs-comment">// true</span>
</code></pre><p>上面代码表示，<code>window.frames.length</code>与<code>window.length</code>应该是相等的。</p><h3 id="windowframeelement">window.frameElement <a class="markdownIt-Anchor" href="#windowframeelement">#</a></h3><p><code>window.frameElement</code>属性主要用于当前窗口嵌在另一个网页的情况（嵌入<code>&lt;object&gt;</code>、<code>&lt;iframe&gt;</code>或<code>&lt;embed&gt;</code>元素），返回当前窗口所在的那个元素节点。如果当前窗口是顶层窗口，或者所嵌入的那个网页不是同源的，该属性返回<code>null</code>。</p><pre class="hljs"><code><span class="hljs-comment">// HTML 代码如下</span>
<span class="hljs-comment">// &lt;iframe src=&quot;about.html&quot;&gt;&lt;/iframe&gt;</span>

<span class="hljs-comment">// 下面的脚本在 about.html 里面</span>
<span class="hljs-keyword">var</span> frameEl = <span class="hljs-built_in">window</span>.frameElement;
<span class="hljs-keyword">if</span> (frameEl) {
  frameEl.src = <span class="hljs-string">&#x27;other.html&#x27;</span>;
}
</code></pre><p>上面代码中，<code>frameEl</code>变量就是<code>&lt;iframe&gt;</code>元素。</p><h3 id="windowtop，windowparent">window.top，window.parent <a class="markdownIt-Anchor" href="#windowtop，windowparent">#</a></h3><p><code>window.top</code>属性指向最顶层窗口，主要用于在框架窗口（frame）里面获取顶层窗口。</p><p><code>window.parent</code>属性指向父窗口。如果当前窗口没有父窗口，<code>window.parent</code>指向自身。</p><pre class="hljs"><code><span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.parent !== <span class="hljs-built_in">window</span>.top) {
  <span class="hljs-comment">// 表明当前窗口嵌入不止一层</span>
}
</code></pre><p>对于不包含框架的网页，这两个属性等同于<code>window</code>对象。</p><h3 id="windowstatus">window.status <a class="markdownIt-Anchor" href="#windowstatus">#</a></h3><p><code>window.status</code>属性用于读写浏览器状态栏的文本。但是，现在很多浏览器都不允许改写状态栏文本，所以使用这个方法不一定有效。</p><h3 id="windowdevicepixelratio">window.devicePixelRatio <a class="markdownIt-Anchor" href="#windowdevicepixelratio">#</a></h3><p><code>window.devicePixelRatio</code>属性返回一个数值，表示一个 CSS 像素的大小与一个物理像素的大小之间的比率。也就是说，它表示一个 CSS 像素由多少个物理像素组成。它可以用于判断用户的显示环境，如果这个比率较大，就表示用户正在使用高清屏幕，因此可以显示较大像素的图片。</p><h3 id="位置大小属性">位置大小属性 <a class="markdownIt-Anchor" href="#位置大小属性">#</a></h3><p>以下属性返回<code>window</code>对象的位置信息和大小信息。</p><p><strong>（1）window.screenX，window.screenY</strong></p><p><code>window.screenX</code>和<code>window.screenY</code>属性，返回浏览器窗口左上角相对于当前屏幕左上角的水平距离和垂直距离（单位像素）。这两个属性只读。</p><p><strong>（2） window.innerHeight，window.innerWidth</strong></p><p><code>window.innerHeight</code>和<code>window.innerWidth</code>属性，返回网页在当前窗口中可见部分的高度和宽度，即“视口”（viewport）的大小（单位像素）。这两个属性只读。</p><p>用户放大网页的时候（比如将网页从100%的大小放大为200%），这两个属性会变小。因为这时网页的像素大小不变（比如宽度还是960像素），只是每个像素占据的屏幕空间变大了，因此可见部分（视口）就变小了。</p><p>注意，这两个属性值包括滚动条的高度和宽度。</p><p><strong>（3）window.outerHeight，window.outerWidth</strong></p><p><code>window.outerHeight</code>和<code>window.outerWidth</code>属性返回浏览器窗口的高度和宽度，包括浏览器菜单和边框（单位像素）。这两个属性只读。</p><p><strong>（4）window.scrollX，window.scrollY</strong></p><p><code>window.scrollX</code>属性返回页面的水平滚动距离，<code>window.scrollY</code>属性返回页面的垂直滚动距离，单位都为像素。这两个属性只读。</p><p>注意，这两个属性的返回值不是整数，而是双精度浮点数。如果页面没有滚动，它们的值就是<code>0</code>。</p><p>举例来说，如果用户向下拉动了垂直滚动条75像素，那么<code>window.scrollY</code>就是75左右。用户水平向右拉动水平滚动条200像素，<code>window.scrollX</code>就是200左右。</p><pre class="hljs"><code><span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.scrollY &lt; <span class="hljs-number">75</span>) {
  <span class="hljs-built_in">window</span>.scroll(<span class="hljs-number">0</span>, <span class="hljs-number">75</span>);
}
</code></pre><p>上面代码中，如果页面向下滚动的距离小于75像素，那么页面向下滚动75像素。</p><p><strong>（5）window.pageXOffset，window.pageYOffset</strong></p><p><code>window.pageXOffset</code>属性和<code>window.pageYOffset</code>属性，是<code>window.scrollX</code>和<code>window.scrollY</code>别名。</p><h3 id="组件属性">组件属性 <a class="markdownIt-Anchor" href="#组件属性">#</a></h3><p>组件属性返回浏览器的组件对象。这样的属性有下面几个。</p><ul><li><code>window.locationbar</code>：地址栏对象</li><li><code>window.menubar</code>：菜单栏对象</li><li><code>window.scrollbars</code>：窗口的滚动条对象</li><li><code>window.toolbar</code>：工具栏对象</li><li><code>window.statusbar</code>：状态栏对象</li><li><code>window.personalbar</code>：用户安装的个人工具栏对象</li></ul><p>这些对象的<code>visible</code>属性是一个布尔值，表示这些组件是否可见。这些属性只读。</p><pre class="hljs"><code><span class="hljs-built_in">window</span>.locationbar.visible
<span class="hljs-built_in">window</span>.menubar.visible
<span class="hljs-built_in">window</span>.scrollbars.visible
<span class="hljs-built_in">window</span>.toolbar.visible
<span class="hljs-built_in">window</span>.statusbar.visible
<span class="hljs-built_in">window</span>.personalbar.visible
</code></pre><h3 id="全局对象属性">全局对象属性 <a class="markdownIt-Anchor" href="#全局对象属性">#</a></h3><p>全局对象属性指向一些浏览器原生的全局对象。</p><ul><li><code>window.document</code>：指向<code>document</code>对象，详见《document 对象》一章。注意，这个属性有同源限制。只有来自同源的脚本才能读取这个属性。</li><li><code>window.location</code>：指向<code>Location</code>对象，用于获取当前窗口的 URL 信息。它等同于<code>document.location</code>属性，详见《Location 对象》一章。</li><li><code>window.navigator</code>：指向<code>Navigator</code>对象，用于获取环境信息，详见《Navigator 对象》一章。</li><li><code>window.history</code>：指向<code>History</code>对象，表示浏览器的浏览历史，详见《History 对象》一章。</li><li><code>window.localStorage</code>：指向本地储存的 localStorage 数据，详见《Storage 接口》一章。</li><li><code>window.sessionStorage</code>：指向本地储存的 sessionStorage 数据，详见《Storage 接口》一章。</li><li><code>window.console</code>：指向<code>console</code>对象，用于操作控制台，详见《console 对象》一章。</li><li><code>window.screen</code>：指向<code>Screen</code>对象，表示屏幕信息，详见《Screen 对象》一章。</li></ul><h3 id="windowissecurecontext">window.isSecureContext <a class="markdownIt-Anchor" href="#windowissecurecontext">#</a></h3><p><code>window.isSecureContext</code>属性返回一个布尔值，表示当前窗口是否处在加密环境。如果是 HTTPS 协议，就是<code>true</code>，否则就是<code>false</code>。</p><h2 id="window-对象的方法">window 对象的方法 <a class="markdownIt-Anchor" href="#window-对象的方法">#</a></h2><h3 id="windowalert，windowprompt，windowconfirm">window.alert()，window.prompt()，window.confirm() <a class="markdownIt-Anchor" href="#windowalert，windowprompt，windowconfirm">#</a></h3><p><code>window.alert()</code>、<code>window.prompt()</code>、<code>window.confirm()</code>都是浏览器与用户互动的全局方法。它们会弹出不同的对话框，要求用户做出回应。注意，这三个方法弹出的对话框，都是浏览器统一规定的式样，无法定制。</p><p><strong>（1）window.alert()</strong></p><p><code>window.alert()</code>方法弹出的对话框，只有一个“确定”按钮，往往用来通知用户某些信息。</p><pre class="hljs"><code><span class="hljs-built_in">window</span>.alert(<span class="hljs-string">&#x27;Hello World&#x27;</span>);
</code></pre><p>用户只有点击“确定”按钮，对话框才会消失。对话框弹出期间，浏览器窗口处于冻结状态，如果不点“确定”按钮，用户什么也干不了。</p><p><code>window.alert()</code>方法的参数只能是字符串，没法使用 CSS 样式，但是可以用<code>\n</code>指定换行。</p><pre class="hljs"><code>alert(<span class="hljs-string">&#x27;本条提示\n分成两行&#x27;</span>);
</code></pre><p><strong>（2）window.prompt()</strong></p><p><code>window.prompt()</code>方法弹出的对话框，提示文字的下方，还有一个输入框，要求用户输入信息，并有“确定”和“取消”两个按钮。它往往用来获取用户输入的数据。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> result = prompt(<span class="hljs-string">&#x27;您的年龄？&#x27;</span>, <span class="hljs-number">25</span>)
</code></pre><p>上面代码会跳出一个对话框，文字提示为“您的年龄？”，要求用户在对话框中输入自己的年龄（默认显示25）。用户填入的值，会作为返回值存入变量<code>result</code>。</p><p><code>window.prompt()</code>的返回值有两种情况，可能是字符串（有可能是空字符串），也有可能是<code>null</code>。具体分成三种情况。</p><ol><li>用户输入信息，并点击“确定”，则用户输入的信息就是返回值。</li><li>用户没有输入信息，直接点击“确定”，则输入框的默认值就是返回值。</li><li>用户点击了“取消”（或者按了 ESC 按钮），则返回值是<code>null</code>。</li></ol><p><code>window.prompt()</code>方法的第二个参数是可选的，但是最好总是提供第二个参数，作为输入框的默认值。</p><p><strong>（3）window.confirm()</strong></p><p><code>window.confirm()</code>方法弹出的对话框，除了提示信息之外，只有“确定”和“取消”两个按钮，往往用来征询用户是否同意。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> result = confirm(<span class="hljs-string">&#x27;你最近好吗？&#x27;</span>);
</code></pre><p>上面代码弹出一个对话框，上面只有一行文字“你最近好吗？”，用户选择点击“确定”或“取消”。</p><p><code>confirm</code>方法返回一个布尔值，如果用户点击“确定”，返回<code>true</code>；如果用户点击“取消”，则返回<code>false</code>。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> okay = confirm(<span class="hljs-string">&#x27;Please confirm this message.&#x27;</span>);
<span class="hljs-keyword">if</span> (okay) {
  <span class="hljs-comment">// 用户按下“确定”</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// 用户按下“取消”</span>
}
</code></pre><p><code>confirm</code>的一个用途是，用户离开当前页面时，弹出一个对话框，问用户是否真的要离开。</p><pre class="hljs"><code><span class="hljs-built_in">window</span>.onunload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>.confirm(<span class="hljs-string">&#x27;你确定要离开当面页面吗？&#x27;</span>);
}
</code></pre><p>这三个方法都具有堵塞效应，一旦弹出对话框，整个页面就是暂停执行，等待用户做出反应。</p><h3 id="windowopen-windowclose，windowstop">window.open(), window.close()，window.stop() <a class="markdownIt-Anchor" href="#windowopen-windowclose，windowstop">#</a></h3><p><strong>（1）window.open()</strong></p><p><code>window.open</code>方法用于新建另一个浏览器窗口，类似于浏览器菜单的新建窗口选项。它会返回新窗口的引用，如果无法新建窗口，则返回<code>null</code>。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> popup = <span class="hljs-built_in">window</span>.open(<span class="hljs-string">&#x27;somefile.html&#x27;</span>);
</code></pre><p>上面代码会让浏览器弹出一个新建窗口，网址是当前域名下的<code>somefile.html</code>。</p><p><code>open</code>方法一共可以接受三个参数。</p><pre class="hljs"><code><span class="hljs-built_in">window</span>.open(url, windowName, [windowFeatures])
</code></pre><ul><li><code>url</code>：字符串，表示新窗口的网址。如果省略，默认网址就是<code>about:blank</code>。</li><li><code>windowName</code>：字符串，表示新窗口的名字。如果该名字的窗口已经存在，则占用该窗口，不再新建窗口。如果省略，就默认使用<code>_blank</code>，表示新建一个没有名字的窗口。另外还有几个预设值，<code>_self</code>表示当前窗口，<code>_top</code>表示顶层窗口，<code>_parent</code>表示上一层窗口。</li><li><code>windowFeatures</code>：字符串，内容为逗号分隔的键值对（详见下文），表示新窗口的参数，比如有没有提示栏、工具条等等。如果省略，则默认打开一个完整 UI 的新窗口。如果新建的是一个已经存在的窗口，则该参数不起作用，浏览器沿用以前窗口的参数。</li></ul><p>下面是一个例子。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> popup = <span class="hljs-built_in">window</span>.open(
  <span class="hljs-string">&#x27;somepage.html&#x27;</span>,
  <span class="hljs-string">&#x27;DefinitionsWindows&#x27;</span>,
  <span class="hljs-string">&#x27;height=200,width=200,location=no,status=yes,resizable=yes,scrollbars=yes&#x27;</span>
);
</code></pre><p>上面代码表示，打开的新窗口高度和宽度都为200像素，没有地址栏，但有状态栏和滚动条，允许用户调整大小。</p><p>第三个参数可以设定如下属性。</p><ul><li>left：新窗口距离屏幕最左边的距离（单位像素）。注意，新窗口必须是可见的，不能设置在屏幕以外的位置。</li><li>top：新窗口距离屏幕最顶部的距离（单位像素）。</li><li>height：新窗口内容区域的高度（单位像素），不得小于100。</li><li>width：新窗口内容区域的宽度（单位像素），不得小于100。</li><li>outerHeight：整个浏览器窗口的高度（单位像素），不得小于100。</li><li>outerWidth：整个浏览器窗口的宽度（单位像素），不得小于100。</li><li>menubar：是否显示菜单栏。</li><li>toolbar：是否显示工具栏。</li><li>location：是否显示地址栏。</li><li>personalbar：是否显示用户自己安装的工具栏。</li><li>status：是否显示状态栏。</li><li>dependent：是否依赖父窗口。如果依赖，那么父窗口最小化，该窗口也最小化；父窗口关闭，该窗口也关闭。</li><li>minimizable：是否有最小化按钮，前提是<code>dialog=yes</code>。</li><li>noopener：新窗口将与父窗口切断联系，即新窗口的<code>window.opener</code>属性返回<code>null</code>，父窗口的<code>window.open()</code>方法也返回<code>null</code>。</li><li>resizable：新窗口是否可以调节大小。</li><li>scrollbars：是否允许新窗口出现滚动条。</li><li>dialog：新窗口标题栏是否出现最大化、最小化、恢复原始大小的控件。</li><li>titlebar：新窗口是否显示标题栏。</li><li>alwaysRaised：是否显示在所有窗口的顶部。</li><li>alwaysLowered：是否显示在父窗口的底下。</li><li>close：新窗口是否显示关闭按钮。</li></ul><p>对于那些可以打开和关闭的属性，设为<code>yes</code>或<code>1</code>或不设任何值就表示打开，比如<code>status=yes</code>、<code>status=1</code>、<code>status</code>都会得到同样的结果。如果想设为关闭，不用写<code>no</code>，而是直接省略这个属性即可。也就是说，如果在第三个参数中设置了一部分属性，其他没有被设置的<code>yes/no</code>属性都会被设成<code>no</code>，只有<code>titlebar</code>和关闭按钮除外（它们的值默认为<code>yes</code>）。</p><p>上面这些属性，属性名与属性值之间用等号连接，属性与属性之间用逗号分隔。</p><pre class="hljs"><code><span class="hljs-string">&#x27;height=200,width=200,location=no,status=yes,resizable=yes,scrollbars=yes&#x27;</span>
</code></pre><p>另外，<code>open()</code>方法的第二个参数虽然可以指定已经存在的窗口，但是不等于可以任意控制其他窗口。为了防止被不相干的窗口控制，浏览器只有在两个窗口同源，或者目标窗口被当前网页打开的情况下，才允许<code>open</code>方法指向该窗口。</p><p><code>window.open</code>方法返回新窗口的引用。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> windowB = <span class="hljs-built_in">window</span>.open(<span class="hljs-string">&#x27;windowB.html&#x27;</span>, <span class="hljs-string">&#x27;WindowB&#x27;</span>);
windowB.window.name <span class="hljs-comment">// &quot;WindowB&quot;</span>
</code></pre><p>注意，如果新窗口和父窗口不是同源的（即不在同一个域），它们彼此不能获取对方窗口对象的内部属性。</p><p>下面是另一个例子。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> w = <span class="hljs-built_in">window</span>.open();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;已经打开新窗口&#x27;</span>);
w.location = <span class="hljs-string">&#x27;http://example.com&#x27;</span>;
</code></pre><p>上面代码先打开一个新窗口，然后在该窗口弹出一个对话框，再将网址导向<code>example.com</code>。</p><p>由于<code>open</code>这个方法很容易被滥用，许多浏览器默认都不允许脚本自动新建窗口。只允许在用户点击链接或按钮时，脚本做出反应，弹出新窗口。因此，有必要检查一下打开新窗口是否成功。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> popup = <span class="hljs-built_in">window</span>.open();
<span class="hljs-keyword">if</span> (popup === <span class="hljs-literal">null</span>) {
  <span class="hljs-comment">// 新建窗口失败</span>
}
</code></pre><p><strong>（2）window.close()</strong></p><p><code>window.close</code>方法用于关闭当前窗口，一般只用来关闭<code>window.open</code>方法新建的窗口。</p><pre class="hljs"><code>popup.close()
</code></pre><p>该方法只对顶层窗口有效，<code>iframe</code>框架之中的窗口使用该方法无效。</p><p><strong>（3）window.stop()</strong></p><p><code>window.stop()</code>方法完全等同于单击浏览器的停止按钮，会停止加载图像、视频等正在或等待加载的对象。</p><pre class="hljs"><code><span class="hljs-built_in">window</span>.stop()
</code></pre><h3 id="windowmoveto，windowmoveby">window.moveTo()，window.moveBy() <a class="markdownIt-Anchor" href="#windowmoveto，windowmoveby">#</a></h3><p><code>window.moveTo()</code>方法用于移动浏览器窗口到指定位置。它接受两个参数，分别是窗口左上角距离屏幕左上角的水平距离和垂直距离，单位为像素。</p><pre class="hljs"><code><span class="hljs-built_in">window</span>.moveTo(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>)
</code></pre><p>上面代码将窗口移动到屏幕<code>(100, 200)</code>的位置。</p><p><code>window.moveBy()</code>方法将窗口移动到一个相对位置。它接受两个参数，分别是窗口左上角向右移动的水平距离和向下移动的垂直距离，单位为像素。</p><pre class="hljs"><code><span class="hljs-built_in">window</span>.moveBy(<span class="hljs-number">25</span>, <span class="hljs-number">50</span>)
</code></pre><p>上面代码将窗口向右移动25像素、向下移动50像素。</p><p>为了防止有人滥用这两个方法，随意移动用户的窗口，目前只有一种情况，浏览器允许用脚本移动窗口：该窗口是用<code>window.open()</code>方法新建的，并且窗口里只有它一个 Tab 页。除此以外的情况，使用上面两个方法都是无效的。</p><h3 id="windowresizeto，windowresizeby">window.resizeTo()，window.resizeBy() <a class="markdownIt-Anchor" href="#windowresizeto，windowresizeby">#</a></h3><p><code>window.resizeTo()</code>方法用于缩放窗口到指定大小。</p><p>它接受两个参数，第一个是缩放后的窗口宽度（<code>outerWidth</code>属性，包含滚动条、标题栏等等），第二个是缩放后的窗口高度（<code>outerHeight</code>属性）。</p><pre class="hljs"><code><span class="hljs-built_in">window</span>.resizeTo(
  <span class="hljs-built_in">window</span>.screen.availWidth / <span class="hljs-number">2</span>,
  <span class="hljs-built_in">window</span>.screen.availHeight / <span class="hljs-number">2</span>
)
</code></pre><p>上面代码将当前窗口缩放到，屏幕可用区域的一半宽度和高度。</p><p><code>window.resizeBy()</code>方法用于缩放窗口。它与<code>window.resizeTo()</code>的区别是，它按照相对的量缩放，<code>window.resizeTo()</code>需要给出缩放后的绝对大小。</p><p>它接受两个参数，第一个是水平缩放的量，第二个是垂直缩放的量，单位都是像素。</p><pre class="hljs"><code><span class="hljs-built_in">window</span>.resizeBy(<span class="hljs-number">-200</span>, <span class="hljs-number">-200</span>)
</code></pre><p>上面的代码将当前窗口的宽度和高度，都缩小200像素。</p><h3 id="windowscrollto，windowscroll，windowscrollby">window.scrollTo()，window.scroll()，window.scrollBy() <a class="markdownIt-Anchor" href="#windowscrollto，windowscroll，windowscrollby">#</a></h3><p><code>window.scrollTo</code>方法用于将文档滚动到指定位置。它接受两个参数，表示滚动后位于窗口左上角的页面坐标。</p><pre class="hljs"><code><span class="hljs-built_in">window</span>.scrollTo(x-coord, y-coord)
</code></pre><p>它也可以接受一个配置对象作为参数。</p><pre class="hljs"><code><span class="hljs-built_in">window</span>.scrollTo(options)
</code></pre><p>配置对象<code>options</code>有三个属性。</p><ul><li><code>top</code>：滚动后页面左上角的垂直坐标，即 y 坐标。</li><li><code>left</code>：滚动后页面左上角的水平坐标，即 x 坐标。</li><li><code>behavior</code>：字符串，表示滚动的方式，有三个可能值（<code>smooth</code>、<code>instant</code>、<code>auto</code>），默认值为<code>auto</code>。</li></ul><pre class="hljs"><code><span class="hljs-built_in">window</span>.scrollTo({
  <span class="hljs-attr">top</span>: <span class="hljs-number">1000</span>,
  <span class="hljs-attr">behavior</span>: <span class="hljs-string">&#x27;smooth&#x27;</span>
});
</code></pre><p><code>window.scroll()</code>方法是<code>window.scrollTo()</code>方法的别名。</p><p><code>window.scrollBy()</code>方法用于将网页滚动指定距离（单位像素）。它接受两个参数：水平向右滚动的像素，垂直向下滚动的像素。</p><pre class="hljs"><code><span class="hljs-built_in">window</span>.scrollBy(<span class="hljs-number">0</span>, <span class="hljs-built_in">window</span>.innerHeight)
</code></pre><p>上面代码用于将网页向下滚动一屏。</p><p>如果不是要滚动整个文档，而是要滚动某个元素，可以使用下面三个属性和方法。</p><ul><li>Element.scrollTop</li><li>Element.scrollLeft</li><li>Element.scrollIntoView()</li></ul><h3 id="windowprint">window.print() <a class="markdownIt-Anchor" href="#windowprint">#</a></h3><p><code>window.print</code>方法会跳出打印对话框，与用户点击菜单里面的“打印”命令效果相同。</p><p>常见的打印按钮代码如下。</p><pre class="hljs"><code><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;printLink&#x27;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">window</span>.print();
}
</code></pre><p>非桌面设备（比如手机）可能没有打印功能，这时可以这样判断。</p><pre class="hljs"><code><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span>.print === <span class="hljs-string">&#x27;function&#x27;</span>) {
  <span class="hljs-comment">// 支持打印功能</span>
}
</code></pre><h3 id="windowfocus，windowblur">window.focus()，window.blur() <a class="markdownIt-Anchor" href="#windowfocus，windowblur">#</a></h3><p><code>window.focus()</code>方法会激活窗口，使其获得焦点，出现在其他窗口的前面。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> popup = <span class="hljs-built_in">window</span>.open(<span class="hljs-string">&#x27;popup.html&#x27;</span>, <span class="hljs-string">&#x27;Popup Window&#x27;</span>);

<span class="hljs-keyword">if</span> ((popup !== <span class="hljs-literal">null</span>) &amp;&amp; !popup.closed) {
  popup.focus();
}
</code></pre><p>上面代码先检查<code>popup</code>窗口是否依然存在，确认后激活该窗口。</p><p><code>window.blur()</code>方法将焦点从窗口移除。</p><p>当前窗口获得焦点时，会触发<code>focus</code>事件；当前窗口失去焦点时，会触发<code>blur</code>事件。</p><h3 id="windowgetselection">window.getSelection() <a class="markdownIt-Anchor" href="#windowgetselection">#</a></h3><p><code>window.getSelection</code>方法返回一个<code>Selection</code>对象，表示用户现在选中的文本。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> selObj = <span class="hljs-built_in">window</span>.getSelection();
</code></pre><p>使用<code>Selection</code>对象的<code>toString</code>方法可以得到选中的文本。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> selectedText = selObj.toString();
</code></pre><h3 id="windowgetcomputedstyle，windowmatchmedia">window.getComputedStyle()，window.matchMedia() <a class="markdownIt-Anchor" href="#windowgetcomputedstyle，windowmatchmedia">#</a></h3><p><code>window.getComputedStyle()</code>方法接受一个元素节点作为参数，返回一个包含该元素的最终样式信息的对象，详见《CSS 操作》一章。</p><p><code>window.matchMedia()</code>方法用来检查 CSS 的<code>mediaQuery</code>语句，详见《CSS 操作》一章。</p><h3 id="windowrequestanimationframe">window.requestAnimationFrame() <a class="markdownIt-Anchor" href="#windowrequestanimationframe">#</a></h3><p><code>window.requestAnimationFrame()</code>方法跟<code>setTimeout</code>类似，都是推迟某个函数的执行。不同之处在于，<code>setTimeout</code>必须指定推迟的时间，<code>window.requestAnimationFrame()</code>则是推迟到浏览器下一次重流时执行，执行完才会进行下一次重绘。重绘通常是 16ms 执行一次，不过浏览器会自动调节这个速率，比如网页切换到后台 Tab 页时，<code>requestAnimationFrame()</code>会暂停执行。</p><p>如果某个函数会改变网页的布局，一般就放在<code>window.requestAnimationFrame()</code>里面执行，这样可以节省系统资源，使得网页效果更加平滑。因为慢速设备会用较慢的速率重流和重绘，而速度更快的设备会有更快的速率。</p><p>该方法接受一个回调函数作为参数。</p><pre class="hljs"><code><span class="hljs-built_in">window</span>.requestAnimationFrame(callback)
</code></pre><p>上面代码中，<code>callback</code>是一个回调函数。<code>callback</code>执行时，它的参数就是系统传入的一个高精度时间戳（<code>performance.now()</code>的返回值），单位是毫秒，表示距离网页加载的时间。</p><p><code>window.requestAnimationFrame()</code>的返回值是一个整数，这个整数可以传入<code>window.cancelAnimationFrame()</code>，用来取消回调函数的执行。</p><p>下面是一个<code>window.requestAnimationFrame()</code>执行网页动画的例子。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> element = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;animate&#x27;</span>);
element.style.position = <span class="hljs-string">&#x27;absolute&#x27;</span>;

<span class="hljs-keyword">var</span> start = <span class="hljs-literal">null</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step</span>(<span class="hljs-params">timestamp</span>) </span>{
  <span class="hljs-keyword">if</span> (!start) start = timestamp;
  <span class="hljs-keyword">var</span> progress = timestamp - start;
  <span class="hljs-comment">// 元素不断向左移，最大不超过200像素</span>
  element.style.left = <span class="hljs-built_in">Math</span>.min(progress / <span class="hljs-number">10</span>, <span class="hljs-number">200</span>) + <span class="hljs-string">&#x27;px&#x27;</span>;
  <span class="hljs-comment">// 如果距离第一次执行不超过 2000 毫秒，</span>
  <span class="hljs-comment">// 就继续执行动画</span>
  <span class="hljs-keyword">if</span> (progress &lt; <span class="hljs-number">2000</span>) {
    <span class="hljs-built_in">window</span>.requestAnimationFrame(step);
  }
}

<span class="hljs-built_in">window</span>.requestAnimationFrame(step);
</code></pre><p>上面代码定义了一个网页动画，持续时间是2秒，会让元素向右移动。</p><h3 id="windowrequestidlecallback">window.requestIdleCallback() <a class="markdownIt-Anchor" href="#windowrequestidlecallback">#</a></h3><p><code>window.requestIdleCallback()</code>跟<code>setTimeout</code>类似，也是将某个函数推迟执行，但是它保证将回调函数推迟到系统资源空闲时执行。也就是说，如果某个任务不是很关键，就可以使用<code>window.requestIdleCallback()</code>将其推迟执行，以保证网页性能。</p><p>它跟<code>window.requestAnimationFrame()</code>的区别在于，后者指定回调函数在下一次浏览器重排时执行，问题在于下一次重排时，系统资源未必空闲，不一定能保证在16毫秒之内完成；<code>window.requestIdleCallback()</code>可以保证回调函数在系统资源空闲时执行。</p><p>该方法接受一个回调函数和一个配置对象作为参数。配置对象可以指定一个推迟执行的最长时间，如果过了这个时间，回调函数不管系统资源有无空闲，都会执行。</p><pre class="hljs"><code><span class="hljs-built_in">window</span>.requestIdleCallback(callback[, options])
</code></pre><p><code>callback</code>参数是一个回调函数。该回调函数执行时，系统会传入一个<code>IdleDeadline</code>对象作为参数。<code>IdleDeadline</code>对象有一个<code>didTimeout</code>属性（布尔值，表示是否为超时调用）和一个<code>timeRemaining()</code>方法（返回该空闲时段剩余的毫秒数）。</p><p><code>options</code>参数是一个配置对象，目前只有<code>timeout</code>一个属性，用来指定回调函数推迟执行的最大毫秒数。该参数可选。</p><p><code>window.requestIdleCallback()</code>方法返回一个整数。该整数可以传入<code>window.cancelIdleCallback()</code>取消回调函数。</p><p>下面是一个例子。</p><pre class="hljs"><code>requestIdleCallback(myNonEssentialWork);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myNonEssentialWork</span>(<span class="hljs-params">deadline</span>) </span>{
  <span class="hljs-keyword">while</span> (deadline.timeRemaining() &gt; <span class="hljs-number">0</span>) {
    doWorkIfNeeded();
  }
}
</code></pre><p>上面代码中，<code>requestIdleCallback()</code>用来执行非关键任务<code>myNonEssentialWork</code>。该任务先确认本次空闲时段有剩余时间，然后才真正开始执行任务。</p><p>下面是指定<code>timeout</code>的例子。</p><pre class="hljs"><code>requestIdleCallback(processPendingAnalyticsEvents, { <span class="hljs-attr">timeout</span>: <span class="hljs-number">2000</span> });
</code></pre><p>上面代码指定，<code>processPendingAnalyticsEvents</code>必须在未来2秒之内执行。</p><p>如果由于超时导致回调函数执行，则<code>deadline.timeRemaining()</code>返回<code>0</code>，<code>deadline.didTimeout</code>返回<code>true</code>。</p><p>如果多次执行<code>window.requestIdleCallback()</code>，指定多个回调函数，那么这些回调函数将排成一个队列，按照先进先出的顺序执行。</p><h2 id="事件">事件 <a class="markdownIt-Anchor" href="#事件">#</a></h2><p><code>window</code>对象可以接收以下事件。</p><h3 id="load-事件和-onload-属性">load 事件和 onload 属性 <a class="markdownIt-Anchor" href="#load-事件和-onload-属性">#</a></h3><p><code>load</code>事件发生在文档在浏览器窗口加载完毕时。<code>window.onload</code>属性可以指定这个事件的回调函数。</p><pre class="hljs"><code><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> elements = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&#x27;example&#x27;</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; elements.length; i++) {
    <span class="hljs-keyword">var</span> elt = elements[i];
    <span class="hljs-comment">// ...</span>
  }
};
</code></pre><p>上面代码在网页加载完毕后，获取指定元素并进行处理。</p><h3 id="error-事件和-onerror-属性">error 事件和 onerror 属性 <a class="markdownIt-Anchor" href="#error-事件和-onerror-属性">#</a></h3><p>浏览器脚本发生错误时，会触发<code>window</code>对象的<code>error</code>事件。我们可以通过<code>window.onerror</code>属性对该事件指定回调函数。</p><pre class="hljs"><code><span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message, filename, lineno, colno, error</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;出错了！--&gt; %s&quot;</span>, error.stack);
};
</code></pre><p>由于历史原因，<code>window</code>的<code>error</code>事件的回调函数不接受错误对象作为参数，而是一共可以接受五个参数，它们的含义依次如下。</p><ul><li>出错信息</li><li>出错脚本的网址</li><li>行号</li><li>列号</li><li>错误对象</li></ul><p>老式浏览器只支持前三个参数。</p><p>并不是所有的错误，都会触发 JavaScript 的<code>error</code>事件（即让 JavaScript 报错）。一般来说，只有 JavaScript 脚本的错误，才会触发这个事件，而像资源文件不存在之类的错误，都不会触发。</p><p>下面是一个例子，如果整个页面未捕获错误超过3个，就显示警告。</p><pre class="hljs"><code><span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg, url, line</span>) </span>{
  <span class="hljs-keyword">if</span> (onerror.num++ &gt; onerror.max) {
    alert(<span class="hljs-string">&#x27;ERROR: &#x27;</span> + msg + <span class="hljs-string">&#x27;\n&#x27;</span> + url + <span class="hljs-string">&#x27;:&#x27;</span> + line);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
}
onerror.max = <span class="hljs-number">3</span>;
onerror.num = <span class="hljs-number">0</span>;
</code></pre><p>需要注意的是，如果脚本网址与网页网址不在同一个域（比如使用了 CDN），浏览器根本不会提供详细的出错信息，只会提示出错，错误类型是“Script error.”，行号为0，其他信息都没有。这是浏览器防止向外部脚本泄漏信息。一个解决方法是在脚本所在的服务器，设置<code>Access-Control-Allow-Origin</code>的 HTTP 头信息。</p><pre class="hljs"><code>Access-Control-Allow-Origin: *
</code></pre><p>然后，在网页的<code>&lt;script&gt;</code>标签中设置<code>crossorigin</code>属性。</p><pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">&quot;anonymous&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//example.com/file.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre><p>上面代码的<code>crossorigin=&quot;anonymous&quot;</code>表示，读取文件不需要身份信息，即不需要 cookie 和 HTTP 认证信息。如果设为<code>crossorigin=&quot;use-credentials&quot;</code>，就表示浏览器会上传 cookie 和 HTTP 认证信息，同时还需要服务器端打开 HTTP 头信息<code>Access-Control-Allow-Credentials</code>。</p><h3 id="window-对象的事件监听属性">window 对象的事件监听属性 <a class="markdownIt-Anchor" href="#window-对象的事件监听属性">#</a></h3><p>除了具备元素节点都有的 GlobalEventHandlers 接口，<code>window</code>对象还具有以下的事件监听函数属性。</p><ul><li><code>window.onafterprint</code>：<code>afterprint</code>事件的监听函数。</li><li><code>window.onbeforeprint</code>：<code>beforeprint</code>事件的监听函数。</li><li><code>window.onbeforeunload</code>：<code>beforeunload</code>事件的监听函数。</li><li><code>window.onhashchange</code>：<code>hashchange</code>事件的监听函数。</li><li><code>window.onlanguagechange</code>: <code>languagechange</code>的监听函数。</li><li><code>window.onmessage</code>：<code>message</code>事件的监听函数。</li><li><code>window.onmessageerror</code>：<code>MessageError</code>事件的监听函数。</li><li><code>window.onoffline</code>：<code>offline</code>事件的监听函数。</li><li><code>window.ononline</code>：<code>online</code>事件的监听函数。</li><li><code>window.onpagehide</code>：<code>pagehide</code>事件的监听函数。</li><li><code>window.onpageshow</code>：<code>pageshow</code>事件的监听函数。</li><li><code>window.onpopstate</code>：<code>popstate</code>事件的监听函数。</li><li><code>window.onstorage</code>：<code>storage</code>事件的监听函数。</li><li><code>window.onunhandledrejection</code>：未处理的 Promise 对象的<code>reject</code>事件的监听函数。</li><li><code>window.onunload</code>：<code>unload</code>事件的监听函数。</li></ul><h2 id="多窗口操作">多窗口操作 <a class="markdownIt-Anchor" href="#多窗口操作">#</a></h2><p>由于网页可以使用<code>iframe</code>元素，嵌入其他网页，因此一个网页之中会形成多个窗口。如果子窗口之中又嵌入别的网页，就会形成多级窗口。</p><h3 id="窗口的引用">窗口的引用 <a class="markdownIt-Anchor" href="#窗口的引用">#</a></h3><p>各个窗口之中的脚本，可以引用其他窗口。浏览器提供了一些特殊变量，用来返回其他窗口。</p><ul><li><code>top</code>：顶层窗口，即最上层的那个窗口</li><li><code>parent</code>：父窗口</li><li><code>self</code>：当前窗口，即自身</li></ul><p>下面代码可以判断，当前窗口是否为顶层窗口。</p><pre class="hljs"><code><span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.top === <span class="hljs-built_in">window</span>.self) {
  <span class="hljs-comment">// 当前窗口是顶层窗口</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// 当前窗口是子窗口</span>
}
</code></pre><p>下面的代码让父窗口的访问历史后退一次。</p><pre class="hljs"><code><span class="hljs-built_in">window</span>.parent.history.back();
</code></pre><p>与这些变量对应，浏览器还提供一些特殊的窗口名，供<code>window.open()</code>方法、<code>&lt;a&gt;</code>标签、<code>&lt;form&gt;</code>标签等引用。</p><ul><li><code>_top</code>：顶层窗口</li><li><code>_parent</code>：父窗口</li><li><code>_blank</code>：新窗口</li></ul><p>下面代码就表示在顶层窗口打开链接。</p><pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;somepage.html&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_top&quot;</span>&gt;</span>Link<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
</code></pre><h3 id="iframe-元素">iframe 元素 <a class="markdownIt-Anchor" href="#iframe-元素">#</a></h3><p>对于<code>iframe</code>嵌入的窗口，<code>document.getElementById</code>方法可以拿到该窗口的 DOM 节点，然后使用<code>contentWindow</code>属性获得<code>iframe</code>节点包含的<code>window</code>对象。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> frame = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;theFrame&#x27;</span>);
<span class="hljs-keyword">var</span> frameWindow = frame.contentWindow;
</code></pre><p>上面代码中，<code>frame.contentWindow</code>可以拿到子窗口的<code>window</code>对象。然后，在满足同源限制的情况下，可以读取子窗口内部的属性。</p><pre class="hljs"><code><span class="hljs-comment">// 获取子窗口的标题</span>
frameWindow.title
</code></pre><p><code>&lt;iframe&gt;</code>元素的<code>contentDocument</code>属性，可以拿到子窗口的<code>document</code>对象。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> frame = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;theFrame&#x27;</span>);
<span class="hljs-keyword">var</span> frameDoc = frame.contentDocument;

<span class="hljs-comment">// 等同于</span>
<span class="hljs-keyword">var</span> frameDoc = frame.contentWindow.document;
</code></pre><p><code>&lt;iframe&gt;</code>元素遵守同源政策，只有当父窗口与子窗口在同一个域时，两者之间才可以用脚本通信，否则只有使用<code>window.postMessage</code>方法。</p><p><code>&lt;iframe&gt;</code>窗口内部，使用<code>window.parent</code>引用父窗口。如果当前页面没有父窗口，则<code>window.parent</code>属性返回自身。因此，可以通过<code>window.parent</code>是否等于<code>window.self</code>，判断当前窗口是否为<code>iframe</code>窗口。</p><pre class="hljs"><code><span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.parent !== <span class="hljs-built_in">window</span>.self) {
  <span class="hljs-comment">// 当前窗口是子窗口</span>
}
</code></pre><p><code>&lt;iframe&gt;</code>窗口的<code>window</code>对象，有一个<code>frameElement</code>属性，返回<code>&lt;iframe&gt;</code>在父窗口中的 DOM 节点。对于非嵌入的窗口，该属性等于<code>null</code>。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> f1Element = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;f1&#x27;</span>);
<span class="hljs-keyword">var</span> f1Window = f1Element.contentWindow;

f1Window.frameElement === f1Element <span class="hljs-comment">// true</span>
<span class="hljs-built_in">window</span>.frameElement === <span class="hljs-literal">null</span> <span class="hljs-comment">// true</span>
</code></pre><h3 id="windowframes-属性">window.frames 属性 <a class="markdownIt-Anchor" href="#windowframes-属性">#</a></h3><p><code>window.frames</code>属性返回一个类似数组的对象，成员是所有子窗口的<code>window</code>对象。可以使用这个属性，实现窗口之间的互相引用。比如，<code>frames[0]</code>返回第一个子窗口，<code>frames[1].frames[2]</code>返回第二个子窗口内部的第三个子窗口，<code>parent.frames[1]</code>返回父窗口的第二个子窗口。</p><p>注意，<code>window.frames</code>每个成员的值，是框架内的窗口（即框架的<code>window</code>对象），而不是<code>iframe</code>标签在父窗口的 DOM 节点。如果要获取每个框架内部的 DOM 树，需要使用<code>window.frames[0].document</code>的写法。</p><p>另外，如果<code>&lt;iframe&gt;</code>元素设置了<code>name</code>或<code>id</code>属性，那么属性值会自动成为全局变量，并且可以通过<code>window.frames</code>属性引用，返回子窗口的<code>window</code>对象。</p><pre class="hljs"><code><span class="hljs-comment">// HTML 代码为 &lt;iframe id=&quot;myFrame&quot;&gt;</span>
<span class="hljs-built_in">window</span>.myFrame <span class="hljs-comment">// [HTMLIFrameElement]</span>
frames.myframe === myFrame <span class="hljs-comment">// true</span>
</code></pre><p>另外，<code>name</code>属性的值会自动成为子窗口的名称，可以用在<code>window.open</code>方法的第二个参数，或者<code>&lt;a&gt;</code>和<code>&lt;frame&gt;</code>标签的<code>target</code>属性。</p></article><nav class="level level-previous-next is-size-5 is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="../bom/engine.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> 浏览器模型概述</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="../bom/navigator.html">Navigator 对象，Screen 对象 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><div class="page-info is-size-5-desktop"><p>本教程采用<a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh" target="_blank">知识共享 署名-相同方式共享 3.0协议</a>。</p><p>分享本文 <span class="social-share"></span></p></div></div><div class="column is-3 is-offset-1"><nav class="panel panel-menu"><p class="panel-heading"><i class="fa fa-book" aria-hidden="true"></i> JavaScript 教程</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="../basic/index.html"><span class="icon"><i class="fa fa-caret-down"></i> </span><i class="fa folder fa-folder-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">入门篇</span></a><ul><li><a href="../basic/introduction.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">导论</span></a></li><li><a href="../basic/history.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">历史</span></a></li><li><a href="../basic/grammar.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">基本语法</span></a></li></ul></li><li><a href="../types/index.html"><span class="icon"><i class="fa fa-caret-down"></i> </span><i class="fa folder fa-folder-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">数据类型</span></a><ul><li><a href="../types/general.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">概述</span></a></li><li><a href="../types/null-undefined-boolean.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">null，undefined 和布尔值</span></a></li><li><a href="../types/number.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">数值</span></a></li><li><a href="../types/string.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">字符串</span></a></li><li><a href="../types/object.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">对象</span></a></li><li><a href="../types/function.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">函数</span></a></li><li><a href="../types/array.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">数组</span></a></li></ul></li><li><a href="../operators/index.html"><span class="icon"><i class="fa fa-caret-down"></i> </span><i class="fa folder fa-folder-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">运算符</span></a><ul><li><a href="../operators/arithmetic.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">算术运算符</span></a></li><li><a href="../operators/comparison.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">比较运算符</span></a></li><li><a href="../operators/boolean.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">布尔运算符</span></a></li><li><a href="../operators/bit.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">二进制位运算符</span></a></li><li><a href="../operators/priority.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">其他运算符，运算顺序</span></a></li></ul></li><li><a href="../features/index.html"><span class="icon"><i class="fa fa-caret-down"></i> </span><i class="fa folder fa-folder-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">语法专题</span></a><ul><li><a href="../features/conversion.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">数据类型的转换</span></a></li><li><a href="../features/error.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">错误处理机制</span></a></li><li><a href="../features/style.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">编程风格</span></a></li><li><a href="../features/console.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">console 对象与控制台</span></a></li></ul></li><li><a href="../stdlib/index.html"><span class="icon"><i class="fa fa-caret-down"></i> </span><i class="fa folder fa-folder-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">标准库</span></a><ul><li><a href="../stdlib/object.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Object 对象</span></a></li><li><a href="../stdlib/attributes.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">属性描述对象</span></a></li><li><a href="../stdlib/array.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Array 对象</span></a></li><li><a href="../stdlib/wrapper.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">包装对象</span></a></li><li><a href="../stdlib/boolean.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Boolean 对象</span></a></li><li><a href="../stdlib/number.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Number 对象</span></a></li><li><a href="../stdlib/string.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">String 对象</span></a></li><li><a href="../stdlib/math.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Math 对象</span></a></li><li><a href="../stdlib/date.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Date 对象</span></a></li><li><a href="../stdlib/regexp.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">RegExp 对象</span></a></li><li><a href="../stdlib/json.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">JSON 对象</span></a></li></ul></li><li><a href="../oop/index.html"><span class="icon"><i class="fa fa-caret-down"></i> </span><i class="fa folder fa-folder-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">面向对象编程</span></a><ul><li><a href="../oop/new.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">实例对象与 new 命令</span></a></li><li><a href="../oop/this.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">this 关键字</span></a></li><li><a href="../oop/prototype.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">对象的继承</span></a></li><li><a href="../oop/object.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Object 对象的相关方法</span></a></li><li><a href="../oop/strict.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">严格模式</span></a></li></ul></li><li><a href="../async/index.html"><span class="icon"><i class="fa fa-caret-down"></i> </span><i class="fa folder fa-folder-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">异步操作</span></a><ul><li><a href="../async/general.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">概述</span></a></li><li><a href="../async/timer.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">定时器</span></a></li><li><a href="../async/promise.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Promise 对象</span></a></li></ul></li><li><a href="../dom/index.html"><span class="icon"><i class="fa fa-caret-down"></i> </span><i class="fa folder fa-folder-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">DOM</span></a><ul><li><a href="../dom/general.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">概述</span></a></li><li><a href="../dom/node.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Node 接口</span></a></li><li><a href="../dom/nodelist.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">NodeList 接口，HTMLCollection 接口</span></a></li><li><a href="../dom/parentnode.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">ParentNode 接口，ChildNode 接口</span></a></li><li><a href="../dom/document.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Document 节点</span></a></li><li><a href="../dom/element.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Element 节点</span></a></li><li><a href="../dom/attributes.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">属性的操作</span></a></li><li><a href="../dom/text.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Text 节点和 DocumentFragment 节点</span></a></li><li><a href="../dom/css.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">CSS 操作</span></a></li><li><a href="../dom/mutationobserver.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Mutation Observer API</span></a></li></ul></li><li><a href="../events/index.html"><span class="icon"><i class="fa fa-caret-down"></i> </span><i class="fa folder fa-folder-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">事件</span></a><ul><li><a href="../events/eventtarget.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">EventTarget 接口</span></a></li><li><a href="../events/model.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">事件模型</span></a></li><li><a href="../events/event.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Event 对象</span></a></li><li><a href="../events/mouse.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">鼠标事件</span></a></li><li><a href="../events/keyboard.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">键盘事件</span></a></li><li><a href="../events/progress.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">进度事件</span></a></li><li><a href="../events/form.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">表单事件</span></a></li><li><a href="../events/touch.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">触摸事件</span></a></li><li><a href="../events/drag.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">拖拉事件</span></a></li><li><a href="../events/common.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">其他常见事件</span></a></li><li><a href="../events/globaleventhandlers.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">GlobalEventHandlers 接口</span></a></li></ul></li><li><a href="../bom/index.html"><span class="icon"><i class="fa fa-caret-down"></i> </span><i class="fa folder fa-folder-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">浏览器模型</span></a><ul><li><a href="../bom/engine.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">浏览器模型概述</span></a></li><li><a href="../bom/window.html" class="is-active"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">window 对象</span></a></li><li><a href="../bom/navigator.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Navigator 对象，Screen 对象</span></a></li><li><a href="../bom/cookie.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Cookie</span></a></li><li><a href="../bom/xmlhttprequest.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">XMLHttpRequest 对象</span></a></li><li><a href="../bom/same-origin.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">同源限制</span></a></li><li><a href="../bom/cors.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">CORS 通信</span></a></li><li><a href="../bom/storage.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Storage 接口</span></a></li><li><a href="../bom/history.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">History 对象</span></a></li><li><a href="../bom/location.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Location 对象，URL 对象，URLSearchParams 对象</span></a></li><li><a href="../bom/arraybuffer.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">ArrayBuffer 对象，Blob 对象</span></a></li><li><a href="../bom/file.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">File 对象，FileList 对象，FileReader 对象</span></a></li><li><a href="../bom/form.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">表单，FormData 对象</span></a></li><li><a href="../bom/indexeddb.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">IndexedDB API</span></a></li><li><a href="../bom/webworker.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Web Worker</span></a></li></ul></li><li><a href="../elements/index.html"><span class="icon"><i class="fa fa-caret-down"></i> </span><i class="fa folder fa-folder-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">附录：网页元素接口</span></a><ul><li><a href="../elements/a.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">&lt;a&gt;</span></a></li><li><a href="../elements/image.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">&lt;img&gt;</span></a></li><li><a href="../elements/form.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">&lt;form&gt;</span></a></li><li><a href="../elements/input.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">&lt;input&gt;</span></a></li><li><a href="../elements/button.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">&lt;button&gt;</span></a></li><li><a href="../elements/option.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">&lt;option&gt;</span></a></li><li><a href="../elements/video.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">&lt;video&gt;，&lt;audio&gt;</span></a></li></ul></li></ul></aside></div></nav><nav class="panel panel-info"><p class="panel-heading"><i class="fa fa-link" aria-hidden="true"></i> 链接</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="https://raw.githubusercontent.com/wangdoc/javascript-tutorial/master/docs/bom/window.md" target="_blank"><span class="icon"></span><i class="fa fa-code" aria-hidden="true" style="width: 14px;"></i>&nbsp;本文源码</a></li><li><a href="https://github.com/wangdoc/javascript-tutorial" target="_blank"><span class="icon"></span><i class="fa fa-hdd-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;代码仓库</a></li><li><a href="https://github.com/wangdoc/javascript-tutorial/issues" target="_blank"><span class="icon"></span><i class="fa fa-flag-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;反馈</a></li></ul></aside></div></nav></div></div><div class="columns"><div class="column is-8"><div id="disqus_thread"></div></div></div></div></section><footer class="footer is-size-5-desktop"><div class="container"><div class="content has-text-centered"><p>联系：contact@wangdoc.com</p></div></div></footer><script>var LOPPO={current_path:"bom/window.md",relative_root_path:"../",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li>\n<li><a href="#window-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7">window 对象的属性</a>\n<ul>\n<li><a href="#windowname">window.name</a></li>\n<li><a href="#windowclosed%EF%BC%8Cwindowopener">window.closed，window.opener</a></li>\n<li><a href="#windowself%EF%BC%8Cwindowwindow">window.self，window.window</a></li>\n<li><a href="#windowframes%EF%BC%8Cwindowlength">window.frames，window.length</a></li>\n<li><a href="#windowframeelement">window.frameElement</a></li>\n<li><a href="#windowtop%EF%BC%8Cwindowparent">window.top，window.parent</a></li>\n<li><a href="#windowstatus">window.status</a></li>\n<li><a href="#windowdevicepixelratio">window.devicePixelRatio</a></li>\n<li><a href="#%E4%BD%8D%E7%BD%AE%E5%A4%A7%E5%B0%8F%E5%B1%9E%E6%80%A7">位置大小属性</a></li>\n<li><a href="#%E7%BB%84%E4%BB%B6%E5%B1%9E%E6%80%A7">组件属性</a></li>\n<li><a href="#%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">全局对象属性</a></li>\n<li><a href="#windowissecurecontext">window.isSecureContext</a></li>\n</ul>\n</li>\n<li><a href="#window-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95">window 对象的方法</a>\n<ul>\n<li><a href="#windowalert%EF%BC%8Cwindowprompt%EF%BC%8Cwindowconfirm">window.alert()，window.prompt()，window.confirm()</a></li>\n<li><a href="#windowopen-windowclose%EF%BC%8Cwindowstop">window.open(), window.close()，window.stop()</a></li>\n<li><a href="#windowmoveto%EF%BC%8Cwindowmoveby">window.moveTo()，window.moveBy()</a></li>\n<li><a href="#windowresizeto%EF%BC%8Cwindowresizeby">window.resizeTo()，window.resizeBy()</a></li>\n<li><a href="#windowscrollto%EF%BC%8Cwindowscroll%EF%BC%8Cwindowscrollby">window.scrollTo()，window.scroll()，window.scrollBy()</a></li>\n<li><a href="#windowprint">window.print()</a></li>\n<li><a href="#windowfocus%EF%BC%8Cwindowblur">window.focus()，window.blur()</a></li>\n<li><a href="#windowgetselection">window.getSelection()</a></li>\n<li><a href="#windowgetcomputedstyle%EF%BC%8Cwindowmatchmedia">window.getComputedStyle()，window.matchMedia()</a></li>\n<li><a href="#windowrequestanimationframe">window.requestAnimationFrame()</a></li>\n<li><a href="#windowrequestidlecallback">window.requestIdleCallback()</a></li>\n</ul>\n</li>\n<li><a href="#%E4%BA%8B%E4%BB%B6">事件</a>\n<ul>\n<li><a href="#load-%E4%BA%8B%E4%BB%B6%E5%92%8C-onload-%E5%B1%9E%E6%80%A7">load 事件和 onload 属性</a></li>\n<li><a href="#error-%E4%BA%8B%E4%BB%B6%E5%92%8C-onerror-%E5%B1%9E%E6%80%A7">error 事件和 onerror 属性</a></li>\n<li><a href="#window-%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%B1%9E%E6%80%A7">window 对象的事件监听属性</a></li>\n</ul>\n</li>\n<li><a href="#%E5%A4%9A%E7%AA%97%E5%8F%A3%E6%93%8D%E4%BD%9C">多窗口操作</a>\n<ul>\n<li><a href="#%E7%AA%97%E5%8F%A3%E7%9A%84%E5%BC%95%E7%94%A8">窗口的引用</a></li>\n<li><a href="#iframe-%E5%85%83%E7%B4%A0">iframe 元素</a></li>\n<li><a href="#windowframes-%E5%B1%9E%E6%80%A7">window.frames 属性</a></li>\n</ul>\n</li>\n</ul>\n'}</script><script src="../assets/js/app.js"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-111269443-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-111269443-1")</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?5eec262881855af3dede6a71234571f6";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/

var disqus_config = function () {
const l = window.location;
const url = l.protocol + '//' + l.host + (l.port ? ':' + l.port : '') + l.pathname;
this.page.url = url;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = l.pathname; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://wangdoc-javascript.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();</script><!--script src="../assets/js/social-share.min.js"--><!--/script--><script>var shareDesc="我正在阅读《window 对象》，出自网道（WangDoc.com）的《JavaScript 教程》。",shareOpts={url:window.location.href,source:shareDesc,title:shareDesc,description:"",image:"",sites:["weibo","wechat","qq","qzone","twitter","facebook"],origin:"WangDoc_com",disabled:[],wechatQrcodeTitle:"微信",wechatQrcodeHelper:"扫一下二维码，分享到微信。"};socialShare(".social-share",shareOpts)</script></body></html>