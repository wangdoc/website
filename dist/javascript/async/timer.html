<!DOCTYPE html><html prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>定时器 - JavaScript 教程 - 网道</title><!-- link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" --><link rel="stylesheet" href="../assets/css/app.min.css"><link rel="stylesheet" href="https://apps.bdimg.com/libs/fontawesome/4.4.0/css/font-awesome.css"><!-- link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css"--><!-- link rel="stylesheet" href="../assets/css/share.min.css" --><meta property="og:type" content="article"><meta property="og:title" content="定时器"><link rel="apple-touch-icon" sizes="57x57" href="../assets/icons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="../assets/icons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="../assets/icons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="../assets/icons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="../assets/icons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="../assets/icons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="../assets/icons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="../assets/icons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="../assets/icons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="../assets/icons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="../assets/icons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="../assets/icons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="../assets/icons/favicon-16x16.png"><link rel="manifest" href="../assets/icons/manifest.json"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="../assets/icons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"></head><body><nav class="navbar is-light" role="navigation" id="navbar" aria-label="main navigation"><div class="container"><div class="navbar-brand"><a href="../index.html" class="navbar-item title has-text-grey has-text-weight-light is-5">网道 / WangDoc.com</a></div><div class="navbar-menu"><div class="navbar-end"><a class="navbar-item is-hidden-desktop-only" target="_blank" href="https://github.com/wangdoc/javascript-tutorial"><span class="icon" style="color: #333;"><i class="fa fa-lg fa-github"></i></span></a></div></div></div></nav><section class="section main article"><div class="container"><div class="columns"><div class="column is-8"><nav class="breadcrumb is-size-5-desktop" aria-label="breadcrumbs"><ul><li><a href="../index.html"><span class="icon"><i class="fa fa-home"></i></span> &nbsp;JavaScript 教程</a></li><li><a href="../async/index.html">异步操作</a></li><li class="is-active"><a class="has-text-grey" href="../async/timer.html">定时器</a></li></ul></nav><nav class="level level-previous-next is-size-5 is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="../async/general.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> 概述</a></p></div><div class="level-right"><p class="level-item is-narrow"></p></div></nav><article class="content is-size-4-desktop"><h1 class="title">定时器</h1><div class="page-meta"><p>出自网道（WangDoc.com），互联网开发文档</p></div><p>JavaScript 提供定时执行代码的功能，叫做定时器（timer），主要由<code>setTimeout()</code>和<code>setInterval()</code>这两个函数来完成。它们向任务队列添加定时任务。</p><h2 id="settimeout">setTimeout() <a class="markdownIt-Anchor" href="#settimeout">#</a></h2><p><code>setTimeout</code>函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> timerId = setTimeout(func|code, delay);
</code></pre><p>上面代码中，<code>setTimeout</code>函数接受两个参数，第一个参数<code>func|code</code>是将要推迟执行的函数名或者一段代码，第二个参数<code>delay</code>是推迟执行的毫秒数。</p><pre class="hljs"><code><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);
setTimeout(<span class="hljs-string">'console.log(2)'</span>,<span class="hljs-number">1000</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);
<span class="hljs-comment">// 1</span>
<span class="hljs-comment">// 3</span>
<span class="hljs-comment">// 2</span>
</code></pre><p>上面代码会先输出1和3，然后等待1000毫秒再输出2。注意，<code>console.log(2)</code>必须以字符串的形式，作为<code>setTimeout</code>的参数。</p><p>如果推迟执行的是函数，就直接将函数名，作为<code>setTimeout</code>的参数。</p><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);
}

setTimeout(f, <span class="hljs-number">1000</span>);
</code></pre><p><code>setTimeout</code>的第二个参数如果省略，则默认为0。</p><pre class="hljs"><code>setTimeout(f)
<span class="hljs-comment">// 等同于</span>
setTimeout(f, <span class="hljs-number">0</span>)
</code></pre><p>除了前两个参数，<code>setTimeout</code>还允许更多的参数。它们将依次传入推迟执行的函数（回调函数）。</p><pre class="hljs"><code>setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a,b</span>) </span>{
  <span class="hljs-built_in">console</span>.log(a + b);
}, <span class="hljs-number">1000</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
</code></pre><p>上面代码中，<code>setTimeout</code>共有4个参数。最后那两个参数，将在1000毫秒之后回调函数执行时，作为回调函数的参数。</p><p>还有一个需要注意的地方，如果回调函数是对象的方法，那么<code>setTimeout</code>使得方法内部的<code>this</code>关键字指向全局环境，而不是定义时所在的那个对象。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;

<span class="hljs-keyword">var</span> obj = {
  <span class="hljs-attr">x</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.x);
  }
};

setTimeout(obj.y, <span class="hljs-number">1000</span>) <span class="hljs-comment">// 1</span>
</code></pre><p>上面代码输出的是1，而不是2。因为当<code>obj.y</code>在1000毫秒后运行时，<code>this</code>所指向的已经不是<code>obj</code>了，而是全局环境。</p><p>为了防止出现这个问题，一种解决方法是将<code>obj.y</code>放入一个函数。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;

<span class="hljs-keyword">var</span> obj = {
  <span class="hljs-attr">x</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.x);
  }
};

setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  obj.y();
}, <span class="hljs-number">1000</span>);
<span class="hljs-comment">// 2</span>
</code></pre><p>上面代码中，<code>obj.y</code>放在一个匿名函数之中，这使得<code>obj.y</code>在<code>obj</code>的作用域执行，而不是在全局作用域内执行，所以能够显示正确的值。</p><p>另一种解决方法是，使用<code>bind</code>方法，将<code>obj.y</code>这个方法绑定在<code>obj</code>上面。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;

<span class="hljs-keyword">var</span> obj = {
  <span class="hljs-attr">x</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.x);
  }
};

setTimeout(obj.y.bind(obj), <span class="hljs-number">1000</span>)
<span class="hljs-comment">// 2</span>
</code></pre><h2 id="setinterval">setInterval() <a class="markdownIt-Anchor" href="#setinterval">#</a></h2><p><code>setInterval</code>函数的用法与<code>setTimeout</code>完全一致，区别仅仅在于<code>setInterval</code>指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>
<span class="hljs-keyword">var</span> timer = setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);
}, <span class="hljs-number">1000</span>)
</code></pre><p>上面代码中，每隔1000毫秒就输出一个2，会无限运行下去，直到关闭当前窗口。</p><p>与<code>setTimeout</code>一样，除了前两个参数，<code>setInterval</code>方法还可以接受更多的参数，它们会传入回调函数。</p><p>下面是一个通过<code>setInterval</code>方法实现网页动画的例子。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'someDiv'</span>);
<span class="hljs-keyword">var</span> opacity = <span class="hljs-number">1</span>;
<span class="hljs-keyword">var</span> fader = setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  opacity -= <span class="hljs-number">0.1</span>;
  <span class="hljs-keyword">if</span> (opacity &gt;= <span class="hljs-number">0</span>) {
    div.style.opacity = opacity;
  } <span class="hljs-keyword">else</span> {
    clearInterval(fader);
  }
}, <span class="hljs-number">100</span>);
</code></pre><p>上面代码每隔100毫秒，设置一次<code>div</code>元素的透明度，直至其完全透明为止。</p><p><code>setInterval</code>的一个常见用途是实现轮询。下面是一个轮询 URL 的 Hash 值是否发生变化的例子。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> hash = <span class="hljs-built_in">window</span>.location.hash;
<span class="hljs-keyword">var</span> hashWatcher = setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.location.hash != hash) {
    updatePage();
  }
}, <span class="hljs-number">1000</span>);
</code></pre><p><code>setInterval</code>指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会小于指定的时间。比如，<code>setInterval</code>指定每 100ms 执行一次，每次执行需要 5ms，那么第一次执行结束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始。</p><p>为了确保两次执行之间有固定的间隔，可以不用<code>setInterval</code>，而是每次执行结束后，使用<code>setTimeout</code>指定下一次执行的具体时间。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;
<span class="hljs-keyword">var</span> timer = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// ...</span>
  timer = setTimeout(f, <span class="hljs-number">2000</span>);
}, <span class="hljs-number">2000</span>);
</code></pre><p>上面代码可以确保，下一次执行总是在本次执行结束之后的2000毫秒开始。</p><h2 id="cleartimeout，clearinterval">clearTimeout()，clearInterval() <a class="markdownIt-Anchor" href="#cleartimeout，clearinterval">#</a></h2><p><code>setTimeout</code>和<code>setInterval</code>函数，都返回一个整数值，表示计数器编号。将该整数传入<code>clearTimeout</code>和<code>clearInterval</code>函数，就可以取消对应的定时器。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> id1 = setTimeout(f, <span class="hljs-number">1000</span>);
<span class="hljs-keyword">var</span> id2 = setInterval(f, <span class="hljs-number">1000</span>);

clearTimeout(id1);
clearInterval(id2);
</code></pre><p>上面代码中，回调函数<code>f</code>不会再执行了，因为两个定时器都被取消了。</p><p><code>setTimeout</code>和<code>setInterval</code>返回的整数值是连续的，也就是说，第二个<code>setTimeout</code>方法返回的整数值，将比第一个的整数值大1。</p><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{}
setTimeout(f, <span class="hljs-number">1000</span>) <span class="hljs-comment">// 10</span>
setTimeout(f, <span class="hljs-number">1000</span>) <span class="hljs-comment">// 11</span>
setTimeout(f, <span class="hljs-number">1000</span>) <span class="hljs-comment">// 12</span>
</code></pre><p>上面代码中，连续调用三次<code>setTimeout</code>，返回值都比上一次大了1。</p><p>利用这一点，可以写一个函数，取消当前所有的<code>setTimeout</code>定时器。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> gid = setInterval(clearAllTimeouts, <span class="hljs-number">0</span>);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearAllTimeouts</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> id = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{}, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">while</span> (id &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span> (id !== gid) {
        clearTimeout(id);
      }
      id--;
    }
  }
})();
</code></pre><p>上面代码中，先调用<code>setTimeout</code>，得到一个计算器编号，然后把编号比它小的计数器全部取消。</p><h2 id="实例：debounce-函数">实例：debounce 函数 <a class="markdownIt-Anchor" href="#实例：debounce-函数">#</a></h2><p>有时，我们不希望回调函数被频繁调用。比如，用户填入网页输入框的内容，希望通过 Ajax 方法传回服务器，jQuery 的写法如下。</p><pre class="hljs"><code>$(<span class="hljs-string">'textarea'</span>).on(<span class="hljs-string">'keydown'</span>, ajaxAction);
</code></pre><p>这样写有一个很大的缺点，就是如果用户连续击键，就会连续触发<code>keydown</code>事件，造成大量的 Ajax 通信。这是不必要的，而且很可能产生性能问题。正确的做法应该是，设置一个门槛值，表示两次 Ajax 通信的最小间隔时间。如果在间隔时间内，发生新的<code>keydown</code>事件，则不触发 Ajax 通信，并且重新开始计时。如果过了指定时间，没有发生新的<code>keydown</code>事件，再将数据发送出去。</p><p>这种做法叫做 debounce（防抖动）。假定两次 Ajax 通信的间隔不得小于2500毫秒，上面的代码可以改写成下面这样。</p><pre class="hljs"><code>$(<span class="hljs-string">'textarea'</span>).on(<span class="hljs-string">'keydown'</span>, debounce(ajaxAction, <span class="hljs-number">2500</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, delay</span>)</span>{
  <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 声明计时器</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;
    clearTimeout(timer);
    timer = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      fn.apply(context, args);
    }, delay);
  };
}
</code></pre><p>上面代码中，只要在2500毫秒之内，用户再次击键，就会取消上一次的定时器，然后再新建一个定时器。这样就保证了回调函数之间的调用间隔，至少是2500毫秒。</p><h2 id="运行机制">运行机制 <a class="markdownIt-Anchor" href="#运行机制">#</a></h2><p><code>setTimeout</code>和<code>setInterval</code>的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就继续等待。</p><p>这意味着，<code>setTimeout</code>和<code>setInterval</code>指定的回调函数，必须等到本轮事件循环的所有同步任务都执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，<code>setTimeout</code>和<code>setInterval</code>指定的任务，一定会按照预定时间执行。</p><pre class="hljs"><code>setTimeout(someTask, <span class="hljs-number">100</span>);
veryLongTask();
</code></pre><p>上面代码的<code>setTimeout</code>，指定100毫秒以后运行一个任务。但是，如果后面的<code>veryLongTask</code>函数（同步任务）运行时间非常长，过了100毫秒还无法结束，那么被推迟运行的<code>someTask</code>就只有等着，等到<code>veryLongTask</code>运行结束，才轮到它执行。</p><p>再看一个<code>setInterval</code>的例子。</p><pre class="hljs"><code>setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);
}, <span class="hljs-number">1000</span>);

sleep(<span class="hljs-number">3000</span>);
</code></pre><p>上面代码中，<code>setInterval</code>要求每隔1000毫秒，就输出一个2。但是，紧接着的<code>sleep</code>语句需要3000毫秒才能完成，那么<code>setInterval</code>就必须推迟到3000毫秒之后才开始生效。注意，生效后<code>setInterval</code>不会产生累积效应，即不会一下子输出三个2，而是只会输出一个2。</p><h2 id="settimeoutf-0">setTimeout(f, 0) <a class="markdownIt-Anchor" href="#settimeoutf-0">#</a></h2><h3 id="含义">含义 <a class="markdownIt-Anchor" href="#含义">#</a></h3><p><code>setTimeout</code>的作用是将代码推迟到指定时间执行，如果指定时间为<code>0</code>，即<code>setTimeout(f, 0)</code>，那么会立刻执行吗？</p><p>答案是不会。因为上一节说过，必须要等到当前脚本的同步任务，全部处理完以后，才会执行<code>setTimeout</code>指定的回调函数<code>f</code>。也就是说，<code>setTimeout(f, 0)</code>会在下一轮事件循环一开始就执行。</p><pre class="hljs"><code>setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);
}, <span class="hljs-number">0</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);
<span class="hljs-comment">// 2</span>
<span class="hljs-comment">// 1</span>
</code></pre><p>上面代码先输出<code>2</code>，再输出<code>1</code>。因为<code>2</code>是同步任务，在本轮事件循环执行，而<code>1</code>是下一轮事件循环执行。</p><p>总之，<code>setTimeout(f, 0)</code>这种写法的目的是，尽可能早地执行<code>f</code>，但是并不能保证立刻就执行<code>f</code>。</p><h3 id="应用">应用 <a class="markdownIt-Anchor" href="#应用">#</a></h3><p><code>setTimeout(f, 0)</code>有几个非常重要的用途。它的一大应用是，可以调整事件的发生顺序。比如，网页开发中，某个事件先发生在子元素，然后冒泡到父元素，即子元素的事件回调函数，会早于父元素的事件回调函数触发。如果，想让父元素的事件回调函数先发生，就要用到<code>setTimeout(f, 0)</code>。</p><pre class="hljs"><code><span class="hljs-comment">// HTML 代码如下</span>
<span class="hljs-comment">// &lt;input type="button" id="myButton" value="click"&gt;</span>

<span class="hljs-keyword">var</span> input = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'myButton'</span>);

input.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>{
  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>) </span>{
    input.value +=<span class="hljs-string">' input'</span>;
  }, <span class="hljs-number">0</span>)
};

<span class="hljs-built_in">document</span>.body.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">C</span>(<span class="hljs-params"></span>) </span>{
  input.value += <span class="hljs-string">' body'</span>
};
</code></pre><p>上面代码在点击按钮后，先触发回调函数<code>A</code>，然后触发函数<code>C</code>。函数<code>A</code>中，<code>setTimeout</code>将函数<code>B</code>推迟到下一轮事件循环执行，这样就起到了，先触发父元素的回调函数<code>C</code>的目的了。</p><p>另一个应用是，用户自定义的回调函数，通常在浏览器的默认动作之前触发。比如，用户在输入框输入文本，<code>keypress</code>事件会在浏览器接收文本之前触发。因此，下面的回调函数是达不到目的的。</p><pre class="hljs"><code><span class="hljs-comment">// HTML 代码如下</span>
<span class="hljs-comment">// &lt;input type="text" id="input-box"&gt;</span>

<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'input-box'</span>).onkeypress = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
  <span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">this</span>.value.toUpperCase();
}
</code></pre><p>上面代码想在用户每次输入文本后，立即将字符转为大写。但是实际上，它只能将本次输入前的字符转为大写，因为浏览器此时还没接收到新的文本，所以<code>this.value</code>取不到最新输入的那个字符。只有用<code>setTimeout</code>改写，上面的代码才能发挥作用。</p><pre class="hljs"><code><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'input-box'</span>).onkeypress = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    self.value = self.value.toUpperCase();
  }, <span class="hljs-number">0</span>);
}
</code></pre><p>上面代码将代码放入<code>setTimeout</code>之中，就能使得它在浏览器接收到文本之后触发。</p><p>由于<code>setTimeout(f, 0)</code>实际上意味着，将任务放到浏览器最早可得的空闲时段执行，所以那些计算量大、耗时长的任务，常常会被放到几个小部分，分别放到<code>setTimeout(f, 0)</code>里面执行。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'div'</span>)[<span class="hljs-number">0</span>];

<span class="hljs-comment">// 写法一</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0xA00000</span>; i &lt; <span class="hljs-number">0xFFFFFF</span>; i++) {
  div.style.backgroundColor = <span class="hljs-string">'#'</span> + i.toString(<span class="hljs-number">16</span>);
}

<span class="hljs-comment">// 写法二</span>
<span class="hljs-keyword">var</span> timer;
<span class="hljs-keyword">var</span> i=<span class="hljs-number">0x100000</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>{
  timer = setTimeout(func, <span class="hljs-number">0</span>);
  div.style.backgroundColor = <span class="hljs-string">'#'</span> + i.toString(<span class="hljs-number">16</span>);
  <span class="hljs-keyword">if</span> (i++ == <span class="hljs-number">0xFFFFFF</span>) clearTimeout(timer);
}

timer = setTimeout(func, <span class="hljs-number">0</span>);
</code></pre><p>上面代码有两种写法，都是改变一个网页元素的背景色。写法一会造成浏览器“堵塞”，因为 JavaScript 执行速度远高于 DOM，会造成大量 DOM 操作“堆积”，而写法二就不会，这就是<code>setTimeout(f, 0)</code>的好处。</p><p>另一个使用这种技巧的例子是代码高亮的处理。如果代码块很大，一次性处理，可能会对性能造成很大的压力，那么将其分成一个个小块，一次处理一块，比如写成<code>setTimeout(highlightNext, 50)</code>的样子，性能压力就会减轻。</p></article><nav class="level level-previous-next is-size-5 is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="../async/general.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> 概述</a></p></div><div class="level-right"><p class="level-item is-narrow"></p></div></nav><div class="page-info is-size-5-desktop"><p>本教程采用<a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh" target="_blank">知识共享 署名-相同方式共享 3.0协议</a>。</p><p>最后生成于 2018-2-22 12:27:37</p><p>分享本文 <span class="social-share"></span></p></div></div><div class="column is-3 is-offset-1"><nav class="panel panel-menu"><p class="panel-heading"><i class="fa fa-book" aria-hidden="true"></i> JavaScript 教程</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="../basic/index.html"><span class="icon"><i class="fa fa-caret-down"></i> </span><i class="fa folder fa-folder-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">入门篇</span></a><ul><li><a href="../basic/introduction.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">导论</span></a></li><li><a href="../basic/history.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">历史</span></a></li><li><a href="../basic/grammar.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">基本语法</span></a></li></ul></li><li><a href="../types/index.html"><span class="icon"><i class="fa fa-caret-down"></i> </span><i class="fa folder fa-folder-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">数据类型</span></a><ul><li><a href="../types/general.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">概述</span></a></li><li><a href="../types/null-undefined-boolean.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">null，undefined 和布尔值</span></a></li><li><a href="../types/number.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">数值</span></a></li><li><a href="../types/string.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">字符串</span></a></li><li><a href="../types/object.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">对象</span></a></li><li><a href="../types/function.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">函数</span></a></li><li><a href="../types/array.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">数组</span></a></li></ul></li><li><a href="../operators/index.html"><span class="icon"><i class="fa fa-caret-down"></i> </span><i class="fa folder fa-folder-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">运算符</span></a><ul><li><a href="../operators/arithmetic.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">算术运算符</span></a></li><li><a href="../operators/comparison.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">比较运算符</span></a></li><li><a href="../operators/boolean.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">布尔运算符</span></a></li><li><a href="../operators/bit.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">二进制位运算符</span></a></li><li><a href="../operators/priority.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">其他运算符，运算顺序</span></a></li></ul></li><li><a href="../features/index.html"><span class="icon"><i class="fa fa-caret-down"></i> </span><i class="fa folder fa-folder-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">语法专题</span></a><ul><li><a href="../features/conversion.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">数据类型的转换</span></a></li><li><a href="../features/error.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">错误处理机制</span></a></li><li><a href="../features/style.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">编程风格</span></a></li><li><a href="../features/console.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">console 对象与控制台</span></a></li></ul></li><li><a href="../stdlib/index.html"><span class="icon"><i class="fa fa-caret-down"></i> </span><i class="fa folder fa-folder-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">标准库</span></a><ul><li><a href="../stdlib/object.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Object 对象</span></a></li><li><a href="../stdlib/attributes.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">属性描述对象</span></a></li><li><a href="../stdlib/array.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Array 对象</span></a></li><li><a href="../stdlib/wrapper.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">包装对象</span></a></li><li><a href="../stdlib/boolean.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Boolean 对象</span></a></li><li><a href="../stdlib/number.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Number 对象</span></a></li><li><a href="../stdlib/string.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">String 对象</span></a></li><li><a href="../stdlib/math.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Math 对象</span></a></li><li><a href="../stdlib/date.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Date 对象</span></a></li><li><a href="../stdlib/regexp.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">RegExp 对象</span></a></li><li><a href="../stdlib/json.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">JSON 对象</span></a></li></ul></li><li><a href="../oop/index.html"><span class="icon"><i class="fa fa-caret-down"></i> </span><i class="fa folder fa-folder-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">面向对象编程</span></a><ul><li><a href="../oop/new.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">实例对象与 new 命令</span></a></li><li><a href="../oop/this.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">this 关键字</span></a></li><li><a href="../oop/prototype.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">对象的继承</span></a></li><li><a href="../oop/object.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Object 对象的相关方法</span></a></li><li><a href="../oop/strict.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">严格模式</span></a></li></ul></li><li><a href="../async/index.html"><span class="icon"><i class="fa fa-caret-down"></i> </span><i class="fa folder fa-folder-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">异步操作</span></a><ul><li><a href="../async/general.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">概述</span></a></li><li><a href="../async/timer.html" class="is-active"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">定时器</span></a></li></ul></li></ul></aside></div></nav><nav class="panel panel-info"><p class="panel-heading"><i class="fa fa-link" aria-hidden="true"></i> 链接</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="https://raw.githubusercontent.com/wangdoc/javascript-tutorial/master/docs/async/timer.md" target="_blank"><span class="icon"></span><i class="fa fa-code" aria-hidden="true" style="width: 14px;"></i>&nbsp;本文源码</a></li><li><a href="https://github.com/wangdoc/javascript-tutorial" target="_blank"><span class="icon"></span><i class="fa fa-hdd-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;代码仓库</a></li><li><a href="https://github.com/wangdoc/javascript-tutorial/issues" target="_blank"><span class="icon"></span><i class="fa fa-flag-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;反馈</a></li></ul></aside></div></nav></div></div><div class="columns"><div class="column is-8"><div id="disqus_thread"></div></div></div></div></section><footer class="footer is-size-5-desktop"><div class="container"><div class="content has-text-centered"><p>联系：contact@wangdoc.com / Build by <a target="_blank" href="https://github.com/ruanyf/loppo">Loppo 0.6.11</a></p></div></div></footer><script>var LOPPO={current_path:"async/timer.md",relative_root_path:"../",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#settimeout">setTimeout()</a></li>\n<li><a href="#setinterval">setInterval()</a></li>\n<li><a href="#cleartimeout%EF%BC%8Cclearinterval">clearTimeout()，clearInterval()</a></li>\n<li><a href="#%E5%AE%9E%E4%BE%8B%EF%BC%9Adebounce-%E5%87%BD%E6%95%B0">实例：debounce 函数</a></li>\n<li><a href="#%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6">运行机制</a></li>\n<li><a href="#settimeoutf-0">setTimeout(f, 0)</a>\n<ul>\n<li><a href="#%E5%90%AB%E4%B9%89">含义</a></li>\n<li><a href="#%E5%BA%94%E7%94%A8">应用</a></li>\n</ul>\n</li>\n</ul>\n'}</script><script src="../assets/js/app.js"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-111269443-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-111269443-1")</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?5eec262881855af3dede6a71234571f6";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/

var disqus_config = function () {
const l = window.location;
const url = l.protocol + '//' + l.host + (l.port ? ':' + l.port : '') + l.pathname;
this.page.url = url;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = l.pathname; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://wangdoc-javascript.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();</script><!--script src="../assets/js/social-share.min.js"--><!--/script--><script>var shareDesc="我正在阅读《定时器》，出自网道（WangDoc.com）的《JavaScript 教程》。",shareOpts={url:window.location.href,source:shareDesc,title:shareDesc,description:"",image:"",sites:["weibo","wechat","qq","qzone","twitter","facebook"],origin:"WangDoc_com",disabled:[],wechatQrcodeTitle:"微信",wechatQrcodeHelper:"扫一下二维码，分享到微信。"};socialShare(".social-share",shareOpts)</script></body></html>