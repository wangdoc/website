<!DOCTYPE html><html lang="zh-CN" prefix="og: http://ogp.me/ns#" data-theme="light"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>TypeScript 类型工具 - TypeScript 教程 - 网道</title><!-- link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" --><link rel="stylesheet" href="assets/css/app.min.css"><link rel="stylesheet" href="https://apps.bdimg.com/libs/fontawesome/4.4.0/css/font-awesome.css"><!-- link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css"--><!-- link rel="stylesheet" href="assets/css/share.min.css" --><meta property="og:type" content="article"><meta property="og:title" content="TypeScript 类型工具"><link rel="apple-touch-icon" href="assets/icons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="192x192" href="assets/icons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="assets/icons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="assets/icons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="assets/icons/favicon-16x16.png"><link rel="manifest" href="assets/icons/manifest.json"></head><body><nav class="navbar is-light" role="navigation" id="navbar" aria-label="main navigation"><div class="container"><div class="navbar-brand"><a href="/" class="navbar-item title has-text-grey has-text-weight-light is-5">网道 / WangDoc.com </a><a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false"><span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span></a></div><div class="navbar-menu" id="navMenu"><div class="navbar-end"><div class="navbar-item"><form action="https://sourcegraph.com/search" target="_blank" method="get" onsubmit='this.q.value="repo:^github.com/wangdoc/typescript-tutorial$ "+this.origin.value'><p class="control has-icons-right"><input class="input" type="text" name="origin" placeholder="搜索..."> <span class="icon is-small is-right"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"><path fill="#ddd" d="M23.822 20.88l-6.353-6.354c.93-1.465 1.467-3.2 1.467-5.059.001-5.219-4.247-9.467-9.468-9.467s-9.468 4.248-9.468 9.468c0 5.221 4.247 9.469 9.468 9.469 1.768 0 3.421-.487 4.839-1.333l6.396 6.396 3.119-3.12zm-20.294-11.412c0-3.273 2.665-5.938 5.939-5.938 3.275 0 5.94 2.664 5.94 5.938 0 3.275-2.665 5.939-5.94 5.939-3.274 0-5.939-2.664-5.939-5.939z"/></svg></span></p><input type="hidden" name="q" value=""> <input type="hidden" name="patternType" value="literal"></form></div><a class="navbar-item is-hidden-desktop-only" target="_blank" href="https://github.com/wangdoc/typescript-tutorial"><span class="icon" style="color: #333;"><i class="fa fa-lg fa-github"></i></span></a></div></div></div></nav><section class="section main article"><div class="container"><div class="columns"><div class="column is-8 is-6-widescreen is-offset-1-widescreen"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="index.html"><span class="icon"><i class="fa fa-home"></i></span> &nbsp;TypeScript 教程</a></li><li class="is-active"><a class="has-text-grey" href="utility.html">类型工具</a></li></ul></nav><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="mapping.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> 类型映射</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="comment.html">注释指令 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><article class="content"><h1 class="title">TypeScript 类型工具</h1><div class="page-meta"><p>网道（WangDoc.com），互联网文档计划</p></div><p>TypeScript 提供了一些内置的类型工具，用来方便地处理各种类型，以及生成新的类型。</p><p>这些类型工具都是语言本身提供的，可以直接使用。</p><h2 id="awaitedtype"><code>Awaited&lt;Type&gt;</code> <a class="markdownIt-Anchor" href="#awaitedtype">#</a></h2><p><code>Awaited&lt;Type&gt;</code>用来取出 Promise 的返回值类型，适合用在描述<code>then()</code>方法和 await 命令的参数类型。</p><pre class="hljs"><code><span class="hljs-comment">// string</span>
<span class="hljs-keyword">type</span> A = <span class="hljs-title class_">Awaited</span>&lt;<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;;
</code></pre><p>上面示例中，<code>Awaited&lt;Type&gt;</code>会返回 Promise 的返回值类型（string）。</p><p>它也可以返回多重 Promise 的返回值类型。</p><pre class="hljs"><code><span class="hljs-comment">// number</span>
<span class="hljs-keyword">type</span> B = <span class="hljs-title class_">Awaited</span>&lt;<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">number</span>&gt;&gt;&gt;;
</code></pre><p>如果它的类型参数不是 Promise 类型，那么就会原样返回。</p><pre class="hljs"><code><span class="hljs-comment">// number | boolean</span>
<span class="hljs-keyword">type</span> C = <span class="hljs-title class_">Awaited</span>&lt;<span class="hljs-built_in">boolean</span> | <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">number</span>&gt;&gt;;
</code></pre><p>上面示例中，类型参数是一个联合类型，其中的<code>boolean</code>会原样返回，所以最终返回的是<code>number|boolean</code>。</p><p><code>Awaited&lt;Type&gt;</code>的实现如下。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Awaited</span>&lt;T&gt; =
  T <span class="hljs-keyword">extends</span> <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span> ? T :
  T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span> &amp; {
    <span class="hljs-title function_">then</span>(
      <span class="hljs-attr">onfulfilled</span>: infer F,
      ...<span class="hljs-attr">args</span>: infer _
    ): <span class="hljs-built_in">any</span>;
  } ? F <span class="hljs-title function_">extends</span> (
    <span class="hljs-attr">value</span>: infer V,
    ...<span class="hljs-attr">args</span>: infer _
  ) =&gt; <span class="hljs-built_in">any</span> ? <span class="hljs-title class_">Awaited</span>&lt;V&gt; : <span class="hljs-attr">never</span>:
  T;
</code></pre><h2 id="constructorparameterstype"><code>ConstructorParameters&lt;Type&gt;</code> <a class="markdownIt-Anchor" href="#constructorparameterstype">#</a></h2><p><code>ConstructorParameters&lt;Type&gt;</code>提取构造方法<code>Type</code>的参数类型，组成一个元组类型返回。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">ConstructorParameters</span>&lt;
  <span class="hljs-title function_">new</span> (<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>) =&gt; <span class="hljs-built_in">object</span>
&gt;; <span class="hljs-comment">// [x: string, y: number]</span>

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">ConstructorParameters</span>&lt;
  <span class="hljs-title function_">new</span> (<span class="hljs-attr">x</span>?: <span class="hljs-built_in">string</span>) =&gt; <span class="hljs-built_in">object</span>
&gt;; <span class="hljs-comment">// [x?: string | undefined]</span>
</code></pre><p>它可以返回一些内置构造方法的参数类型。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">ConstructorParameters</span>&lt;
  <span class="hljs-title class_">ErrorConstructor</span>
&gt;; <span class="hljs-comment">// [message?: string]</span>

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">ConstructorParameters</span>&lt;
  <span class="hljs-title class_">FunctionConstructor</span>
&gt;; <span class="hljs-comment">// string[]</span>

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T3</span> = <span class="hljs-title class_">ConstructorParameters</span>&lt;
  <span class="hljs-title class_">RegExpConstructor</span>
&gt;; <span class="hljs-comment">// [pattern:string|RegExp, flags?:string]</span>
</code></pre><p>如果参数类型不是构造方法，就会报错。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">ConstructorParameters</span>&lt;<span class="hljs-built_in">string</span>&gt;; <span class="hljs-comment">// 报错</span>

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">ConstructorParameters</span>&lt;<span class="hljs-title class_">Function</span>&gt;; <span class="hljs-comment">// 报错</span>
</code></pre><p><code>any</code>类型和<code>never</code>类型是两个特殊值，分别返回<code>unknown[]</code>和<code>never</code>。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">ConstructorParameters</span>&lt;<span class="hljs-built_in">any</span>&gt;;  <span class="hljs-comment">// unknown[]</span>

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">ConstructorParameters</span>&lt;<span class="hljs-built_in">never</span>&gt;; <span class="hljs-comment">// never</span>
</code></pre><p><code>ConstructorParameters&lt;Type&gt;</code>的实现如下。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ConstructorParameters</span>&lt;
  T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">new</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">any</span>
&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">new</span> (...<span class="hljs-attr">args</span>: infer P) 
  =&gt; <span class="hljs-built_in">any</span> ? P : <span class="hljs-built_in">never</span>
</code></pre><h2 id="excludeuniontype-excludedmembers"><code>Exclude&lt;UnionType, ExcludedMembers&gt;</code> <a class="markdownIt-Anchor" href="#excludeuniontype-excludedmembers">#</a></h2><p><code>Exclude&lt;UnionType, ExcludedMembers&gt;</code>用来从联合类型<code>UnionType</code>里面，删除某些类型<code>ExcludedMembers</code>，组成一个新的类型返回。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-string">&#x27;a&#x27;</span>|<span class="hljs-string">&#x27;b&#x27;</span>|<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>&gt;; <span class="hljs-comment">// &#x27;b&#x27;|&#x27;c&#x27;</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-string">&#x27;a&#x27;</span>|<span class="hljs-string">&#x27;b&#x27;</span>|<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>|<span class="hljs-string">&#x27;b&#x27;</span>&gt;; <span class="hljs-comment">// &#x27;c&#x27;</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T3</span> = <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-built_in">string</span>|(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>), <span class="hljs-title class_">Function</span>&gt;; <span class="hljs-comment">// string</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T4</span> = <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">string</span>[], <span class="hljs-built_in">any</span>[]&gt;; <span class="hljs-comment">// string</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T5</span> = <span class="hljs-title class_">Exclude</span>&lt;(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>) | <span class="hljs-literal">null</span>, <span class="hljs-title class_">Function</span>&gt;; <span class="hljs-comment">// null</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T6</span> = <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-number">200</span> | <span class="hljs-number">400</span>, <span class="hljs-number">200</span> | <span class="hljs-number">201</span>&gt;; <span class="hljs-comment">// 400</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T7</span> = <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">boolean</span>&gt;; <span class="hljs-comment">// number</span>
</code></pre><p><code>Exclude&lt;UnionType, ExcludedMembers&gt;</code>的实现如下。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Exclude</span>&lt;T, U&gt; = T <span class="hljs-keyword">extends</span> U ? <span class="hljs-built_in">never</span> : T;
</code></pre><p>上面代码中，等号右边的部分，表示先判断<code>T</code>是否兼容<code>U</code>，如果是的就返回<code>never</code>类型，否则返回当前类型<code>T</code>。由于<code>never</code>类型是任何其他类型的子类型，它跟其他类型组成联合类型时，可以直接将<code>never</code>类型从联合类型中“消掉”，因此<code>Exclude&lt;T, U&gt;</code>就相当于删除兼容的类型，剩下不兼容的类型。</p><h2 id="extractuniontype-union"><code>Extract&lt;UnionType, Union&gt;</code> <a class="markdownIt-Anchor" href="#extractuniontype-union">#</a></h2><p><code>Extract&lt;UnionType, Union&gt;</code>用来从联合类型<code>UnionType</code>之中，提取指定类型<code>Union</code>，组成一个新类型返回。它与<code>Exclude&lt;T, U&gt;</code>正好相反。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Extract</span>&lt;<span class="hljs-string">&#x27;a&#x27;</span>|<span class="hljs-string">&#x27;b&#x27;</span>|<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>&gt;; <span class="hljs-comment">// &#x27;a&#x27;</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">Extract</span>&lt;<span class="hljs-string">&#x27;a&#x27;</span>|<span class="hljs-string">&#x27;b&#x27;</span>|<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>|<span class="hljs-string">&#x27;b&#x27;</span>&gt;; <span class="hljs-comment">// &#x27;a&#x27;|&#x27;b&#x27;</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T3</span> = <span class="hljs-title class_">Extract</span>&lt;<span class="hljs-string">&#x27;a&#x27;</span>|<span class="hljs-string">&#x27;b&#x27;</span>|<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>|<span class="hljs-string">&#x27;d&#x27;</span>&gt;; <span class="hljs-comment">// &#x27;a&#x27;</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T4</span> = <span class="hljs-title class_">Extract</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">string</span>[], <span class="hljs-built_in">any</span>[]&gt;; <span class="hljs-comment">// string[]</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T5</span> = <span class="hljs-title class_">Extract</span>&lt;(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>) | <span class="hljs-literal">null</span>, <span class="hljs-title class_">Function</span>&gt;; <span class="hljs-comment">// () =&gt; void</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T6</span> = <span class="hljs-title class_">Extract</span>&lt;<span class="hljs-number">200</span> | <span class="hljs-number">400</span>, <span class="hljs-number">200</span> | <span class="hljs-number">201</span>&gt;; <span class="hljs-comment">// 200</span>
</code></pre><p>如果参数类型<code>Union</code>不包含在联合类型<code>UnionType</code>之中，则返回<code>never</code>类型。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> T = <span class="hljs-title class_">Extract</span>&lt;<span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span>, <span class="hljs-built_in">boolean</span>&gt;; <span class="hljs-comment">// never</span>
</code></pre><p><code>Extract&lt;UnionType, Union&gt;</code>的实现如下。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Extract</span>&lt;T, U&gt; = T <span class="hljs-keyword">extends</span> U ? T : <span class="hljs-built_in">never</span>;
</code></pre><h2 id="instancetypetype"><code>InstanceType&lt;Type&gt;</code> <a class="markdownIt-Anchor" href="#instancetypetype">#</a></h2><p><code>InstanceType&lt;Type&gt;</code>提取构造函数的返回值的类型（即实例类型），参数<code>Type</code>是一个构造函数，等同于构造函数的<code>ReturnType&lt;Type&gt;</code>。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> T = <span class="hljs-title class_">InstanceType</span>&lt;
  <span class="hljs-title function_">new</span> () =&gt; <span class="hljs-built_in">object</span>
&gt;; <span class="hljs-comment">// object</span>
</code></pre><p>上面示例中，类型参数是一个构造函数<code>new () =&gt; object</code>，返回值是该构造函数的实例类型（<code>object</code>）。</p><p>下面是一些例子。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> A = <span class="hljs-title class_">InstanceType</span>&lt;<span class="hljs-title class_">ErrorConstructor</span>&gt;; <span class="hljs-comment">// Error</span>
<span class="hljs-keyword">type</span> B = <span class="hljs-title class_">InstanceType</span>&lt;<span class="hljs-title class_">FunctionConstructor</span>&gt;; <span class="hljs-comment">// Function</span>
<span class="hljs-keyword">type</span> C = <span class="hljs-title class_">InstanceType</span>&lt;<span class="hljs-title class_">RegExpConstructor</span>&gt;; <span class="hljs-comment">// RegExp</span>
</code></pre><p>上面示例中，<code>InstanceType&lt;T&gt;</code>的参数都是 TypeScript 内置的原生对象的构造函数类型，<code>InstanceType&lt;T&gt;</code>的返回值就是这些构造函数的实例类型。</p><p>由于 Class 作为类型，代表实例类型。要获取它的构造方法，必须把它当成值，然后用<code>typeof</code>运算符获取它的构造方法类型。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  x = <span class="hljs-number">0</span>;
  y = <span class="hljs-number">0</span>;
}

<span class="hljs-keyword">type</span> T = <span class="hljs-title class_">InstanceType</span>&lt;<span class="hljs-keyword">typeof</span> C&gt;; <span class="hljs-comment">// C</span>
</code></pre><p>上面示例中，<code>typeof C</code>是<code>C</code>的构造方法类型，然后 InstanceType 就能获得实例类型，即<code>C</code>本身。</p><p>如果类型参数不是构造方法，就会报错。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">InstanceType</span>&lt;<span class="hljs-built_in">string</span>&gt;; <span class="hljs-comment">// 报错</span>

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">InstanceType</span>&lt;<span class="hljs-title class_">Function</span>&gt;; <span class="hljs-comment">// 报错</span>
</code></pre><p>如果类型参数是<code>any</code>或<code>never</code>两个特殊值，分别返回<code>any</code>和<code>never</code>。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">InstanceType</span>&lt;<span class="hljs-built_in">any</span>&gt;; <span class="hljs-comment">// any</span>

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">InstanceType</span>&lt;<span class="hljs-built_in">never</span>&gt;; <span class="hljs-comment">// never</span>
</code></pre><p><code>InstanceType&lt;Type&gt;</code>的实现如下。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">InstanceType</span>&lt;
  T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">new</span> (...<span class="hljs-attr">args</span>:<span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">any</span>
&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">new</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; infer R ? R :
  <span class="hljs-built_in">any</span>;
</code></pre><h2 id="nonnullabletype"><code>NonNullable&lt;Type&gt;</code> <a class="markdownIt-Anchor" href="#nonnullabletype">#</a></h2><p><code>NonNullable&lt;Type&gt;</code>用来从联合类型<code>Type</code>删除<code>null</code>类型和<code>undefined</code>类型，组成一个新类型返回，也就是返回<code>Type</code>的非空类型版本。</p><pre class="hljs"><code><span class="hljs-comment">// string|number</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">NonNullable</span>&lt;<span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span>|<span class="hljs-literal">undefined</span>&gt;;

<span class="hljs-comment">// string[]</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">NonNullable</span>&lt;<span class="hljs-built_in">string</span>[]|<span class="hljs-literal">null</span>|<span class="hljs-literal">undefined</span>&gt;;

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T3</span> = <span class="hljs-title class_">NonNullable</span>&lt;<span class="hljs-built_in">boolean</span>&gt;; <span class="hljs-comment">// boolean</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T4</span> = <span class="hljs-title class_">NonNullable</span>&lt;<span class="hljs-built_in">number</span>|<span class="hljs-literal">null</span>&gt;; <span class="hljs-comment">// number</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T5</span> = <span class="hljs-title class_">NonNullable</span>&lt;<span class="hljs-built_in">string</span>|<span class="hljs-literal">undefined</span>&gt;; <span class="hljs-comment">// string</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T6</span> = <span class="hljs-title class_">NonNullable</span>&lt;<span class="hljs-literal">null</span>|<span class="hljs-literal">undefined</span>&gt;; <span class="hljs-comment">// never</span>
</code></pre><p><code>NonNullable&lt;Type&gt;</code>的实现如下。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">NonNullable</span>&lt;T&gt; = T &amp; {}
</code></pre><p>上面代码中，<code>T &amp; {}</code>等同于求<code>T &amp; Object</code>的交叉类型。由于 TypeScript 的非空值都属于<code>Object</code>的子类型，所以会返回自身；而<code>null</code>和<code>undefined</code>不属于<code>Object</code>，会返回<code>never</code>类型。</p><h2 id="omittype-keys"><code>Omit&lt;Type, Keys&gt;</code> <a class="markdownIt-Anchor" href="#omittype-keys">#</a></h2><p><code>Omit&lt;Type, Keys&gt;</code>用来从对象类型<code>Type</code>中，删除指定的属性<code>Keys</code>，组成一个新的对象类型返回。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> A {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Omit</span>&lt;A, <span class="hljs-string">&#x27;x&#x27;</span>&gt;;       <span class="hljs-comment">// { y: number }</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">Omit</span>&lt;A, <span class="hljs-string">&#x27;y&#x27;</span>&gt;;       <span class="hljs-comment">// { x: number }</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T3</span> = <span class="hljs-title class_">Omit</span>&lt;A, <span class="hljs-string">&#x27;x&#x27;</span> | <span class="hljs-string">&#x27;y&#x27;</span>&gt;; <span class="hljs-comment">// { }</span>
</code></pre><p>上面示例中，<code>Omit&lt;Type, Keys&gt;</code>从对象类型<code>A</code>里面删除指定属性，返回剩下的属性。</p><p>指定删除的键名<code>Keys</code>可以是对象类型<code>Type</code>中不存在的属性，但必须兼容<code>string|number|symbol</code>。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> A {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">type</span> T = <span class="hljs-title class_">Omit</span>&lt;A, <span class="hljs-string">&#x27;z&#x27;</span>&gt;; <span class="hljs-comment">// { x: number; y: number }</span>
</code></pre><p>上面示例中，对象类型<code>A</code>中不存在属性<code>z</code>，所以就原样返回了。</p><p><code>Omit&lt;Type, Keys&gt;</code>的实现如下。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Omit</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof <span class="hljs-built_in">any</span>&gt; 
  = <span class="hljs-title class_">Pick</span>&lt;T, <span class="hljs-title class_">Exclude</span>&lt;keyof T, K&gt;&gt;;
</code></pre><h2 id="omitthisparametertype"><code>OmitThisParameter&lt;Type&gt;</code> <a class="markdownIt-Anchor" href="#omitthisparametertype">#</a></h2><p><code>OmitThisParameter&lt;Type&gt;</code>从函数类型中移除 this 参数。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">toHex</span>(<span class="hljs-params"><span class="hljs-attr">this</span>: <span class="hljs-title class_">Number</span></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>);
}

<span class="hljs-keyword">type</span> T = <span class="hljs-title class_">OmitThisParameter</span>&lt;<span class="hljs-keyword">typeof</span> toHex&gt;; <span class="hljs-comment">// () =&gt; string</span>
</code></pre><p>上面示例中，<code>OmitThisParameter&lt;T&gt;</code>给出了函数<code>toHex()</code>的类型，并将其中的<code>this</code>参数删除。</p><p>如果函数没有 this 参数，则返回原始函数类型。</p><p><code>OmitThisParameter&lt;Type&gt;</code>的实现如下。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">OmitThisParameter</span>&lt;T&gt; =
  <span class="hljs-built_in">unknown</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThisParameterType</span>&lt;T&gt; ? T :
  T <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: infer A) =&gt; infer R ?
  <span class="hljs-function">(<span class="hljs-params">...<span class="hljs-attr">args</span>: A</span>) =&gt;</span> R : T;
</code></pre><h2 id="parameterstype"><code>Parameters&lt;Type&gt;</code> <a class="markdownIt-Anchor" href="#parameterstype">#</a></h2><p><code>Parameters&lt;Type&gt;</code>从函数类型<code>Type</code>里面提取参数类型，组成一个元组返回。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span>&gt;; <span class="hljs-comment">// []</span>

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">s</span>:<span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;; <span class="hljs-comment">// [s:string]</span>

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T3</span> = <span class="hljs-title class_">Parameters</span>&lt;&lt;T&gt;<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">arg</span>: T</span>) =&gt;</span> T&gt;;    <span class="hljs-comment">// [arg: unknown]</span>

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T4</span> = <span class="hljs-title class_">Parameters</span>&lt;
  <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">x</span>:{ a: <span class="hljs-built_in">number</span>; b: <span class="hljs-built_in">string</span> }</span>) =&gt;</span> <span class="hljs-built_in">void</span>
&gt;; <span class="hljs-comment">// [x: { a: number, b: string }]</span>

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T5</span> = <span class="hljs-title class_">Parameters</span>&lt;
  <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">a</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>
&gt;; <span class="hljs-comment">// [a:number, b:number]</span>
</code></pre><p>上面示例中，<code>Parameters&lt;Type&gt;</code>的返回值会包括函数的参数名，这一点需要注意。</p><p>如果参数类型<code>Type</code>不是带有参数的函数形式，会报错。</p><pre class="hljs"><code><span class="hljs-comment">// 报错</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-built_in">string</span>&gt;;

<span class="hljs-comment">// 报错</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-title class_">Function</span>&gt;;
</code></pre><p>由于<code>any</code>和<code>never</code>是两个特殊值，会返回<code>unknown[]</code>和<code>never</code>。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-built_in">any</span>&gt;; <span class="hljs-comment">// unknown[]</span>

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-built_in">never</span>&gt;; <span class="hljs-comment">// never</span>
</code></pre><p><code>Parameters&lt;Type&gt;</code>主要用于从外部模块提供的函数类型中，获取参数类型。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SecretName</span> {
  <span class="hljs-attr">first</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">last</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">SecretSanta</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-title class_">SecretName</span>;
  <span class="hljs-attr">gift</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getGift</span>(<span class="hljs-params">
  <span class="hljs-attr">name</span>: <span class="hljs-title class_">SecretName</span>,
  <span class="hljs-attr">gift</span>: <span class="hljs-built_in">string</span>
</span>): <span class="hljs-title class_">SecretSanta</span> {
 <span class="hljs-comment">// ...</span>
}
</code></pre><p>上面示例中，模块只输出了函数<code>getGift()</code>，没有输出参数<code>SecretName</code>和返回值<code>SecretSanta</code>。这时就可以通过<code>Parameters&lt;T&gt;</code>和<code>ReturnType&lt;T&gt;</code>拿到这两个接口类型。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ParaT</span> = <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-keyword">typeof</span> getGift&gt;[<span class="hljs-number">0</span>]; <span class="hljs-comment">// SecretName</span>

<span class="hljs-keyword">type</span> <span class="hljs-title class_">ReturnT</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> getGift&gt;; <span class="hljs-comment">// SecretSanta</span>
</code></pre><p><code>Parameters&lt;Type&gt;</code>的实现如下。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Parameters</span>&lt;T <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">any</span>&gt; = 
  T <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: infer P)
  =&gt; <span class="hljs-built_in">any</span> ? P : <span class="hljs-built_in">never</span>
</code></pre><h2 id="partialtype"><code>Partial&lt;Type&gt;</code> <a class="markdownIt-Anchor" href="#partialtype">#</a></h2><p><code>Partial&lt;Type&gt;</code>返回一个新类型，将参数类型<code>Type</code>的所有属性变为可选属性。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> A {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;
}
 
<span class="hljs-keyword">type</span> T = <span class="hljs-title class_">Partial</span>&lt;A&gt;; <span class="hljs-comment">// { x?: number; y?: number; }</span>
</code></pre><p><code>Partial&lt;Type&gt;</code>的实现如下。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Partial</span>&lt;T&gt; = {
  [P <span class="hljs-keyword">in</span> keyof T]?: T[P];
};
</code></pre><h2 id="picktype-keys"><code>Pick&lt;Type, Keys&gt;</code> <a class="markdownIt-Anchor" href="#picktype-keys">#</a></h2><p><code>Pick&lt;Type, Keys&gt;</code>返回一个新的对象类型，第一个参数<code>Type</code>是一个对象类型，第二个参数<code>Keys</code>是<code>Type</code>里面被选定的键名。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> A {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Pick</span>&lt;A, <span class="hljs-string">&#x27;x&#x27;</span>&gt;; <span class="hljs-comment">// { x: number }</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">Pick</span>&lt;A, <span class="hljs-string">&#x27;y&#x27;</span>&gt;; <span class="hljs-comment">// { y: number }</span>
<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T3</span> = <span class="hljs-title class_">Pick</span>&lt;A, <span class="hljs-string">&#x27;x&#x27;</span>|<span class="hljs-string">&#x27;y&#x27;</span>&gt;;  <span class="hljs-comment">// { x: number; y: number }</span>
</code></pre><p>上面示例中，<code>Pick&lt;Type, Keys&gt;</code>会从对象类型<code>A</code>里面挑出指定的键名，组成一个新的对象类型。</p><p>指定的键名<code>Keys</code>必须是对象类型<code>Type</code>里面已经存在的键名，否则会报错。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> A {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">type</span> T = <span class="hljs-title class_">Pick</span>&lt;A, <span class="hljs-string">&#x27;z&#x27;</span>&gt;; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，对象类型<code>A</code>不存在键名<code>z</code>，所以报错了。</p><p><code>Pick&lt;Type, Keys&gt;</code>的实现如下。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Pick</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt; = {
  [P <span class="hljs-keyword">in</span> K]: T[P];
};
</code></pre><h2 id="readonlytype"><code>Readonly&lt;Type&gt;</code> <a class="markdownIt-Anchor" href="#readonlytype">#</a></h2><p><code>Readonly&lt;Type&gt;</code>返回一个新类型，将参数类型<code>Type</code>的所有属性变为只读属性。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> A {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>?: <span class="hljs-built_in">number</span>;
}

<span class="hljs-comment">// { readonly x: number; readonly y?: number; }</span>
<span class="hljs-keyword">type</span> T = <span class="hljs-title class_">Readonly</span>&lt;A&gt;;
</code></pre><p>上面示例中，<code>y</code>是可选属性，<code>Readonly&lt;Type&gt;</code>不会改变这一点，只会让<code>y</code>变成只读。</p><p><code>Readonly&lt;Type&gt;</code>的实现如下。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Readonly</span>&lt;T&gt; = {
  <span class="hljs-keyword">readonly</span> [P <span class="hljs-keyword">in</span> keyof T]: T[P];
};
</code></pre><p>我们可以自定义类型工具<code>Mutable&lt;Type&gt;</code>，将参数类型的所有属性变成可变属性。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Mutable</span>&lt;T&gt; = {
  -<span class="hljs-keyword">readonly</span> [P <span class="hljs-keyword">in</span> keyof T]: T[P];
};
</code></pre><p>上面代码中，<code>-readonly</code>表示去除属性的只读标志。</p><p>相应地，<code>+readonly</code>就表示增加只读标志，等同于<code>readonly</code>。因此，<code>Readonly&lt;Type&gt;</code>的实现也可以写成下面这样。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Readonly</span>&lt;T&gt; = {
  +<span class="hljs-keyword">readonly</span> [P <span class="hljs-keyword">in</span> keyof T]: T[P];
};
</code></pre><p><code>Readonly&lt;Type&gt;</code>可以与<code>Partial&lt;Type&gt;</code>结合使用，将所有属性变成只读的可选属性。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">worker</span>: <span class="hljs-title class_">Readonly</span>&lt;<span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">Person</span>&gt;&gt;
  = { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span> };

worker.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;李四&#x27;</span>; <span class="hljs-comment">// 报错</span>
</code></pre><h2 id="recordkeys-type"><code>Record&lt;Keys, Type&gt;</code> <a class="markdownIt-Anchor" href="#recordkeys-type">#</a></h2><p><code>Record&lt;Keys, Type&gt;</code>返回一个对象类型，参数<code>Keys</code>用作键名，参数<code>Type</code>用作键值类型。</p><pre class="hljs"><code><span class="hljs-comment">// { a: number }</span>
<span class="hljs-keyword">type</span> T = <span class="hljs-title class_">Record</span>&lt;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-built_in">number</span>&gt;;
</code></pre><p>上面示例中，<code>Record&lt;Keys, Type&gt;</code>的第一个参数<code>a</code>，用作对象的键名，第二个参数<code>number</code>是<code>a</code>的键值类型。</p><p>参数<code>Keys</code>可以是联合类型，这时会依次展开为多个键。</p><pre class="hljs"><code><span class="hljs-comment">// { a: number, b: number }</span>
<span class="hljs-keyword">type</span> T = <span class="hljs-title class_">Record</span>&lt;<span class="hljs-string">&#x27;a&#x27;</span>|<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-built_in">number</span>&gt;;
</code></pre><p>上面示例中，第一个参数是联合类型<code>'a'|'b'</code>，展开成两个键名<code>a</code>和<code>b</code>。</p><p>如果参数<code>Type</code>是联合类型，就表明键值是联合类型。</p><pre class="hljs"><code><span class="hljs-comment">// { a: number|string }</span>
<span class="hljs-keyword">type</span> T = <span class="hljs-title class_">Record</span>&lt;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-built_in">number</span>|<span class="hljs-built_in">string</span>&gt;;
</code></pre><p>参数<code>Keys</code>的类型必须兼容<code>string|number|symbol</code>，否则不能用作键名，会报错。</p><p><code>Record&lt;Keys, Type&gt;</code>的实现如下。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Record</span>&lt;K <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span>|<span class="hljs-built_in">symbol</span>, T&gt;
  = { [P <span class="hljs-keyword">in</span> K]: T; }
</code></pre><h2 id="requiredtype"><code>Required&lt;Type&gt;</code> <a class="markdownIt-Anchor" href="#requiredtype">#</a></h2><p><code>Required&lt;Type&gt;</code>返回一个新类型，将参数类型<code>Type</code>的所有属性变为必选属性。它与<code>Partial&lt;Type&gt;</code>的作用正好相反。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> A {
  <span class="hljs-attr">x</span>?: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">type</span> T = <span class="hljs-title class_">Required</span>&lt;A&gt;; <span class="hljs-comment">// { x: number; y: number; }</span>
</code></pre><p><code>Required&lt;Type&gt;</code>的实现如下。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Required</span>&lt;T&gt; = {
  [P <span class="hljs-keyword">in</span> keyof T]-?: T[P];
};
</code></pre><p>上面代码中，符号<code>-?</code>表示去除可选属性的“问号”，使其变成必选属性。</p><p>相对应地，符号<code>+?</code>表示增加可选属性的“问号”，等同于<code>?</code>。因此，前面的<code>Partial&lt;Type&gt;</code>的定义也可以写成下面这样。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Partial</span>&lt;T&gt; = {
  [P <span class="hljs-keyword">in</span> keyof T]+?: T[P];
};
</code></pre><h2 id="readonlyarraytype"><code>ReadonlyArray&lt;Type&gt;</code> <a class="markdownIt-Anchor" href="#readonlyarraytype">#</a></h2><p><code>ReadonlyArray&lt;Type&gt;</code>用来生成一个只读数组类型，类型参数<code>Type</code>表示数组成员的类型。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">values</span>: <span class="hljs-title class_">ReadonlyArray</span>&lt;<span class="hljs-built_in">string</span>&gt; 
  = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];

values[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;x&#x27;</span>; <span class="hljs-comment">// 报错</span>
values.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;x&#x27;</span>); <span class="hljs-comment">// 报错</span>
values.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 报错</span>
values.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，变量<code>values</code>的类型是一个只读数组，所以修改成员会报错，并且那些会修改源数组的方法<code>push()</code>、<code>pop()</code>、<code>splice()</code>等都不存在。</p><p><code>ReadonlyArray&lt;Type&gt;</code>的实现如下。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ReadonlyArray</span>&lt;T&gt; {
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>;

  <span class="hljs-keyword">readonly</span> [<span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span>]: T;

  <span class="hljs-comment">// ...</span>
}
</code></pre><h2 id="returntypetype"><code>ReturnType&lt;Type&gt;</code> <a class="markdownIt-Anchor" href="#returntypetype">#</a></h2><p><code>ReturnType&lt;Type&gt;</code>提取函数类型<code>Type</code>的返回值类型，作为一个新类型返回。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span>&gt;; <span class="hljs-comment">// string</span>

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>
}&gt;; <span class="hljs-comment">// { a: string; b: number }</span>

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T3</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">s</span>:<span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;; <span class="hljs-comment">// void</span>

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T4</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-function">() =&gt;</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">any</span>[]&gt;; <span class="hljs-comment">// () =&gt; any[]</span>

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T5</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Math</span>.<span class="hljs-property">random</span>&gt;; <span class="hljs-comment">// number</span>

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T6</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Array</span>.<span class="hljs-property">isArray</span>&gt;; <span class="hljs-comment">// boolean</span>
</code></pre><p>如果参数类型是泛型函数，返回值取决于泛型类型。如果泛型不带有限制条件，就会返回<code>unknown</code>。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">ReturnType</span>&lt;&lt;T&gt;<span class="hljs-function">() =&gt;</span> T&gt;; <span class="hljs-comment">// unknown</span>

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">ReturnType</span>&lt;
  &lt;T <span class="hljs-keyword">extends</span> U, U <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>[]&gt;<span class="hljs-function">() =&gt;</span> T
&gt;; <span class="hljs-comment">// number[]</span>
</code></pre><p>如果类型不是函数，会报错。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-built_in">boolean</span>&gt;; <span class="hljs-comment">// 报错</span>

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-title class_">Function</span>&gt;; <span class="hljs-comment">// 报错</span>
</code></pre><p><code>any</code>和<code>never</code>是两个特殊值，分别返回<code>any</code>和<code>never</code>。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-built_in">any</span>&gt;; <span class="hljs-comment">// any</span>

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-built_in">never</span>&gt;; <span class="hljs-comment">// never</span>
</code></pre><p><code>ReturnType&lt;Type&gt;</code>的实现如下。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReturnType</span>&lt;
  T <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">any</span>
&gt; =
  T <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; infer R ? R : <span class="hljs-built_in">any</span>;
</code></pre><h2 id="thisparametertypetype"><code>ThisParameterType&lt;Type&gt;</code> <a class="markdownIt-Anchor" href="#thisparametertypetype">#</a></h2><p><code>ThisParameterType&lt;Type&gt;</code>提取函数类型中<code>this</code>参数的类型。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">toHex</span>(<span class="hljs-params"><span class="hljs-attr">this</span>:<span class="hljs-built_in">number</span></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>);
}

<span class="hljs-keyword">type</span> T = <span class="hljs-title class_">ThisParameterType</span>&lt;<span class="hljs-keyword">typeof</span> toHex&gt;; <span class="hljs-comment">// number</span>
</code></pre><p>如果函数没有<code>this</code>参数，则返回<code>unknown</code>。</p><p><code>ThisParameterType&lt;Type&gt;</code>的实现如下。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ThisParameterType</span>&lt;T&gt; =
  T <span class="hljs-title function_">extends</span> (
    <span class="hljs-attr">this</span>: infer U,
    ...<span class="hljs-attr">args</span>: <span class="hljs-built_in">never</span>
  ) =&gt; <span class="hljs-built_in">any</span> ? U : <span class="hljs-built_in">unknown</span>;
</code></pre><h2 id="thistypetype"><code>ThisType&lt;Type&gt;</code> <a class="markdownIt-Anchor" href="#thistypetype">#</a></h2><p><code>ThisType&lt;Type&gt;</code>不返回类型，只用来跟其他类型组成交叉类型，用来提示 TypeScript 其他类型里面的<code>this</code>的类型。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">HelperThisValue</span> {
  <span class="hljs-attr">logError</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">error</span>:<span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
}

<span class="hljs-keyword">let</span> <span class="hljs-attr">helperFunctions</span>:
  { [<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-title class_">Function</span> } &amp;
  <span class="hljs-title class_">ThisType</span>&lt;<span class="hljs-title class_">HelperThisValue</span>&gt;
= {
  <span class="hljs-attr">hello</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">logError</span>(<span class="hljs-string">&quot;Error: Something wrong!&quot;</span>); <span class="hljs-comment">// 正确</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">update</span>(); <span class="hljs-comment">// 报错</span>
  }
}
</code></pre><p>上面示例中，变量<code>helperFunctions</code>的类型是一个正常的对象类型与<code>ThisType&lt;HelperThisValue&gt;</code>组成的交叉类型。</p><p>这里的<code>ThisType</code>的作用是提示 TypeScript，变量<code>helperFunctions</code>的<code>this</code>应该满足<code>HelperThisValue</code>的条件。所以，<code>this.logError()</code>可以正确调用，而<code>this.update()</code>会报错，因为<code>HelperThisValue</code>里面没有这个方法。</p><p>注意，使用这个类型工具时，必须打开<code>noImplicitThis</code>设置。</p><p>下面是另一个例子。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>: <span class="hljs-title class_">ThisType</span>&lt;{ <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span> }&gt; &amp;
  { <span class="hljs-attr">getX</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">number</span> };

obj = {
  <span class="hljs-title function_">getX</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>; <span class="hljs-comment">// 报错</span>
  },
};
</code></pre><p>上面示例中，<code>getX()</code>里面的<code>this.y</code>会报错，因为根据<code>ThisType&lt;{ x: number }&gt;</code>，这个对象的<code>this</code>不包含属性<code>y</code>。</p><p><code>ThisType&lt;Type&gt;</code>的实现就是一个空接口。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ThisType</span>&lt;T&gt; { }
</code></pre><h2 id="字符串类型工具">字符串类型工具 <a class="markdownIt-Anchor" href="#字符串类型工具">#</a></h2><p>TypeScript 内置了四个字符串类型工具，专门用来操作字符串类型。这四个工具类型都定义在 TypeScript 自带的<code>.d.ts</code>文件里面。</p><p>它们的实现都是在底层调用 JavaScript 引擎提供 JavaScript 字符操作方法。</p><h3 id="uppercasestringtype"><code>Uppercase&lt;StringType&gt;</code> <a class="markdownIt-Anchor" href="#uppercasestringtype">#</a></h3><p><code>Uppercase&lt;StringType&gt;</code>将字符串类型的每个字符转为大写。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> A = <span class="hljs-string">&#x27;hello&#x27;</span>;

<span class="hljs-comment">// &quot;HELLO&quot;</span>
<span class="hljs-keyword">type</span> B = <span class="hljs-title class_">Uppercase</span>&lt;A&gt;;
</code></pre><p>上面示例中，<code>Uppercase&lt;T&gt;</code>将 hello 转为 HELLO。</p><h3 id="lowercasestringtype"><code>Lowercase&lt;StringType&gt;</code> <a class="markdownIt-Anchor" href="#lowercasestringtype">#</a></h3><p><code>Lowercase&lt;StringType&gt;</code>将字符串的每个字符转为小写。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> A = <span class="hljs-string">&#x27;HELLO&#x27;</span>;

<span class="hljs-comment">// &quot;hello&quot;</span>
<span class="hljs-keyword">type</span> B = <span class="hljs-title class_">Lowercase</span>&lt;A&gt;;
</code></pre><p>上面示例中，<code>Lowercase&lt;T&gt;</code>将 HELLO 转为 hello。</p><h3 id="capitalizestringtype"><code>Capitalize&lt;StringType&gt;</code> <a class="markdownIt-Anchor" href="#capitalizestringtype">#</a></h3><p><code>Capitalize&lt;StringType&gt;</code>将字符串的第一个字符转为大写。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> A = <span class="hljs-string">&#x27;hello&#x27;</span>;

<span class="hljs-comment">// &quot;Hello&quot;</span>
<span class="hljs-keyword">type</span> B = <span class="hljs-title class_">Capitalize</span>&lt;A&gt;;
</code></pre><p>上面示例中，<code>Capitalize&lt;T&gt;</code>将 hello 转为 Hello。</p><h3 id="uncapitalizestringtype"><code>Uncapitalize&lt;StringType&gt;</code> <a class="markdownIt-Anchor" href="#uncapitalizestringtype">#</a></h3><p><code>Uncapitalize&lt;StringType&gt;</code> 将字符串的第一个字符转为小写。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> A = <span class="hljs-string">&#x27;HELLO&#x27;</span>;

<span class="hljs-comment">// &quot;hELLO&quot;</span>
<span class="hljs-keyword">type</span> B = <span class="hljs-title class_">Uncapitalize</span>&lt;A&gt;;
</code></pre><p>上面示例中，<code>Uncapitalize&lt;T&gt;</code>将 HELLO 转为 hELLO。</p><h2 id="参考链接">参考链接 <a class="markdownIt-Anchor" href="#参考链接">#</a></h2><ul><li><a href="https://stackoverflow.com/questions/55029032/what-is-typescripts-thistype-used-for" target="_blank" rel="noopener">What is TypeScript's ThisType used for?</a></li></ul></article><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="mapping.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> 类型映射</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="comment.html">注释指令 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><div class="page-info"><p>本教程采用<a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh" target="_blank">知识共享 署名-相同方式共享 3.0协议</a>。</p><p>分享本文 <span class="social-share"></span></p></div></div><div class="column is-3 is-offset-1"><nav class="panel panel-menu is-light"><p class="panel-heading"><i class="fa fa-book" aria-hidden="true"></i> TypeScript 教程</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="intro.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">简介</span></a></li><li><a href="basic.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">基本用法</span></a></li><li><a href="any.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">any 类型</span></a></li><li><a href="types.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型系统</span></a></li><li><a href="array.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">数组</span></a></li><li><a href="tuple.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">元组</span></a></li><li><a href="symbol.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">symbol 类型</span></a></li><li><a href="function.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">函数</span></a></li><li><a href="object.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">对象</span></a></li><li><a href="interface.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">interface</span></a></li><li><a href="class.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类</span></a></li><li><a href="generics.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">泛型</span></a></li><li><a href="enum.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Enum 类型</span></a></li><li><a href="assert.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型断言</span></a></li><li><a href="module.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">模块</span></a></li><li><a href="namespace.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">namespace</span></a></li><li><a href="decorator.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">装饰器</span></a></li><li><a href="decorator-legacy.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">装饰器（旧语法）</span></a></li><li><a href="declare.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">declare 关键字</span></a></li><li><a href="d.ts.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">d.ts 类型声明文件</span></a></li><li><a href="operator.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型运算符</span></a></li><li><a href="mapping.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型映射</span></a></li><li><a href="utility.html" class="is-active"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型工具</span></a></li><li><a href="comment.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">注释指令</span></a></li><li><a href="tsconfig.json.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">tsconfig.json 文件</span></a></li><li><a href="tsc.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">tsc 命令</span></a></li></ul></aside></div></nav><nav class="panel panel-info is-light"><p class="panel-heading"><i class="fa fa-link" aria-hidden="true"></i> 链接</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="https://raw.githubusercontent.com/wangdoc/typescript-tutorial/main/docs/utility.md" target="_blank"><span class="icon"></span><i class="fa fa-code" aria-hidden="true" style="width: 14px;"></i>&nbsp;本文源码</a></li><li><a href="https://github.com/wangdoc/typescript-tutorial" target="_blank"><span class="icon"></span><i class="fa fa-hdd-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;代码仓库</a></li><li><a href="https://github.com/wangdoc/typescript-tutorial/issues" target="_blank"><span class="icon"></span><i class="fa fa-flag-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;反馈</a></li></ul></aside></div></nav></div></div><div class="columns"><div class="column is-8 is-6-widescreen is-offset-1-widescreen"><div id="disqus_thread"></div></div></div></div></section><footer class="footer"><div class="container"><div class="content has-text-centered"><p>联系：contact@wangdoc.com</p></div></div></footer><script>var LOPPO={current_path:"utility.md",relative_root_path:"",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#awaitedtype"><code>Awaited&lt;Type&gt;</code></a></li>\n<li><a href="#constructorparameterstype"><code>ConstructorParameters&lt;Type&gt;</code></a></li>\n<li><a href="#excludeuniontype-excludedmembers"><code>Exclude&lt;UnionType, ExcludedMembers&gt;</code></a></li>\n<li><a href="#extractuniontype-union"><code>Extract&lt;UnionType, Union&gt;</code></a></li>\n<li><a href="#instancetypetype"><code>InstanceType&lt;Type&gt;</code></a></li>\n<li><a href="#nonnullabletype"><code>NonNullable&lt;Type&gt;</code></a></li>\n<li><a href="#omittype-keys"><code>Omit&lt;Type, Keys&gt;</code></a></li>\n<li><a href="#omitthisparametertype"><code>OmitThisParameter&lt;Type&gt;</code></a></li>\n<li><a href="#parameterstype"><code>Parameters&lt;Type&gt;</code></a></li>\n<li><a href="#partialtype"><code>Partial&lt;Type&gt;</code></a></li>\n<li><a href="#picktype-keys"><code>Pick&lt;Type, Keys&gt;</code></a></li>\n<li><a href="#readonlytype"><code>Readonly&lt;Type&gt;</code></a></li>\n<li><a href="#recordkeys-type"><code>Record&lt;Keys, Type&gt;</code></a></li>\n<li><a href="#requiredtype"><code>Required&lt;Type&gt;</code></a></li>\n<li><a href="#readonlyarraytype"><code>ReadonlyArray&lt;Type&gt;</code></a></li>\n<li><a href="#returntypetype"><code>ReturnType&lt;Type&gt;</code></a></li>\n<li><a href="#thisparametertypetype"><code>ThisParameterType&lt;Type&gt;</code></a></li>\n<li><a href="#thistypetype"><code>ThisType&lt;Type&gt;</code></a></li>\n<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7">字符串类型工具</a>\n<ul>\n<li><a href="#uppercasestringtype"><code>Uppercase&lt;StringType&gt;</code></a></li>\n<li><a href="#lowercasestringtype"><code>Lowercase&lt;StringType&gt;</code></a></li>\n<li><a href="#capitalizestringtype"><code>Capitalize&lt;StringType&gt;</code></a></li>\n<li><a href="#uncapitalizestringtype"><code>Uncapitalize&lt;StringType&gt;</code></a></li>\n</ul>\n</li>\n<li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li>\n</ul>\n'}</script><script src="assets/js/app.js"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-111269443-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-111269443-1")</script><script>var _hmt=_hmt||[];(()=>{var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?5eec262881855af3dede6a71234571f6",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)})()</script><script>var disqus_config=function(){var t=window.location,e=t.protocol+"//"+t.host+(t.port?":"+t.port:"")+t.pathname;this.page.url=e,this.page.identifier=t.pathname};(()=>{var t=document,e=t.createElement("script");e.src="https://wangdoc-typescript.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)})()</script><!--script src="assets/js/social-share.min.js"--><!--/script--><script>var shareDesc="我正在阅读《TypeScript 类型工具》，出自网道（WangDoc.com）的《TypeScript 教程》。",shareOpts={url:window.location.href,source:shareDesc,title:shareDesc,description:"",image:"",sites:["weibo","wechat","qq","qzone","twitter","facebook"],origin:"WangDoc_com",disabled:[],wechatQrcodeTitle:"微信",wechatQrcodeHelper:"扫一下二维码，分享到微信。"};socialShare(".social-share",shareOpts)</script></body></html>