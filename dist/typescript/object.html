<!DOCTYPE html><html lang="zh-CN" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>TypeScript 的对象类型 - TypeScript 教程 - 网道</title><!-- link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" --><link rel="stylesheet" href="assets/css/app.min.css"><link rel="stylesheet" href="https://apps.bdimg.com/libs/fontawesome/4.4.0/css/font-awesome.css"><!-- link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css"--><!-- link rel="stylesheet" href="assets/css/share.min.css" --><meta property="og:type" content="article"><meta property="og:title" content="TypeScript 的对象类型"><link rel="apple-touch-icon" href="assets/icons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="192x192" href="assets/icons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="assets/icons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="assets/icons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="assets/icons/favicon-16x16.png"><link rel="manifest" href="assets/icons/manifest.json"></head><body><nav class="navbar is-light" role="navigation" id="navbar" aria-label="main navigation"><div class="container"><div class="navbar-brand"><a href="/" class="navbar-item title has-text-grey has-text-weight-light is-5">网道 / WangDoc.com </a><a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false"><span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span></a></div><div class="navbar-menu" id="navMenu"><div class="navbar-end"><div class="navbar-item"><form action="https://sourcegraph.com/search" target="_blank" method="get" onsubmit='this.q.value="repo:^github.com/wangdoc/typescript-tutorial$ "+this.origin.value'><p class="control has-icons-right"><input class="input" type="text" name="origin" placeholder="搜索..."> <span class="icon is-small is-right"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"><path fill="#ddd" d="M23.822 20.88l-6.353-6.354c.93-1.465 1.467-3.2 1.467-5.059.001-5.219-4.247-9.467-9.468-9.467s-9.468 4.248-9.468 9.468c0 5.221 4.247 9.469 9.468 9.469 1.768 0 3.421-.487 4.839-1.333l6.396 6.396 3.119-3.12zm-20.294-11.412c0-3.273 2.665-5.938 5.939-5.938 3.275 0 5.94 2.664 5.94 5.938 0 3.275-2.665 5.939-5.94 5.939-3.274 0-5.939-2.664-5.939-5.939z"/></svg></span></p><input type="hidden" name="q" value=""> <input type="hidden" name="patternType" value="literal"></form></div><a class="navbar-item is-hidden-desktop-only" target="_blank" href="https://github.com/wangdoc/typescript-tutorial"><span class="icon" style="color: #333;"><i class="fa fa-lg fa-github"></i></span></a></div></div></div></nav><section class="section main article"><div class="container"><div class="columns"><div class="column is-8 is-6-widescreen is-offset-1-widescreen"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="index.html"><span class="icon"><i class="fa fa-home"></i></span> &nbsp;TypeScript 教程</a></li><li class="is-active"><a class="has-text-grey" href="object.html">对象</a></li></ul></nav><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="function.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> 函数</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="interface.html">interface <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><article class="content"><h1 class="title">TypeScript 的对象类型</h1><div class="page-meta"><p>网道（WangDoc.com），互联网文档计划</p></div><h2 id="简介">简介 <a class="markdownIt-Anchor" href="#简介">#</a></h2><p>除了原始类型，对象是 JavaScript 最基本的数据结构。TypeScript 对于对象类型有很多规则。</p><p>对象类型的最简单声明方法，就是使用大括号表示对象，在大括号内部声明每个属性和方法的类型。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:{
  <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>;
} = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">1</span> };
</code></pre><p>上面示例中，对象<code>obj</code>的类型就写在变量名后面，使用大括号描述，内部声明每个属性的属性名和类型。</p><p>属性的类型可以用分号结尾，也可以用逗号结尾。</p><pre class="hljs"><code><span class="hljs-comment">// 属性类型以分号结尾</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">MyObj</span> = {
  <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>;
};

<span class="hljs-comment">// 属性类型以逗号结尾</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">MyObj</span> = {
  <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>,
  <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>,
};
</code></pre><p>最后一个属性后面，可以写分号或逗号，也可以不写。</p><p>一旦声明了类型，对象赋值时，就不能缺少指定的属性，也不能有多余的属性。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyObj</span> = {
  <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>;
};

<span class="hljs-keyword">const</span> <span class="hljs-attr">o1</span>:<span class="hljs-title class_">MyObj</span> = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> }; <span class="hljs-comment">// 报错</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">o2</span>:<span class="hljs-title class_">MyObj</span> = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">1</span> }; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，变量<code>o1</code>缺少了属性<code>y</code>，变量<code>o2</code>多出了属性<code>z</code>，都会报错。</p><p>读写不存在的属性也会报错。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:{
  <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>;
} = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">1</span> };

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">z</span>); <span class="hljs-comment">// 报错</span>
obj.<span class="hljs-property">z</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，读写不存在的属性<code>z</code>都会报错。</p><p>同样地，也不能删除类型声明中存在的属性，修改属性值是可以的。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> myUser = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Sabrina&quot;</span>,
};

<span class="hljs-keyword">delete</span> myUser.<span class="hljs-property">name</span> <span class="hljs-comment">// 报错</span>
myUser.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Cynthia&quot;</span>; <span class="hljs-comment">// 正确</span>
</code></pre><p>上面声明中，删除类型声明中存在的属性<code>name</code>会报错，但是可以修改它的值。</p><p>对象的方法使用函数类型描述。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:{
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-title function_">add</span>(<span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
  <span class="hljs-comment">// 或者写成</span>
  <span class="hljs-comment">// add: (x:number, y:number) =&gt; number;</span>
} = {
  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-number">1</span>,
  <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) {
    <span class="hljs-keyword">return</span> x + y;
  }
};
</code></pre><p>上面示例中，对象<code>obj</code>有一个方法<code>add()</code>，需要定义它的参数类型和返回值类型。</p><p>对象类型可以使用方括号读取属性的类型。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>
};
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Name</span> = <span class="hljs-title class_">User</span>[<span class="hljs-string">&#x27;name&#x27;</span>]; <span class="hljs-comment">// string</span>
</code></pre><p>上面示例中，对象类型<code>User</code>使用方括号，读取了属性<code>name</code>的类型（<code>string</code>）。</p><p>除了<code>type</code>命令可以为对象类型声明一个别名，TypeScript 还提供了<code>interface</code>命令，可以把对象类型提炼为一个接口。</p><pre class="hljs"><code><span class="hljs-comment">// 写法一</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">MyObj</span> = {
  <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>;
};

<span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:<span class="hljs-title class_">MyObj</span> = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">1</span> };

<span class="hljs-comment">// 写法二</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyObj</span> {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:<span class="hljs-title class_">MyObj</span> = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">1</span> };
</code></pre><p>上面示例中，写法一是<code>type</code>命令的用法，写法二是<code>interface</code>命令的用法。<code>interface</code>命令的详细解释，以及与<code>type</code>命令的区别，详见《Interface》一章。</p><p>注意，TypeScript 不区分对象自身的属性和继承的属性，一律视为对象的属性。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> {
  <span class="hljs-title function_">toString</span>(): <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 继承的属性</span>
  <span class="hljs-attr">prop</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 自身的属性</span>
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:<span class="hljs-title class_">MyInterface</span> = { <span class="hljs-comment">// 正确</span>
  <span class="hljs-attr">prop</span>: <span class="hljs-number">123</span>,
};
</code></pre><p>上面示例中，<code>obj</code>只写了<code>prop</code>属性，但是不报错。因为它可以继承原型上面的<code>toString()</code>方法。</p><h2 id="可选属性">可选属性 <a class="markdownIt-Anchor" href="#可选属性">#</a></h2><p>如果某个属性是可选的（即可以忽略），需要在属性名后面加一个问号。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>: {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  y?: <span class="hljs-built_in">number</span>;
} = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> };
</code></pre><p>上面示例中，属性<code>y</code>是可选的。</p><p>可选属性等同于允许赋值为<code>undefined</code>，下面两种写法是等效的。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = {
  <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span>;
  lastName?: <span class="hljs-built_in">string</span>;
};

<span class="hljs-comment">// 等同于</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = {
  <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span>;
  lastName?: <span class="hljs-built_in">string</span>|<span class="hljs-literal">undefined</span>;
};
</code></pre><p>上面示例中，类型<code>User</code>的可选属性<code>lastName</code>可以是字符串，也可以是<code>undefined</code>，即可选属性可以赋值为<code>undefined</code>。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>: {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  y?: <span class="hljs-built_in">number</span>;
} = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-literal">undefined</span> };
</code></pre><p>上面示例中，可选属性<code>y</code>赋值为<code>undefined</code>，不会报错。</p><p>同样地，读取一个没有赋值的可选属性时，返回<code>undefined</code>。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyObj</span> = {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>,
  y?: <span class="hljs-built_in">string</span>
};

<span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:<span class="hljs-title class_">MyObj</span> = { <span class="hljs-attr">x</span>: <span class="hljs-string">&#x27;hello&#x27;</span> };
obj.<span class="hljs-property">y</span>.<span class="hljs-title function_">toLowerCase</span>() <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，最后一行会报错，因为<code>obj.y</code>返回<code>undefined</code>，无法对其调用<code>toLowerCase()</code>。</p><p>所以，读取可选属性之前，必须检查一下是否为<code>undefined</code>。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">user</span>:{
  <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span>;
  lastName?: <span class="hljs-built_in">string</span>;
} = { <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;Foo&#x27;</span>};

<span class="hljs-keyword">if</span> (user.<span class="hljs-property">lastName</span> !== <span class="hljs-literal">undefined</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`hello <span class="hljs-subst">${user.firstName}</span> <span class="hljs-subst">${user.lastName}</span>`</span>)
}
</code></pre><p>上面示例中，<code>lastName</code>是可选属性，需要判断是否为<code>undefined</code>以后，才能使用。建议使用下面的写法。</p><pre class="hljs"><code><span class="hljs-comment">// 写法一</span>
<span class="hljs-keyword">let</span> firstName = (user.<span class="hljs-property">firstName</span> === <span class="hljs-literal">undefined</span>)
  ? <span class="hljs-string">&#x27;Foo&#x27;</span> : user.<span class="hljs-property">firstName</span>;
<span class="hljs-keyword">let</span> lastName = (user.<span class="hljs-property">lastName</span> === <span class="hljs-literal">undefined</span>)
  ? <span class="hljs-string">&#x27;Bar&#x27;</span> : user.<span class="hljs-property">lastName</span>;

<span class="hljs-comment">// 写法二</span>
<span class="hljs-keyword">let</span> firstName = user.<span class="hljs-property">firstName</span> ?? <span class="hljs-string">&#x27;Foo&#x27;</span>;
<span class="hljs-keyword">let</span> lastName = user.<span class="hljs-property">lastName</span> ?? <span class="hljs-string">&#x27;Bar&#x27;</span>;
</code></pre><p>上面示例中，写法一使用三元运算符<code>?:</code>，判断是否为<code>undefined</code>，并设置默认值。写法二使用 Null 判断运算符<code>??</code>，与写法一的作用完全相同。</p><p>TypeScript 提供编译设置<code>ExactOptionalPropertyTypes</code>，只要同时打开这个设置和<code>strictNullChecks</code>，可选属性就不能设为<code>undefined</code>。</p><pre class="hljs"><code><span class="hljs-comment">// 打开 ExactOptionsPropertyTypes 和 strictNullChecks</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>: {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  y?: <span class="hljs-built_in">number</span>;
} = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-literal">undefined</span> }; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，打开了这两个设置以后，可选属性就不能设为<code>undefined</code>了。</p><p>注意，可选属性与允许设为<code>undefined</code>的必选属性是不等价的。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> A = { <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>, y?:<span class="hljs-built_in">number</span> };
<span class="hljs-keyword">type</span> B = { <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>|<span class="hljs-literal">undefined</span> };

<span class="hljs-keyword">const</span> <span class="hljs-title class_">ObjA</span>:A = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> }; <span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">ObjB</span>:B = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> }; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，属性<code>y</code>如果是一个可选属性，那就可以省略不写；如果是允许设为<code>undefined</code>的必选属性，一旦省略就会报错，必须显式写成<code>{ x: 1, y: undefined }</code>。</p><h2 id="只读属性">只读属性 <a class="markdownIt-Anchor" href="#只读属性">#</a></h2><p>属性名前面加上<code>readonly</code>关键字，表示这个属性是只读属性，不能修改。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> {
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">prop</span>: <span class="hljs-built_in">number</span>;
}
</code></pre><p>上面示例中，<code>prop</code>属性是只读属性，不能修改它的值。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">person</span>:{
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>
} = { <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> };

person.<span class="hljs-property">age</span> = <span class="hljs-number">21</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，最后一行修改了只读属性<code>age</code>，就报错了。</p><p>只读属性只能在对象初始化期间赋值，此后就不能修改该属性。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = {
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;
};

<span class="hljs-keyword">const</span> <span class="hljs-attr">p</span>:<span class="hljs-title class_">Point</span> = { <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> };

p.<span class="hljs-property">x</span> = <span class="hljs-number">100</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，类型<code>Point</code>的属性<code>x</code>和<code>y</code>都带有修饰符<code>readonly</code>，表示这两个属性只能在初始化期间赋值，后面再修改就会报错。</p><p>注意，如果属性值是一个对象，<code>readonly</code>修饰符并不禁止修改该对象的属性，只是禁止完全替换掉该对象。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Home</span> {
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">resident</span>: {
    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>
  };
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">h</span>:<span class="hljs-title class_">Home</span> = {
  <span class="hljs-attr">resident</span>: {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Vicky&#x27;</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">42</span>
  }
};

h.<span class="hljs-property">resident</span>.<span class="hljs-property">age</span> = <span class="hljs-number">32</span>; <span class="hljs-comment">// 正确</span>
h.<span class="hljs-property">resident</span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Kate&#x27;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">23</span> 
} <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，<code>h.resident</code>是只读属性，它的值是一个对象。修改这个对象的<code>age</code>属性是可以的，但是整个替换掉<code>h.resident</code>属性会报错。</p><p>另一个需要注意的地方是，如果一个对象有两个引用，即两个变量对应同一个对象，其中一个变量是可写的，另一个变量是只读的，那么从可写变量修改属性，会影响到只读变量。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">ReadonlyPerson</span> {
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">let</span> <span class="hljs-attr">w</span>:<span class="hljs-title class_">Person</span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Vicky&#x27;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">42</span>,
};

<span class="hljs-keyword">let</span> <span class="hljs-attr">r</span>:<span class="hljs-title class_">ReadonlyPerson</span> = w;

w.<span class="hljs-property">age</span> += <span class="hljs-number">1</span>;
r.<span class="hljs-property">age</span> <span class="hljs-comment">// 43</span>
</code></pre><p>上面示例中，变量<code>w</code>和<code>r</code>指向同一个对象，其中<code>w</code>是可写的，<code>r</code>是只读的。那么，对<code>w</code>的属性修改，会影响到<code>r</code>。</p><p>如果希望属性值是只读的，除了声明时加上<code>readonly</code>关键字，还有一种方法，就是在赋值时，在对象后面加上只读断言<code>as const</code>。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> myUser = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Sabrina&quot;</span>,
} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;

myUser.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Cynthia&quot;</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，对象后面加了只读断言<code>as const</code>，就变成只读对象了，不能修改属性了。</p><p>注意，上面的<code>as const</code>属于 TypeScript 的类型推断，如果变量明确地声明了类型，那么 TypeScript 会以声明的类型为准。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">myUser</span>:{ <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> } = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Sabrina&quot;</span>,
} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;

myUser.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Cynthia&quot;</span>; <span class="hljs-comment">// 正确</span>
</code></pre><p>上面示例中，根据变量<code>myUser</code>的类型声明，<code>name</code>不是只读属性，但是赋值时又使用只读断言<code>as const</code>。这时会以声明的类型为准，因为<code>name</code>属性可以修改。</p><h2 id="属性名的索引类型">属性名的索引类型 <a class="markdownIt-Anchor" href="#属性名的索引类型">#</a></h2><p>如果对象的属性非常多，一个个声明类型就很麻烦，而且有些时候，无法事前知道对象会有多少属性，比如外部 API 返回的对象。这时 TypeScript 允许采用属性名表达式的写法来描述类型，称为“属性名的索引类型”。</p><p>索引类型里面，最常见的就是属性名的字符串索引。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyObj</span> = {
  [<span class="hljs-attr">property</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>
};

<span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:<span class="hljs-title class_">MyObj</span> = {
  <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;a&#x27;</span>,
  <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;b&#x27;</span>,
  <span class="hljs-attr">baz</span>: <span class="hljs-string">&#x27;c&#x27;</span>,
};
</code></pre><p>上面示例中，类型<code>MyObj</code>的属性名类型就采用了表达式形式，写在方括号里面。<code>[property: string]</code>的<code>property</code>表示属性名，这个是可以随便起的，它的类型是<code>string</code>，即属性名类型为<code>string</code>。也就是说，不管这个对象有多少属性，只要属性名为字符串，且属性值也是字符串，就符合这个类型声明。</p><p>JavaScript 对象的属性名（即上例的<code>property</code>）的类型有三种可能，除了上例的<code>string</code>，还有<code>number</code>和<code>symbol</code>。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = {
  [<span class="hljs-attr">property</span>: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span>
};

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = {
  [<span class="hljs-attr">property</span>: <span class="hljs-built_in">symbol</span>]: <span class="hljs-built_in">string</span>
};
</code></pre><p>上面示例中，对象属性名的类型分别为<code>number</code>和<code>symbol</code>。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyArr</span> = {
  [<span class="hljs-attr">n</span>:<span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span>;
};

<span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>:<span class="hljs-title class_">MyArr</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-comment">// 或者</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>:<span class="hljs-title class_">MyArr</span> = {
  <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,
  <span class="hljs-number">1</span>: <span class="hljs-number">2</span>,
  <span class="hljs-number">2</span>: <span class="hljs-number">3</span>,
};
</code></pre><p>上面示例中，对象类型<code>MyArr</code>的属性名是<code>[n:number]</code>，就表示它的属性名都是数值，比如<code>0</code>、<code>1</code>、<code>2</code>。</p><p>对象可以同时有多种类型的属性名索引，比如同时有数值索引和字符串索引。但是，数值索引不能与字符串索引发生冲突，必须服从后者，这是因为在 JavaScript 语言内部，所有的数值属性名都会自动转为字符串属性名。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyType</span> = {
  [<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">boolean</span>; <span class="hljs-comment">// 报错</span>
  [<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;
}
</code></pre><p>上面示例中，类型<code>MyType</code>同时有两种属性名索引，但是数值索引与字符串索引冲突了，所以报错了。由于字符属性名的值类型是<code>string</code>，数值属性名的值类型只有同样为<code>string</code>，才不会报错。</p><p>同样地，可以既声明属性名索引，也声明具体的单个属性名。如果单个属性名不符合属性名索引的范围，两者发生冲突，就会报错。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyType</span> = {
  <span class="hljs-attr">foo</span>: <span class="hljs-built_in">boolean</span>; <span class="hljs-comment">// 报错</span>
  [<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;
}
</code></pre><p>上面示例中，属性名<code>foo</code>符合属性名的字符串索引，但是两者的属性值类型不一样，所以报错了。</p><p>属性的索引类型写法，建议谨慎使用，因为属性名的声明太宽泛，约束太少。另外，属性名的数值索引不宜用来声明数组，因为采用这种方式声明数组，就不能使用各种数组方法以及<code>length</code>属性，因为类型里面没有定义这些东西。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyArr</span> = {
  [<span class="hljs-attr">n</span>:<span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span>;
};

<span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>:<span class="hljs-title class_">MyArr</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
arr.<span class="hljs-property">length</span> <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，读取<code>arr.length</code>属性会报错，因为类型<code>MyArr</code>没有这个属性。</p><h2 id="解构赋值">解构赋值 <a class="markdownIt-Anchor" href="#解构赋值">#</a></h2><p>解构赋值用于直接从对象中提取属性。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> {id, name, price} = product;
</code></pre><p>上面语句从对象<code>product</code>提取了三个属性，并声明属性名的同名变量。</p><p>解构赋值的类型写法，跟为对象声明类型是一样的。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> {id, name, price}:{
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">price</span>: <span class="hljs-built_in">number</span>
} = product;
</code></pre><p>注意，目前没法为解构变量指定类型，因为对象解构里面的冒号，JavaScript 指定了其他用途。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> { <span class="hljs-attr">x</span>: foo, <span class="hljs-attr">y</span>: bar } = obj;

<span class="hljs-comment">// 等同于</span>
<span class="hljs-keyword">let</span> foo = obj.<span class="hljs-property">x</span>;
<span class="hljs-keyword">let</span> bar = obj.<span class="hljs-property">y</span>;
</code></pre><p>上面示例中，冒号不是表示属性<code>x</code>和<code>y</code>的类型，而是为这两个属性指定新的变量名。如果要为<code>x</code>和<code>y</code>指定类型，不得不写成下面这样。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> { <span class="hljs-attr">x</span>: foo, <span class="hljs-attr">y</span>: bar }
  : { <span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span> } = obj;
</code></pre><p>这一点要特别小心，TypeScript 里面很容易搞糊涂。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params">{
  shape: Shape,
  xPos: <span class="hljs-built_in">number</span> = <span class="hljs-number">100</span>,
  yPos: <span class="hljs-built_in">number</span> = <span class="hljs-number">100</span>
}</span>) {
  <span class="hljs-keyword">let</span> myShape = shape; <span class="hljs-comment">// 报错</span>
  <span class="hljs-keyword">let</span> x = xPos; <span class="hljs-comment">// 报错</span>
}
</code></pre><p>上面示例中，函数<code>draw()</code>的参数是一个对象解构，里面的冒号很像是为变量指定类型，其实是为对应的属性指定新的变量名。所以，TypeScript 就会解读成，函数体内不存在变量<code>shape</code>，而是属性<code>shape</code>的值被赋值给了变量<code>Shape</code>。</p><h2 id="结构类型原则">结构类型原则 <a class="markdownIt-Anchor" href="#结构类型原则">#</a></h2><p>只要对象 B 满足 对象 A 的结构特征，TypeScript 就认为对象 B 兼容对象 A 的类型，这称为“结构类型”原则（structural typing）。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> A = {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
};

<span class="hljs-keyword">type</span> B = {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;
};
</code></pre><p>上面示例中，对象<code>A</code>只有一个属性<code>x</code>，类型为<code>number</code>。对象<code>B</code>满足这个特征，因此兼容对象<code>A</code>，只要可以使用<code>A</code>的地方，就可以使用<code>B</code>。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> B = {
  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-number">1</span>
};

<span class="hljs-keyword">const</span> <span class="hljs-attr">A</span>:{ <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span> } = B; <span class="hljs-comment">// 正确</span>
</code></pre><p>上面示例中，<code>A</code>和<code>B</code>并不是同一个类型，但是<code>B</code>可以赋值给<code>A</code>，因为<code>B</code>满足<code>A</code>的结构特征。</p><p>根据“结构类型”原则，TypeScript 检查某个值是否符合指定类型时，并不是检查这个值的类型名（即“名义类型”），而是检查这个值的结构是否符合要求（即“结构类型”）。</p><p>TypeScript 之所以这样设计，是为了符合 JavaScript 的行为。JavaScript 并不关心对象是否严格相似，只要某个对象具有所要求的属性，就可以正确运行。</p><p>如果类型 B 可以赋值给类型 A，TypeScript 就认为 B 是 A 的子类型（subtyping），A 是 B 的父类型。子类型满足父类型的所有结构特征，同时还具有自己的特征。凡是可以使用父类型的地方，都可以使用子类型，即子类型兼容父类型。</p><p>这种设计有时会导致令人惊讶的结果。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> myObj = {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>,
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">getSum</span>(<span class="hljs-params">obj:myObj</span>) {
  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> n <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)) {
    <span class="hljs-keyword">const</span> v = obj[n]; <span class="hljs-comment">// 报错</span>
    sum += <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(v);
  }

  <span class="hljs-keyword">return</span> sum;
}
</code></pre><p>上面示例中，函数<code>getSum()</code>要求传入参数的类型是<code>myObj</code>，但是实际上所有与<code>myObj</code>兼容的对象都可以传入。这会导致<code>const v = obj[n]</code>这一行报错，原因是<code>obj[n]</code>取出的属性值不一定是数值（<code>number</code>），使得变量<code>v</code>的类型被推断为<code>any</code>。如果项目设置为不允许变量类型推断为<code>any</code>，代码就会报错。写成下面这样，就不会报错。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyObj</span> = {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>,
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">getSum</span>(<span class="hljs-params">obj:MyObj</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(obj.<span class="hljs-property">x</span>) + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(obj.<span class="hljs-property">y</span>);
}
</code></pre><p>上面示例就不会报错，因为函数体内部只使用了属性<code>x</code>和<code>y</code>，这两个属性有明确的类型声明，保证<code>obj.x</code>和<code>obj.y</code>肯定是数值。虽然与<code>MyObj</code>兼容的任何对象都可以传入函数<code>getSum()</code>，但是只要不使用其他属性，就不会有类型报错。</p><h2 id="严格字面量检查">严格字面量检查 <a class="markdownIt-Anchor" href="#严格字面量检查">#</a></h2><p>如果对象使用字面量表示，会触发 TypeScript 的严格字面量检查（strict object literal checking）。如果字面量的结构跟类型定义的不一样（比如多出了未定义的属性），就会报错。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">point</span>:{
  <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>;
} = {
  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">z</span>: <span class="hljs-number">1</span> <span class="hljs-comment">// 报错</span>
};
</code></pre><p>上面示例中，等号右边是一个对象的字面量，这时会触发严格字面量检查。只要有类型声明中不存在的属性（本例是<code>z</code>），就会导致报错。</p><p>如果等号右边不是字面量，而是一个变量，根据结构类型原则，是不会报错的。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> myPoint = {
  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">z</span>: <span class="hljs-number">1</span>
};

<span class="hljs-keyword">const</span> <span class="hljs-attr">point</span>:{
  <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>;
} = myPoint; <span class="hljs-comment">// 正确</span>
</code></pre><p>上面示例中，等号右边是一个变量，就不会触发严格字面量检查，从而不报错。</p><p>TypeScript 对字面量进行严格检查的目的，主要是防止拼写错误。一般来说，字面量大多数来自手写，容易出现拼写错误，或者误用 API。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Options</span> = {
  <span class="hljs-attr">title</span>:<span class="hljs-built_in">string</span>;
  darkMode?:<span class="hljs-built_in">boolean</span>;
};

<span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:<span class="hljs-title class_">Options</span> = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;我的网页&#x27;</span>,
  <span class="hljs-attr">darkmode</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 报错</span>
};
</code></pre><p>上面示例中，属性<code>darkMode</code>拼写错了，成了<code>darkmode</code>。如果没有严格字面量规则，就不会报错，因为<code>darkMode</code>是可选属性，根据结构类型原则，任何对象只要有<code>title</code>属性，都认为符合<code>Options</code>类型。</p><p>规避严格字面量检查，可以使用中间变量。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> myOptions = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;我的网页&#x27;</span>,
  <span class="hljs-attr">darkmode</span>: <span class="hljs-literal">true</span>,
};

<span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:<span class="hljs-title class_">Options</span> = myOptions;
</code></pre><p>上面示例中，创建了一个中间变量<code>myOptions</code>，就不会触发严格字面量规则，因为这时变量<code>obj</code>的赋值，不属于直接字面量赋值。</p><p>如果你确认字面量没有错误，也可以使用类型断言规避严格字面量检查。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:<span class="hljs-title class_">Options</span> = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;我的网页&#x27;</span>,
  <span class="hljs-attr">darkmode</span>: <span class="hljs-literal">true</span>,
} <span class="hljs-keyword">as</span> <span class="hljs-title class_">Options</span>;
</code></pre><p>上面示例使用类型断言<code>as Options</code>，告诉编译器，字面量符合 Options 类型，就能规避这条规则。</p><p>如果允许字面量有多余属性，可以像下面这样在类型里面定义一个通用属性。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: {
  <span class="hljs-attr">foo</span>: <span class="hljs-built_in">number</span>,
  [<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>
};

x = { <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">baz</span>: <span class="hljs-number">2</span> };  <span class="hljs-comment">// Ok</span>
</code></pre><p>上面示例中，变量<code>x</code>的类型声明里面，有一个属性的字符串索引（<code>[x: string]</code>），导致任何字符串属性名都是合法的。</p><p>由于严格字面量检查，字面量对象传入函数必须很小心，不能有多余的属性。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">computeDistance</span>(<span class="hljs-params">point: Point</span>) { <span class="hljs-comment">/*...*/</span> }

<span class="hljs-title function_">computeDistance</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">3</span> }); <span class="hljs-comment">// 报错</span>
<span class="hljs-title function_">computeDistance</span>({<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>}); <span class="hljs-comment">// 正确</span>
</code></pre><p>上面示例中，对象字面量传入函数<code>computeDistance()</code>时，不能有多余的属性，否则就通不过严格字面量检查。</p><p>编译器选项<code>suppressExcessPropertyErrors</code>，可以关闭多余属性检查。下面是它在 tsconfig.json 文件里面的写法。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;compilerOptions&quot;</span>: {
    <span class="hljs-string">&quot;suppressExcessPropertyErrors&quot;</span>: <span class="hljs-literal">true</span>
  }
}
</code></pre><h2 id="最小可选属性规则">最小可选属性规则 <a class="markdownIt-Anchor" href="#最小可选属性规则">#</a></h2><p>根据“结构类型”原则，如果一个对象的所有属性都是可选的，那么其他对象跟它都是结构类似的。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Options</span> = {
  a?:<span class="hljs-built_in">number</span>;
  b?:<span class="hljs-built_in">number</span>;
  c?:<span class="hljs-built_in">number</span>;
};
</code></pre><p>上面示例中，类型<code>Options</code>的所有属性都是可选的，所以它可以是一个空对象，也就意味着任意对象都满足<code>Options</code>的结构。</p><p>为了避免这种情况，TypeScript 2.4 引入了一个“最小可选属性规则”，也称为<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-4.html#weak-type-detection" target="_blank" rel="noopener">“弱类型检测”</a>（weak type detection）。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Options</span> = {
  a?:<span class="hljs-built_in">number</span>;
  b?:<span class="hljs-built_in">number</span>;
  c?:<span class="hljs-built_in">number</span>;
};

<span class="hljs-keyword">const</span> opts = { <span class="hljs-attr">d</span>: <span class="hljs-number">123</span> };

<span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:<span class="hljs-title class_">Options</span> = opts; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，对象<code>opts</code>与类型<code>Options</code>没有共同属性，赋值给该类型的变量就会报错。</p><p>报错原因是，如果某个类型的所有属性都是可选的，那么该类型的对象必须至少存在一个可选属性，不能所有可选属性都不存在。这就叫做“最小可选属性规则”。</p><p>如果想规避这条规则，要么在类型里面增加一条索引属性（<code>[propName: string]: someType</code>），要么使用类型断言（<code>opts as Options</code>）。</p><h2 id="空对象">空对象 <a class="markdownIt-Anchor" href="#空对象">#</a></h2><p>空对象是 TypeScript 的一种特殊值，也是一种特殊类型。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> obj = {};
obj.<span class="hljs-property">prop</span> = <span class="hljs-number">123</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，变量<code>obj</code>的值是一个空对象，然后对<code>obj.prop</code>赋值就会报错。</p><p>原因是这时 TypeScript 会推断变量<code>obj</code>的类型为空对象，实际执行的是下面的代码。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:{} = {};
</code></pre><p>空对象没有自定义属性，所以对自定义属性赋值就会报错。空对象只能使用继承的属性，即继承自原型对象<code>Object.prototype</code>的属性。</p><pre class="hljs"><code>obj.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// 正确</span>
</code></pre><p>上面示例中，<code>toString()</code>方法是一个继承自原型对象的方法，TypeScript 允许在空对象上使用。</p><p>回到本节开始的例子，这种写法其实在 JavaScript 很常见：先声明一个空对象，然后向空对象添加属性。但是，TypeScript 不允许动态添加属性，所以对象不能分步生成，必须生成时一次性声明所有属性。</p><pre class="hljs"><code><span class="hljs-comment">// 错误</span>
<span class="hljs-keyword">const</span> pt = {};
pt.<span class="hljs-property">x</span> = <span class="hljs-number">3</span>;
pt.<span class="hljs-property">y</span> = <span class="hljs-number">4</span>;

<span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">const</span> pt = {
  <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-number">4</span>
};
</code></pre><p>如果确实需要分步声明，一个比较好的方法是，使用扩展运算符（<code>...</code>）合成一个新对象。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> pt0 = {};
<span class="hljs-keyword">const</span> pt1 = { <span class="hljs-attr">x</span>: <span class="hljs-number">3</span> };
<span class="hljs-keyword">const</span> pt2 = { <span class="hljs-attr">y</span>: <span class="hljs-number">4</span> };

<span class="hljs-keyword">const</span> pt = {
  ...pt0, ...pt1, ...pt2
};
</code></pre><p>上面示例中，对象<code>pt</code>是三个部分合成的，这样既可以分步声明，也符合 TypeScript 静态声明的要求。</p><p>空对象作为类型，其实是<code>Object</code>类型的简写形式。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-attr">d</span>:{};
<span class="hljs-comment">// 等同于</span>
<span class="hljs-comment">// let d:Object;</span>

d = {};
d = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> };
d = <span class="hljs-string">&#x27;hello&#x27;</span>;
d = <span class="hljs-number">2</span>;
</code></pre><p>上面示例中，各种类型的值（除了<code>null</code>和<code>undefined</code>）都可以赋值给空对象类型，跟<code>Object</code>类型的行为是一样的。</p><p>因为<code>Object</code>可以接受各种类型的值，而空对象是<code>Object</code>类型的简写，所以它不会有严格字面量检查，赋值时总是允许多余的属性，只是不能读取这些属性。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Empty</span> { }
<span class="hljs-keyword">const</span> <span class="hljs-attr">b</span>:<span class="hljs-title class_">Empty</span> = {<span class="hljs-attr">myProp</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">anotherProp</span>: <span class="hljs-number">2</span>}; <span class="hljs-comment">// 正确</span>
b.<span class="hljs-property">myProp</span> <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，变量<code>b</code>的类型是空对象，视同<code>Object</code>类型，不会有严格字面量检查，但是读取多余的属性会报错。</p><p>如果想强制使用没有任何属性的对象，可以采用下面的写法。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">WithoutProperties</span> {
  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">never</span>;
}

<span class="hljs-comment">// 报错</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>:<span class="hljs-title class_">WithoutProperties</span> = { <span class="hljs-attr">prop</span>: <span class="hljs-number">1</span> };
</code></pre><p>上面的示例中，<code>[key: string]: never</code>表示字符串属性名是不存在的，因此其他对象进行赋值时就会报错。</p></article><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="function.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> 函数</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="interface.html">interface <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><div class="page-info"><p>本教程采用<a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh" target="_blank">知识共享 署名-相同方式共享 3.0协议</a>。</p><p>分享本文 <span class="social-share"></span></p></div></div><div class="column is-3 is-offset-1"><nav class="panel panel-menu is-light"><p class="panel-heading"><i class="fa fa-book" aria-hidden="true"></i> TypeScript 教程</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="intro.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">简介</span></a></li><li><a href="basic.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">基本用法</span></a></li><li><a href="any.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">any 类型</span></a></li><li><a href="types.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型系统</span></a></li><li><a href="array.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">数组</span></a></li><li><a href="tuple.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">元组</span></a></li><li><a href="symbol.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">symbol 类型</span></a></li><li><a href="function.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">函数</span></a></li><li><a href="object.html" class="is-active"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">对象</span></a></li><li><a href="interface.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">interface</span></a></li><li><a href="class.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类</span></a></li><li><a href="generics.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">泛型</span></a></li><li><a href="enum.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Enum 类型</span></a></li><li><a href="assert.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型断言</span></a></li><li><a href="module.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">模块</span></a></li><li><a href="namespace.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">namespace</span></a></li><li><a href="decorator.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">装饰器</span></a></li><li><a href="decorator-legacy.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">装饰器（旧语法）</span></a></li><li><a href="declare.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">declare 关键字</span></a></li><li><a href="d.ts.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">d.ts 类型声明文件</span></a></li><li><a href="operator.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型运算符</span></a></li><li><a href="mapping.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型映射</span></a></li><li><a href="utility.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型工具</span></a></li><li><a href="comment.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">注释指令</span></a></li><li><a href="tsconfig.json.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">tsconfig.json 文件</span></a></li><li><a href="tsc.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">tsc 命令</span></a></li></ul></aside></div></nav><nav class="panel panel-info is-light"><p class="panel-heading"><i class="fa fa-link" aria-hidden="true"></i> 链接</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="https://raw.githubusercontent.com/wangdoc/typescript-tutorial/main/docs/object.md" target="_blank"><span class="icon"></span><i class="fa fa-code" aria-hidden="true" style="width: 14px;"></i>&nbsp;本文源码</a></li><li><a href="https://github.com/wangdoc/typescript-tutorial" target="_blank"><span class="icon"></span><i class="fa fa-hdd-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;代码仓库</a></li><li><a href="https://github.com/wangdoc/typescript-tutorial/issues" target="_blank"><span class="icon"></span><i class="fa fa-flag-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;反馈</a></li></ul></aside></div></nav></div></div><div class="columns"><div class="column is-8 is-6-widescreen is-offset-1-widescreen"><div id="disqus_thread"></div></div></div></div></section><footer class="footer"><div class="container"><div class="content has-text-centered"><p>联系：contact@wangdoc.com</p></div></div></footer><script>var LOPPO={current_path:"object.md",relative_root_path:"",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>\n<li><a href="#%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7">可选属性</a></li>\n<li><a href="#%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7">只读属性</a></li>\n<li><a href="#%E5%B1%9E%E6%80%A7%E5%90%8D%E7%9A%84%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B">属性名的索引类型</a></li>\n<li><a href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">解构赋值</a></li>\n<li><a href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%88%99">结构类型原则</a></li>\n<li><a href="#%E4%B8%A5%E6%A0%BC%E5%AD%97%E9%9D%A2%E9%87%8F%E6%A3%80%E6%9F%A5">严格字面量检查</a></li>\n<li><a href="#%E6%9C%80%E5%B0%8F%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7%E8%A7%84%E5%88%99">最小可选属性规则</a></li>\n<li><a href="#%E7%A9%BA%E5%AF%B9%E8%B1%A1">空对象</a></li>\n</ul>\n'}</script><script src="assets/js/app.js"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-111269443-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-111269443-1")</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?5eec262881855af3dede6a71234571f6",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)}()</script><script>var disqus_config=function(){var t=window.location,e=t.protocol+"//"+t.host+(t.port?":"+t.port:"")+t.pathname;this.page.url=e,this.page.identifier=t.pathname};!function(){var t=document,e=t.createElement("script");e.src="https://wangdoc-typescript.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><!--script src="assets/js/social-share.min.js"--><!--/script--><script>var shareDesc="我正在阅读《TypeScript 的对象类型》，出自网道（WangDoc.com）的《TypeScript 教程》。",shareOpts={url:window.location.href,source:shareDesc,title:shareDesc,description:"",image:"",sites:["weibo","wechat","qq","qzone","twitter","facebook"],origin:"WangDoc_com",disabled:[],wechatQrcodeTitle:"微信",wechatQrcodeHelper:"扫一下二维码，分享到微信。"};socialShare(".social-share",shareOpts)</script></body></html>