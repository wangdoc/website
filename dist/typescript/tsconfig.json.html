<!DOCTYPE html><html lang="zh-CN" prefix="og: http://ogp.me/ns#" data-theme="light"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>tsconfig.json - TypeScript 教程 - 网道</title><!-- link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" --><link rel="stylesheet" href="assets/css/app.min.css"><link rel="stylesheet" href="https://apps.bdimg.com/libs/fontawesome/4.4.0/css/font-awesome.css"><!-- link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css"--><!-- link rel="stylesheet" href="assets/css/share.min.css" --><meta property="og:type" content="article"><meta property="og:title" content="tsconfig.json"><link rel="apple-touch-icon" href="assets/icons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="192x192" href="assets/icons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="assets/icons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="assets/icons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="assets/icons/favicon-16x16.png"><link rel="manifest" href="assets/icons/manifest.json"></head><body><nav class="navbar is-light" role="navigation" id="navbar" aria-label="main navigation"><div class="container"><div class="navbar-brand"><a href="/" class="navbar-item title has-text-grey has-text-weight-light is-5">网道 / WangDoc.com </a><a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false"><span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span></a></div><div class="navbar-menu" id="navMenu"><div class="navbar-end"><div class="navbar-item"><form action="https://sourcegraph.com/search" target="_blank" method="get" onsubmit='this.q.value="repo:^github.com/wangdoc/typescript-tutorial$ "+this.origin.value'><p class="control has-icons-right"><input class="input" type="text" name="origin" placeholder="搜索..."> <span class="icon is-small is-right"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"><path fill="#ddd" d="M23.822 20.88l-6.353-6.354c.93-1.465 1.467-3.2 1.467-5.059.001-5.219-4.247-9.467-9.468-9.467s-9.468 4.248-9.468 9.468c0 5.221 4.247 9.469 9.468 9.469 1.768 0 3.421-.487 4.839-1.333l6.396 6.396 3.119-3.12zm-20.294-11.412c0-3.273 2.665-5.938 5.939-5.938 3.275 0 5.94 2.664 5.94 5.938 0 3.275-2.665 5.939-5.94 5.939-3.274 0-5.939-2.664-5.939-5.939z"/></svg></span></p><input type="hidden" name="q" value=""> <input type="hidden" name="patternType" value="literal"></form></div><a class="navbar-item is-hidden-desktop-only" target="_blank" href="https://github.com/wangdoc/typescript-tutorial"><span class="icon" style="color: #333;"><i class="fa fa-lg fa-github"></i></span></a></div></div></div></nav><section class="section main article"><div class="container"><div class="columns"><div class="column is-8 is-6-widescreen is-offset-1-widescreen"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="index.html"><span class="icon"><i class="fa fa-home"></i></span> &nbsp;TypeScript 教程</a></li><li class="is-active"><a class="has-text-grey" href="tsconfig.json.html">tsconfig.json 文件</a></li></ul></nav><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="comment.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> 注释指令</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="tsc.html">tsc 命令 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><article class="content"><h1 class="title">tsconfig.json</h1><div class="page-meta"><p>网道（WangDoc.com），互联网文档计划</p></div><h2 id="简介">简介 <a class="markdownIt-Anchor" href="#简介">#</a></h2><p><code>tsconfig.json</code>是 TypeScript 项目的配置文件，放在项目的根目录。反过来说，如果一个目录里面有<code>tsconfig.json</code>，TypeScript 就认为这是项目的根目录。</p><p>如果项目源码是 JavaScript，但是想用 TypeScript 处理，那么配置文件的名字是<code>jsconfig.json</code>，它跟<code>tsconfig</code>的写法是一样的。</p><p><code>tsconfig.json</code>文件主要供<code>tsc</code>编译器使用，它的命令行参数<code>--project</code>或<code>-p</code>可以指定<code>tsconfig.json</code>的位置（目录或文件皆可）。</p><pre class="hljs"><code>$ tsc -p ./dir
</code></pre><p>如果不指定配置文件的位置，<code>tsc</code>就会在当前目录下搜索<code>tsconfig.json</code>文件，如果不存在，就到上一级目录搜索，直到找到为止。</p><p><code>tsconfig.json</code>文件的格式，是一个 JSON 对象，最简单的情况可以只放置一个空对象<code>{}</code>。下面是一个示例。</p><pre class="hljs"><code><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;outDir&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./built&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;allowJs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;es5&quot;</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;./src/**/*&quot;</span><span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre><p>本章后面会详细介绍<code>tsconfig.json</code>的各个属性，这里简单说一下，上面示例的四个属性的含义。</p><ul><li>include：指定哪些文件需要编译。</li><li>allowJs：指定源目录的 JavaScript 文件是否原样拷贝到编译后的目录。</li><li>outDir：指定编译产物存放的目录。</li><li>target：指定编译产物的 JS 版本。</li></ul><p><code>tsconfig.json</code>文件可以不必手写，使用 tsc 命令的<code>--init</code>参数自动生成。</p><pre class="hljs"><code>$ tsc --init
</code></pre><p>上面命令生成的<code>tsconfig.json</code>文件，里面会有一些默认配置。</p><p>你也可以使用别人预先写好的 tsconfig.json 文件，npm 的<code>@tsconfig</code>名称空间下面有很多模块，都是写好的<code>tsconfig.json</code>样本，比如 <code>@tsconfig/recommended</code>和<code>@tsconfig/node16</code>。</p><p>这些模块需要安装，以<code>@tsconfig/deno</code>为例。</p><pre class="hljs"><code>$ npm install --save-dev @tsconfig/deno
<span class="hljs-comment"># 或者</span>
$ yarn add --dev @tsconfig/deno
</code></pre><p>安装以后，就可以在<code>tsconfig.json</code>里面引用这个模块，相当于继承它的设置，然后进行扩展。</p><pre class="hljs"><code><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;extends&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;@tsconfig/deno/tsconfig.json&quot;</span>
<span class="hljs-punctuation">}</span>
</code></pre><p><code>@tsconfig</code>空间下包含的完整 tsconfig 文件目录，可以查看 <a href="https://github.com/tsconfig/bases/tree/main/bases" target="_blank" rel="noopener">GitHub</a>。</p><p><code>tsconfig.json</code>的一级属性并不多，只有很少几个，但是<code>compilerOptions</code>属性有很多二级属性。下面先逐一介绍一级属性，然后再介绍<code>compilerOptions</code>的二级属性，按照首字母排序。</p><h2 id="exclude">exclude <a class="markdownIt-Anchor" href="#exclude">#</a></h2><p><code>exclude</code>属性是一个数组，必须与<code>include</code>属性一起使用，用来从编译列表中去除指定的文件。它也支持使用与<code>include</code>属性相同的通配符。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;include&quot;</span>: [<span class="hljs-string">&quot;**/*&quot;</span>],
  <span class="hljs-string">&quot;exclude&quot;</span>: [<span class="hljs-string">&quot;**/*.spec.ts&quot;</span>]
}
</code></pre><h2 id="extends">extends <a class="markdownIt-Anchor" href="#extends">#</a></h2><p><code>tsconfig.json</code>可以继承另一个<code>tsconfig.json</code>文件的配置。如果一个项目有多个配置，可以把共同的配置写成<code>tsconfig.base.json</code>，其他的配置文件继承该文件，这样便于维护和修改。</p><p><code>extends</code>属性用来指定所要继承的配置文件。它可以是本地文件。</p><pre class="hljs"><code><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;extends&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;../tsconfig.base.json&quot;</span>
<span class="hljs-punctuation">}</span>
</code></pre><p>如果<code>extends</code>属性指定的路径不是以<code>./</code>或<code>../</code>开头，那么编译器将在<code>node_modules</code>目录下查找指定的配置文件。</p><p><code>extends</code>属性也可以继承已发布的 npm 模块里面的 tsconfig 文件。</p><pre class="hljs"><code><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;extends&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;@tsconfig/node12/tsconfig.json&quot;</span>
<span class="hljs-punctuation">}</span>
</code></pre><p><code>extends</code>指定的<code>tsconfig.json</code>会先加载，然后加载当前的<code>tsconfig.json</code>。如果两者有重名的属性，后者会覆盖前者。</p><h2 id="files">files <a class="markdownIt-Anchor" href="#files">#</a></h2><p><code>files</code>属性指定编译的文件列表，如果其中有一个文件不存在，就会报错。</p><p>它是一个数组，排在前面的文件先编译。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;files&quot;</span>: [<span class="hljs-string">&quot;a.ts&quot;</span>, <span class="hljs-string">&quot;b.ts&quot;</span>]
}
</code></pre><p>该属性必须逐一列出文件，不支持文件匹配。如果文件较多，建议使用<code>include</code>和<code>exclude</code>属性。</p><h2 id="include">include <a class="markdownIt-Anchor" href="#include">#</a></h2><p><code>include</code>属性指定所要编译的文件列表，既支持逐一列出文件，也支持通配符。文件位置相对于当前配置文件而定。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;include&quot;</span>: [<span class="hljs-string">&quot;src/**/*&quot;</span>, <span class="hljs-string">&quot;tests/**/*&quot;</span>]
}
</code></pre><p><code>include</code>属性支持三种通配符。</p><ul><li><code>?</code>：指代单个字符</li><li><code>*</code>：指代任意字符，不含路径分隔符</li><li><code>**</code>：指定任意目录层级。</li></ul><p>如果不指定文件后缀名，默认包括<code>.ts</code>、<code>.tsx</code>和<code>.d.ts</code>文件。如果打开了<code>allowJs</code>，那么还包括<code>.js</code>和<code>.jsx</code>。</p><h2 id="references">references <a class="markdownIt-Anchor" href="#references">#</a></h2><p><code>references</code>属性是一个数组，数组成员为对象，适合一个大项目由许多小项目构成的情况，用来设置需要引用的底层项目。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;references&quot;</span>: [
    { <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;../pkg1&quot;</span> },
    { <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;../pkg2/tsconfig.json&quot;</span> }
  ]
}
</code></pre><p><code>references</code>数组成员对象的<code>path</code>属性，既可以是含有文件<code>tsconfig.json</code>的目录，也可以直接是该文件。</p><p>与此同时，引用的底层项目的<code>tsconfig.json</code>必须启用<code>composite</code>属性。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;compilerOptions&quot;</span>: {
    <span class="hljs-string">&quot;composite&quot;</span>: <span class="hljs-literal">true</span>
  }
}
</code></pre><h2 id="compileroptions">compilerOptions <a class="markdownIt-Anchor" href="#compileroptions">#</a></h2><p><code>compilerOptions</code>属性用来定制编译行为。这个属性可以省略，这时编译器将使用默认设置。</p><h3 id="allowjs">allowJs <a class="markdownIt-Anchor" href="#allowjs">#</a></h3><p><code>allowJs</code>允许 TypeScript 项目加载 JS 脚本。编译时，也会将 JS 文件，一起拷贝到输出目录。</p><pre class="hljs"><code><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;allowJs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre><h3 id="alwaysstrict">alwaysStrict <a class="markdownIt-Anchor" href="#alwaysstrict">#</a></h3><p><code>alwaysStrict</code>确保脚本以 ECMAScript 严格模式进行解析，因此脚本头部不用写<code>&quot;use strict&quot;</code>。它的值是一个布尔值，默认为<code>true</code>。</p><h3 id="allowsyntheticdefaultimports">allowSyntheticDefaultImports <a class="markdownIt-Anchor" href="#allowsyntheticdefaultimports">#</a></h3><p><code>allowSyntheticDefaultImports</code>允许<code>import</code>命令默认加载没有<code>default</code>输出的模块。</p><p>比如，打开这个设置，就可以写<code>import React from &quot;react&quot;;</code>，而不是<code>import * as React from &quot;react&quot;;</code>。</p><h3 id="allowunreachablecode">allowUnreachableCode <a class="markdownIt-Anchor" href="#allowunreachablecode">#</a></h3><p><code>allowUnreachableCode</code>设置是否允许存在不可能执行到的代码。它的值有三种可能。</p><ul><li><code>undefined</code>： 默认值，编辑器显示警告。</li><li><code>true</code>：忽略不可能执行到的代码。</li><li><code>false</code>：编译器报错。</li></ul><h3 id="allowunusedlabels">allowUnusedLabels <a class="markdownIt-Anchor" href="#allowunusedlabels">#</a></h3><p><code>allowUnusedLabels</code>设置是否允许存在没有用到的代码标签（label）。它的值有三种可能。</p><ul><li><code>undefined</code>： 默认值，编辑器显示警告。</li><li><code>true</code>：忽略没有用到的代码标签。</li><li><code>false</code>：编译器报错。</li></ul><h3 id="baseurl">baseUrl <a class="markdownIt-Anchor" href="#baseurl">#</a></h3><p><code>baseUrl</code>的值为字符串，指定 TypeScript 项目的基准目录。</p><p>由于默认是以 tsconfig.json 的位置作为基准目录，所以一般情况不需要使用该属性。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;compilerOptions&quot;</span>: {
    <span class="hljs-string">&quot;baseUrl&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>
  }
}
</code></pre><p>上面示例中，<code>baseUrl</code>为当前目录<code>./</code>。那么，当遇到下面的语句，TypeScript 将以<code>./</code>为起点，寻找<code>hello/world.ts</code>。</p><pre class="hljs"><code><span class="hljs-keyword">import</span> { helloWorld } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;hello/world&quot;</span>;
</code></pre><h3 id="checkjs">checkJs <a class="markdownIt-Anchor" href="#checkjs">#</a></h3><p><code>checkJS</code>设置对 JS 文件同样进行类型检查。打开这个属性，也会自动打开<code>allowJs</code>。它等同于在 JS 脚本的头部添加<code>// @ts-check</code>命令。</p><pre class="hljs"><code><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;checkJs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre><h3 id="composite">composite <a class="markdownIt-Anchor" href="#composite">#</a></h3><p><code>composite</code>打开某些设置，使得 TypeScript 项目可以进行增量构建，往往跟<code>incremental</code>属性配合使用。</p><h3 id="declaration">declaration <a class="markdownIt-Anchor" href="#declaration">#</a></h3><p><code>declaration</code>设置编译时是否为每个脚本生成类型声明文件<code>.d.ts</code>。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;compilerOptions&quot;</span>: {
    <span class="hljs-string">&quot;declaration&quot;</span>: <span class="hljs-literal">true</span>
  }
}
</code></pre><h3 id="declarationdir">declarationDir <a class="markdownIt-Anchor" href="#declarationdir">#</a></h3><p><code>declarationDir</code>设置生成的<code>.d.ts</code>文件所在的目录。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;compilerOptions&quot;</span>: {
    <span class="hljs-string">&quot;declaration&quot;</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">&quot;declarationDir&quot;</span>: <span class="hljs-string">&quot;./types&quot;</span>
  }
}
</code></pre><h3 id="declarationmap">declarationMap <a class="markdownIt-Anchor" href="#declarationmap">#</a></h3><p><code>declarationMap</code>设置生成<code>.d.ts</code>类型声明文件的同时，还会生成对应的 Source Map 文件。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;compilerOptions&quot;</span>: {
    <span class="hljs-string">&quot;declaration&quot;</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">&quot;declarationMap&quot;</span>: <span class="hljs-literal">true</span>
  }
}
</code></pre><h3 id="emitbom">emitBOM <a class="markdownIt-Anchor" href="#emitbom">#</a></h3><p><code>emitBOM</code>设置是否在编译结果的文件头添加字节顺序标志 BOM，默认值是<code>false</code>。</p><h3 id="emitdeclarationonly">emitDeclarationOnly <a class="markdownIt-Anchor" href="#emitdeclarationonly">#</a></h3><p><code>emitDeclarationOnly</code>设置编译后只生成<code>.d.ts</code>文件，不生成<code>.js</code>文件。</p><h3 id="esmoduleinterop">esModuleInterop <a class="markdownIt-Anchor" href="#esmoduleinterop">#</a></h3><p><code>esModuleInterop</code>修复了一些 CommonJS 和 ES6 模块之间的兼容性问题。</p><p>如果<code>module</code>属性为<code>node16</code>或<code>nodenext</code>，则<code>esModuleInterop</code>默认为<code>true</code>，其他情况默认为<code>false</code>。</p><p>打开这个属性，使用<code>import</code>命令加载 CommonJS 模块时，TypeScript 会严格检查兼容性问题是否存在。</p><pre class="hljs"><code><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> moment <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;moment&#x27;</span>
<span class="hljs-title function_">moment</span>(); <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，根据 ES6 规范，<code>import * as moment</code>里面的<code>moment</code>是一个对象，不能当作函数调用，所以第二行报错了。</p><p>解决方法就是改写上面的语句，改成加载默认接口。</p><pre class="hljs"><code><span class="hljs-keyword">import</span> moment <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;moment&#x27;</span>
<span class="hljs-title function_">moment</span>(); <span class="hljs-comment">// 不报错</span>
</code></pre><p>打开<code>esModuleInterop</code>以后，如果将上面的代码编译成 CommonJS 模块格式，就会加入一些辅助函数，保证编译后的代码行为正确。</p><p>注意，打开<code>esModuleInterop</code>，将自动打开<code>allowSyntheticDefaultImports</code>。</p><h3 id="exactoptionalpropertytypes">exactOptionalPropertyTypes <a class="markdownIt-Anchor" href="#exactoptionalpropertytypes">#</a></h3><p><code>exactOptionalPropertyTypes</code>设置可选属性不能赋值为<code>undefined</code>。</p><pre class="hljs"><code><span class="hljs-comment">// 打开 exactOptionalPropertyTypes</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyObj</span> {
  foo?: <span class="hljs-string">&#x27;A&#x27;</span> | <span class="hljs-string">&#x27;B&#x27;</span>;
}

<span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>:<span class="hljs-title class_">MyObj</span> = { <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;A&#x27;</span> };

obj.<span class="hljs-property">foo</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，<code>foo</code>是可选属性，打开<code>exactOptionalPropertyTypes</code>以后，该属性就不能显式赋值为<code>undefined</code>。</p><h3 id="forceconsistentcasinginfilenames">forceConsistentCasingInFileNames <a class="markdownIt-Anchor" href="#forceconsistentcasinginfilenames">#</a></h3><p><code>forceConsistentCasingInFileNames</code>设置文件名是否为大小写敏感，默认为<code>true</code>。</p><h3 id="incremental">incremental <a class="markdownIt-Anchor" href="#incremental">#</a></h3><p><code>incremental</code>让 TypeScript 项目构建时产生文件<code>tsbuildinfo</code>，从而完成增量构建。</p><h3 id="inlinesourcemap">inlineSourceMap <a class="markdownIt-Anchor" href="#inlinesourcemap">#</a></h3><p><code>inlineSourceMap</code>设置将 SourceMap 文件写入编译后的 JS 文件中，否则会单独生成一个<code>.js.map</code>文件。</p><h3 id="inlinesources">inlineSources <a class="markdownIt-Anchor" href="#inlinesources">#</a></h3><p><code>inlineSources</code>设置将原始的<code>.ts</code>代码嵌入编译后的 JS 中。</p><p>它要求<code>sourceMap</code>或<code>inlineSourceMap</code>至少打开一个。</p><h3 id="isolatedmodules">isolatedModules <a class="markdownIt-Anchor" href="#isolatedmodules">#</a></h3><p><code>isolatedModules</code>设置如果当前 TypeScript 脚本作为单个模块编译，是否会因为缺少其他脚本的类型信息而报错，主要便于非官方的编译工具（比如 Babel）正确编译单个脚本。</p><h3 id="jsx">jsx <a class="markdownIt-Anchor" href="#jsx">#</a></h3><p><code>jsx</code>设置如何处理<code>.tsx</code>文件。它可以取以下五个值。</p><ul><li><code>preserve</code>：保持 jsx 语法不变，输出的文件名为<code>.jsx</code>。</li><li><code>react</code>：将<code>&lt;div /&gt;</code>编译成<code>React.createElement(&quot;div&quot;)</code>，输出的文件名为<code>.js</code>。</li><li><code>react-native</code>：保持 jsx 语法不变，输出的文件后缀名为<code>.js</code>。</li><li><code>react-jsx</code>：将<code>&lt;div /&gt;</code>编译成<code>_jsx(&quot;div&quot;)</code>，输出的文件名为<code>.js</code>。</li><li><code>react-jsxdev</code>：跟<code>react-jsx</code>类似，但是为<code>_jsx()</code>加上更多的开发调试项，输出的文件名为<code>.js</code>。</li></ul><pre class="hljs"><code>{
  <span class="hljs-string">&quot;compilerOptions&quot;</span>: {
    <span class="hljs-string">&quot;jsx&quot;</span>: <span class="hljs-string">&quot;preserve&quot;</span>
  }
}
</code></pre><h3 id="lib">lib <a class="markdownIt-Anchor" href="#lib">#</a></h3><p><code>lib</code>值是一个数组，描述项目需要加载的 TypeScript 内置类型描述文件，跟三斜线指令<code>/// &lt;reference lib=&quot;&quot; /&gt;</code>作用相同。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;compilerOptions&quot;</span>: {
    <span class="hljs-string">&quot;lib&quot;</span>: [<span class="hljs-string">&quot;dom&quot;</span>, <span class="hljs-string">&quot;es2021&quot;</span>]
  }
}
</code></pre><p>TypeScript 内置的类型描述文件，主要有以下一些，完整的清单可以参考 <a href="https://github.com/microsoft/TypeScript/tree/main/src/lib" target="_blank" rel="noopener">TypeScript 源码</a>。</p><ul><li>ES5</li><li>ES2015</li><li>ES6</li><li>ES2016</li><li>ES7</li><li>ES2017</li><li>ES2018</li><li>ES2019</li><li>ES2020</li><li>ES2021</li><li>ES2022</li><li>ESNext</li><li>DOM</li><li>WebWorker</li><li>ScriptHost</li></ul><h3 id="listemittedfiles">listEmittedFiles <a class="markdownIt-Anchor" href="#listemittedfiles">#</a></h3><p><code>listEmittedFiles</code>设置编译时在终端显示，生成了哪些文件。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;compilerOptions&quot;</span>: {
    <span class="hljs-string">&quot;listEmittedFiles&quot;</span>: <span class="hljs-literal">true</span>
  }
}
</code></pre><h3 id="listfiles">listFiles <a class="markdownIt-Anchor" href="#listfiles">#</a></h3><p><code>listFiles</code>设置编译时在终端显示，参与本次编译的文件列表。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;compilerOptions&quot;</span>: {
    <span class="hljs-string">&quot;listFiles&quot;</span>: <span class="hljs-literal">true</span>
  }
}
</code></pre><h3 id="maproot">mapRoot <a class="markdownIt-Anchor" href="#maproot">#</a></h3><p><code>mapRoot</code>指定 SourceMap 文件的位置，而不是默认的生成位置。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;compilerOptions&quot;</span>: {
    <span class="hljs-string">&quot;sourceMap&quot;</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">&quot;mapRoot&quot;</span>: <span class="hljs-string">&quot;https://my-website.com/debug/sourcemaps/&quot;</span>
  }
}
</code></pre><h3 id="module">module <a class="markdownIt-Anchor" href="#module">#</a></h3><p><code>module</code>指定编译产物的模块格式。它的默认值与<code>target</code>属性有关，如果<code>target</code>是<code>ES3</code>或<code>ES5</code>，它的默认值是<code>commonjs</code>，否则就是<code>ES6/ES2015</code>。</p><pre class="hljs"><code><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;commonjs&quot;</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre><p>它可以取以下值：none、commonjs、amd、umd、system、es6/es2015、es2020、es2022、esnext、node16、nodenext。</p><h3 id="moduleresolution">moduleResolution <a class="markdownIt-Anchor" href="#moduleresolution">#</a></h3><p><code>moduleResolution</code>确定模块路径的算法，即如何查找模块。它可以取以下四种值。</p><ul><li><code>node</code>：采用 Node.js 的 CommonJS 模块算法。</li><li><code>node16</code>或<code>nodenext</code>：采用 Node.js 的 ECMAScript 模块算法，从 TypeScript 4.7 开始支持。</li><li><code>classic</code>：TypeScript 1.6 之前的算法，新项目不建议使用。</li><li><code>bundler</code>：TypeScript 5.0 新增的选项，表示当前代码会被其他打包器（比如 Webpack、Vite、esbuild、Parcel、rollup、swc）处理，从而放宽加载规则，它要求<code>module</code>设为<code>es2015</code>或更高版本，详见加入该功能的 <a href="https://github.com/microsoft/TypeScript/pull/51669" target="_blank" rel="noopener">PR 说明</a>。</li></ul><p>它的默认值与<code>module</code>属性有关，如果<code>module</code>为<code>AMD</code>、<code>UMD</code>、<code>System</code>或<code>ES6/ES2015</code>，默认值为<code>classic</code>；如果<code>module</code>为<code>node16</code>或<code>nodenext</code>，默认值为这两个值；其他情况下,默认值为<code>Node</code>。</p><h3 id="modulesuffixes">moduleSuffixes <a class="markdownIt-Anchor" href="#modulesuffixes">#</a></h3><p><code>moduleSuffixes</code>指定模块的后缀名。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;compilerOptions&quot;</span>: {
    <span class="hljs-string">&quot;moduleSuffixes&quot;</span>: [<span class="hljs-string">&quot;.ios&quot;</span>, <span class="hljs-string">&quot;.native&quot;</span>, <span class="hljs-string">&quot;&quot;</span>]
  }
}
</code></pre><p>上面的设置使得 TypeScript 对于语句<code>import * as foo from &quot;./foo&quot;;</code>，会搜索以下脚本<code>./foo.ios.ts</code>、<code>./foo.native.ts</code>和<code>./foo.ts</code>。</p><h3 id="newline">newLine <a class="markdownIt-Anchor" href="#newline">#</a></h3><p><code>newLine</code>设置换行符为<code>CRLF</code>（Windows）还是<code>LF</code>（Linux）。</p><h3 id="noemit">noEmit <a class="markdownIt-Anchor" href="#noemit">#</a></h3><p><code>noEmit</code>设置是否产生编译结果。如果不生成，TypeScript 编译就纯粹作为类型检查了。</p><h3 id="noemithelpers">noEmitHelpers <a class="markdownIt-Anchor" href="#noemithelpers">#</a></h3><p><code>noEmitHelpers</code>设置在编译结果文件不插入 TypeScript 辅助函数，而是通过外部引入辅助函数来解决，比如 NPM 模块<code>tslib</code>。</p><h3 id="noemitonerror">noEmitOnError <a class="markdownIt-Anchor" href="#noemitonerror">#</a></h3><p><code>noEmitOnError</code>指定一旦编译报错，就不生成编译产物，默认为<code>false</code>。</p><h3 id="nofallthroughcasesinswitch">noFallthroughCasesInSwitch <a class="markdownIt-Anchor" href="#nofallthroughcasesinswitch">#</a></h3><p><code>noFallthroughCasesInSwitch</code>设置是否对没有<code>break</code>语句（或者<code>return</code>和<code>throw</code>语句）的 switch 分支报错，即<code>case</code>代码里面必须有终结语句（比如<code>break</code>）。</p><h3 id="noimplicitany">noImplicitAny <a class="markdownIt-Anchor" href="#noimplicitany">#</a></h3><p><code>noImplicitAny</code>设置当一个表达式没有明确的类型描述、且编译器无法推断出具体类型时，是否允许将它推断为<code>any</code>类型。</p><p>它是一个布尔值，默认为<code>true</code>，即只要推断出<code>any</code>类型就报错。</p><h3 id="noimplicitreturns">noImplicitReturns <a class="markdownIt-Anchor" href="#noimplicitreturns">#</a></h3><p><code>noImplicitReturns</code>设置是否要求函数任何情况下都必须返回一个值，即函数必须有<code>return</code>语句。</p><h3 id="noimplicitthis">noImplicitThis <a class="markdownIt-Anchor" href="#noimplicitthis">#</a></h3><p><code>noImplicitThis</code>设置如果<code>this</code>被推断为<code>any</code>类型是否报错。</p><h3 id="nounusedlocals">noUnusedLocals <a class="markdownIt-Anchor" href="#nounusedlocals">#</a></h3><p><code>noUnusedLocals</code>设置是否允许未使用的局部变量。</p><h3 id="nounusedparameters">noUnusedParameters <a class="markdownIt-Anchor" href="#nounusedparameters">#</a></h3><p><code>noUnusedParameters</code>设置是否允许未使用的函数参数。</p><h3 id="outdir">outDir <a class="markdownIt-Anchor" href="#outdir">#</a></h3><p><code>outDir</code>指定编译产物的存放目录。如果不指定，编译出来的<code>.js</code>文件存放在对应的<code>.ts</code>文件的相同位置。</p><h3 id="outfile">outFile <a class="markdownIt-Anchor" href="#outfile">#</a></h3><p><code>outFile</code>设置将所有非模块的全局文件，编译在同一个文件里面。它只有在<code>module</code>属性为<code>None</code>、<code>System</code>、<code>AMD</code>时才生效，并且不能用来打包 CommonJS 或 ES6 模块。</p><h3 id="paths">paths <a class="markdownIt-Anchor" href="#paths">#</a></h3><p><code>paths</code>设置模块名和模块路径的映射，也就是 TypeScript 如何导入<code>require</code>或<code>imports</code>语句加载的模块。</p><p><code>paths</code>基于<code>baseUrl</code>进行加载，所以必须同时设置后者。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;compilerOptions&quot;</span>: {
    <span class="hljs-string">&quot;baseUrl&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,
    <span class="hljs-string">&quot;paths&quot;</span>: {
      <span class="hljs-string">&quot;b&quot;</span>: [<span class="hljs-string">&quot;bar/b&quot;</span>]
    }
  }
}
</code></pre><p>上面示例中，paths 设置的是执行<code>require('b')</code>时，即加载的是<code>./bar/b</code>。</p><p>它还可以使用通配符“*”，表明模块名与模块位置的对应关系。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;compilerOptions&quot;</span>: {
    <span class="hljs-string">&quot;baseUrl&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,
    <span class="hljs-string">&quot;paths&quot;</span>: {
      <span class="hljs-string">&quot;@bar/*&quot;</span>: [<span class="hljs-string">&quot;bar/*&quot;</span>]
    }
  }
}
</code></pre><h3 id="preserveconstenums">preserveConstEnums <a class="markdownIt-Anchor" href="#preserveconstenums">#</a></h3><p><code>preserveConstEnums</code>将<code>const enum</code>结构保留下来，不替换成常量值。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;compilerOptions&quot;</span>: {
    <span class="hljs-string">&quot;preserveConstEnums&quot;</span>: <span class="hljs-literal">true</span>
  }
}
</code></pre><h3 id="pretty">pretty <a class="markdownIt-Anchor" href="#pretty">#</a></h3><p><code>pretty</code>设置美化输出终端的编译信息，默认为<code>true</code>。</p><h3 id="removecomments">removeComments <a class="markdownIt-Anchor" href="#removecomments">#</a></h3><p><code>removeComments</code>移除 TypeScript 脚本里面的注释，默认为<code>false</code>。</p><h3 id="resolvejsonmodule">resolveJsonModule <a class="markdownIt-Anchor" href="#resolvejsonmodule">#</a></h3><p><code>resolveJsonModule</code>允许 import 命令导入 JSON 文件。</p><h3 id="rootdir">rootDir <a class="markdownIt-Anchor" href="#rootdir">#</a></h3><p><code>rootDir</code>设置源码脚本所在的目录，主要跟编译后的脚本结构有关。<code>rootDir</code>对应目录下的所有脚本，会成为输出目录里面的顶层脚本。</p><h3 id="rootdirs">rootDirs <a class="markdownIt-Anchor" href="#rootdirs">#</a></h3><p><code>rootDirs</code>把多个不同目录，合并成一个虚拟目录，便于模块定位。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;compilerOptions&quot;</span>: {
    <span class="hljs-string">&quot;rootDirs&quot;</span>: [<span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>]
  }
}
</code></pre><p>上面示例中，<code>rootDirs</code>将<code>bar</code>和<code>foo</code>组成一个虚拟目录。</p><h3 id="sourcemap">sourceMap <a class="markdownIt-Anchor" href="#sourcemap">#</a></h3><p><code>sourceMap</code>设置编译时是否生成 SourceMap 文件。</p><h3 id="sourceroot">sourceRoot <a class="markdownIt-Anchor" href="#sourceroot">#</a></h3><p><code>sourceRoot</code>在 SourceMap 里面设置 TypeScript 源文件的位置。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;compilerOptions&quot;</span>: {
    <span class="hljs-string">&quot;sourceMap&quot;</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">&quot;sourceRoot&quot;</span>: <span class="hljs-string">&quot;https://my-website.com/debug/source/&quot;</span>
  }
}
</code></pre><h3 id="strict">strict <a class="markdownIt-Anchor" href="#strict">#</a></h3><p><code>strict</code>用来打开 TypeScript 的严格检查。它的值是一个布尔值，默认是关闭的。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;compilerOptions&quot;</span>: {
    <span class="hljs-string">&quot;strict&quot;</span>: <span class="hljs-literal">true</span>
  }
}
</code></pre><p>这个设置相当于同时打开以下的一系列设置。</p><ul><li>alwaysStrict</li><li>strictNullChecks</li><li>strictBindCallApply</li><li>strictFunctionTypes</li><li>strictPropertyInitialization</li><li>noImplicitAny</li><li>noImplicitThis</li><li>useUnknownInCatchVariables</li></ul><p>打开<code>strict</code>的时候，允许单独关闭其中一项。</p><pre class="hljs"><code><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;strict&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;alwaysStrict&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre><h3 id="strictbindcallapply">strictBindCallApply <a class="markdownIt-Anchor" href="#strictbindcallapply">#</a></h3><p><code>strictBindCallApply</code>设置是否对函数的<code>call()</code>、<code>bind()</code>、<code>apply()</code>这三个方法进行类型检查。</p><p>如果不打开<code>strictBindCallApply</code>编译选项，编译器不会对以上三个方法进行类型检查，参数类型都是<code>any</code>，传入任何参数都不会产生编译错误。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(x);
}

<span class="hljs-comment">// strictBindCallApply:false</span>
<span class="hljs-keyword">const</span> n = fn.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-literal">false</span>);
<span class="hljs-comment">// 以上不报错</span>
</code></pre><h3 id="strictfunctiontypes">strictFunctionTypes <a class="markdownIt-Anchor" href="#strictfunctiontypes">#</a></h3><p><code>strictFunctionTypes</code>允许对函数更严格的参数检查。具体来说，如果函数 B 的参数是函数 A 参数的子类型，那么函数 B 不能替代函数 A。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"><span class="hljs-attr">x</span>:<span class="hljs-built_in">string</span></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + x.<span class="hljs-title function_">toLowerCase</span>());
}

<span class="hljs-keyword">type</span> <span class="hljs-title class_">StringOrNumberFunc</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">ns</span>:<span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;

<span class="hljs-comment">// 打开 strictFunctionTypes，下面代码会报错</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">func</span>:<span class="hljs-title class_">StringOrNumberFunc</span> = fn;
</code></pre><p>上面示例中，函数<code>fn()</code>的参数是<code>StringOrNumberFunc</code>参数的子集，因此<code>fn</code>不能替代<code>StringOrNumberFunc</code>。</p><h3 id="strictnullchecks">strictNullChecks <a class="markdownIt-Anchor" href="#strictnullchecks">#</a></h3><p>不打开<code>strictNullChecks</code>的情况下，一个变量不管类型是什么，都可以赋值为<code>undefined</code>或<code>null</code>。</p><pre class="hljs"><code><span class="hljs-comment">// 不打开 strictNullChecks 的情况</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>;

x = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 不报错</span>
x = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 不报错</span>
</code></pre><p>上面示例中，不打开<code>strictNullChecks</code>时，变量<code>x</code>的类型是<code>number</code>，但是赋值为<code>undefined</code>或<code>null</code>都不会报错。这是为了继承 JavaScript 的设定：当变量没有赋值时，它的值就为<code>undefined</code>。</p><p>一旦打开<code>strictNullChecks</code>，就使用严格类型，禁止变量赋值为<code>undefined</code>和<code>null</code>，除非变量原本就是这两种类型。它相当于从变量的值里面，排除了<code>undefined</code>和<code>null</code>。</p><pre class="hljs"><code><span class="hljs-comment">// 打开 strictNullChecks 的情况</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>;

x = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 报错</span>
x = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，打开<code>strictNullChecks</code>时，变量<code>x</code>作为<code>number</code>类型，就不能赋值为<code>undefined</code>和<code>null</code>。</p><p>下面是一个例子。</p><pre class="hljs"><code><span class="hljs-comment">// 打开 strickNullChecks 时，类型 A 为 number</span>
<span class="hljs-comment">// 不打开时，类型 A 为 string</span>
<span class="hljs-keyword">type</span> A = <span class="hljs-built_in">unknown</span> <span class="hljs-keyword">extends</span> {} ? <span class="hljs-built_in">string</span> : <span class="hljs-built_in">number</span>;
</code></pre><p>上面示例中，<code>{}</code>代表了 Object 类型，不打开<code>strictNullChecks</code>时，它包括了<code>undefined</code>和<code>null</code>，就相当于包括了所有类型的值，所以这时<code>unknown</code>类型可以赋值给<code>{}</code>类型，类型<code>A</code>就为<code>string</code>。打开<code>strictNullChecks</code>时，<code>{}</code>就排除掉了<code>undefined</code>和<code>null</code>，这时<code>unknown</code>类型就不能赋值给<code>{}</code>类型后，类型<code>A</code>就为<code>number</code>。</p><p>最后，<code>strict</code>属性包含了<code>strictNullChecks</code>，如果打开<code>strict</code>属性，就相当于打开了<code>strictNullChecks</code>。</p><h3 id="strictpropertyinitialization">strictPropertyInitialization <a class="markdownIt-Anchor" href="#strictpropertyinitialization">#</a></h3><p><code>strictPropertyInitialization</code>设置类的实例属性都必须初始化，包括以下几种情况。</p><ul><li>设为<code>undefined</code>类型</li><li>显式初始化</li><li>构造函数中赋值</li></ul><p>注意，使用该属性的同时，必须打开<code>strictNullChecks</code>。</p><pre class="hljs"><code><span class="hljs-comment">// strictPropertyInitialization：true</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-comment">// 报错，属性 username 没有初始化</span>
  <span class="hljs-attr">username</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">// 解决方法一</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  username = <span class="hljs-string">&#x27;张三&#x27;</span>;
}

<span class="hljs-comment">// 解决方法二</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">username</span>:<span class="hljs-built_in">string</span>|<span class="hljs-literal">undefined</span>;
}

<span class="hljs-comment">// 解决方法三</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">username</span>:<span class="hljs-built_in">string</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">username</span>:<span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">username</span> = username;
  }
}
<span class="hljs-comment">// 或者</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-attr">username</span>:<span class="hljs-built_in">string</span></span>) {}
}

<span class="hljs-comment">// 解决方法四：赋值断言</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  username!:<span class="hljs-built_in">string</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">username</span>:<span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initialize</span>(username);
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">initialize</span>(<span class="hljs-params"><span class="hljs-attr">username</span>:<span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">username</span> = username;
  }
}
</code></pre><h3 id="suppressexcesspropertyerrors">suppressExcessPropertyErrors <a class="markdownIt-Anchor" href="#suppressexcesspropertyerrors">#</a></h3><p><code>suppressExcessPropertyErrors</code>关闭对象字面量的多余参数的报错。</p><h3 id="target">target <a class="markdownIt-Anchor" href="#target">#</a></h3><p><code>target</code>指定编译出来的 JavaScript 代码的 ECMAScript 版本，比如<code>es2021</code>，默认是<code>es3</code>。</p><p>它可以取以下值。</p><ul><li>es3</li><li>es5</li><li>es6/es2015</li><li>es2016</li><li>es2017</li><li>es2018</li><li>es2019</li><li>es2020</li><li>es2021</li><li>es2022</li><li>esnext</li></ul><p>注意，如果编译的目标版本过老，比如<code>&quot;target&quot;: &quot;es3&quot;</code>，有些语法可能无法编译，<code>tsc</code>命令会报错。</p><h3 id="traceresolution">traceResolution <a class="markdownIt-Anchor" href="#traceresolution">#</a></h3><p><code>traceResolution</code>设置编译时，在终端输出模块解析的具体步骤。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;compilerOptions&quot;</span>: {
    <span class="hljs-string">&quot;traceResolution&quot;</span>: <span class="hljs-literal">true</span>
  }
}
</code></pre><h3 id="typeroots">typeRoots <a class="markdownIt-Anchor" href="#typeroots">#</a></h3><p><code>typeRoots</code>设置类型模块所在的目录，默认是<code>node_modules/@types</code>，该目录里面的模块会自动加入编译。一旦指定了该属性，就不会再用默认值<code>node_modules/@types</code>里面的类型模块。</p><p>该属性的值是一个数组，数组的每个成员就是一个目录，它们的路径是相对于<code>tsconfig.json</code>位置。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;compilerOptions&quot;</span>: {
    <span class="hljs-string">&quot;typeRoots&quot;</span>: [<span class="hljs-string">&quot;./typings&quot;</span>, <span class="hljs-string">&quot;./vendor/types&quot;</span>]
  }
}
</code></pre><h3 id="types">types <a class="markdownIt-Anchor" href="#types">#</a></h3><p>默认情况下，<code>typeRoots</code>目录下所有模块都会自动加入编译，如果指定了<code>types</code>属性，那么只有其中列出的模块才会自动加入编译。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;compilerOptions&quot;</span>: {
    <span class="hljs-string">&quot;types&quot;</span>: [<span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;jest&quot;</span>, <span class="hljs-string">&quot;express&quot;</span>]
  }
}
</code></pre><p>上面的设置表示，默认情况下，只有<code>./node_modules/@types/node</code>、<code>./node_modules/@types/jest</code>和<code>./node_modules/@types/express</code>会自动加入编译，其他<code>node_modules/@types/</code>目录下的模块不会加入编译。</p><p>如果<code>&quot;types&quot;: []</code>，就表示不会自动将所有<code>@types</code>模块加入编译。</p><h3 id="usedefineforclassfields">useDefineForClassFields <a class="markdownIt-Anchor" href="#usedefineforclassfields">#</a></h3><p><code>useDefineForClassFields</code>这个设置针对的是，在类（class）的顶部声明的属性。TypeScript 早先对这一类属性的处理方法，与写入 ES2022 标准的处理方法不一致。这个设置设为<code>true</code>，就用来开启 ES2022 的处理方法，设为<code>false</code>就是 TypeScript 原有的处理方法。</p><p>它的默认值跟<code>target</code>属性有关，如果编译目标是<code>ES2022</code>或更高，那么<code>useDefineForClassFields</code>默认值为<code>true</code>，否则为<code>false</code>。</p><h3 id="useunknownincatchvariables">useUnknownInCatchVariables <a class="markdownIt-Anchor" href="#useunknownincatchvariables">#</a></h3><p><code>useUnknownInCatchVariables</code>设置<code>catch</code>语句捕获的<code>try</code>抛出的返回值类型，从<code>any</code>变成<code>unknown</code>。</p><pre class="hljs"><code><span class="hljs-keyword">try</span> {
  <span class="hljs-title function_">someExternalFunction</span>();
} <span class="hljs-keyword">catch</span> (err) {
  err; <span class="hljs-comment">// 类型 any</span>
}
</code></pre><p>上面示例中，默认情况下，<code>catch</code>语句的参数<code>err</code>类型是<code>any</code>，即可以是任何值。</p><p>打开<code>useUnknownInCatchVariables</code>以后，<code>err</code>的类型抛出的错误将是<code>unknown</code>类型。这带来的变化就是使用<code>err</code>之前，必须缩小它的类型，否则会报错。</p><pre class="hljs"><code><span class="hljs-keyword">try</span> {
  <span class="hljs-title function_">someExternalFunction</span>();
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Error</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>);
  }
}
</code></pre><h2 id="参考链接">参考链接 <a class="markdownIt-Anchor" href="#参考链接">#</a></h2><ul><li><a href="https://mariusschulz.com/blog/strict-property-initialization-in-typescript" target="_blank" rel="noopener">Strict Property Initialization in TypeScript</a>, Marius Schulz</li></ul></article><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="comment.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> 注释指令</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="tsc.html">tsc 命令 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><div class="page-info"><p>本教程采用<a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh" target="_blank">知识共享 署名-相同方式共享 3.0协议</a>。</p><p>分享本文 <span class="social-share"></span></p></div></div><div class="column is-3 is-offset-1"><nav class="panel panel-menu is-light"><p class="panel-heading"><i class="fa fa-book" aria-hidden="true"></i> TypeScript 教程</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="intro.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">简介</span></a></li><li><a href="basic.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">基本用法</span></a></li><li><a href="any.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">any 类型</span></a></li><li><a href="types.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型系统</span></a></li><li><a href="array.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">数组</span></a></li><li><a href="tuple.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">元组</span></a></li><li><a href="symbol.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">symbol 类型</span></a></li><li><a href="function.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">函数</span></a></li><li><a href="object.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">对象</span></a></li><li><a href="interface.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">interface</span></a></li><li><a href="class.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类</span></a></li><li><a href="generics.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">泛型</span></a></li><li><a href="enum.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Enum 类型</span></a></li><li><a href="assert.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型断言</span></a></li><li><a href="module.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">模块</span></a></li><li><a href="namespace.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">namespace</span></a></li><li><a href="decorator.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">装饰器</span></a></li><li><a href="decorator-legacy.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">装饰器（旧语法）</span></a></li><li><a href="declare.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">declare 关键字</span></a></li><li><a href="d.ts.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">d.ts 类型声明文件</span></a></li><li><a href="operator.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型运算符</span></a></li><li><a href="mapping.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型映射</span></a></li><li><a href="utility.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型工具</span></a></li><li><a href="comment.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">注释指令</span></a></li><li><a href="tsconfig.json.html" class="is-active"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">tsconfig.json 文件</span></a></li><li><a href="tsc.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">tsc 命令</span></a></li></ul></aside></div></nav><nav class="panel panel-info is-light"><p class="panel-heading"><i class="fa fa-link" aria-hidden="true"></i> 链接</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="https://raw.githubusercontent.com/wangdoc/typescript-tutorial/main/docs/tsconfig.json.md" target="_blank"><span class="icon"></span><i class="fa fa-code" aria-hidden="true" style="width: 14px;"></i>&nbsp;本文源码</a></li><li><a href="https://github.com/wangdoc/typescript-tutorial" target="_blank"><span class="icon"></span><i class="fa fa-hdd-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;代码仓库</a></li><li><a href="https://github.com/wangdoc/typescript-tutorial/issues" target="_blank"><span class="icon"></span><i class="fa fa-flag-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;反馈</a></li></ul></aside></div></nav></div></div><div class="columns"><div class="column is-8 is-6-widescreen is-offset-1-widescreen"><div id="disqus_thread"></div></div></div></div></section><footer class="footer"><div class="container"><div class="content has-text-centered"><p>联系：contact@wangdoc.com</p></div></div></footer><script>var LOPPO={current_path:"tsconfig.json.md",relative_root_path:"",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>\n<li><a href="#exclude">exclude</a></li>\n<li><a href="#extends">extends</a></li>\n<li><a href="#files">files</a></li>\n<li><a href="#include">include</a></li>\n<li><a href="#references">references</a></li>\n<li><a href="#compileroptions">compilerOptions</a>\n<ul>\n<li><a href="#allowjs">allowJs</a></li>\n<li><a href="#alwaysstrict">alwaysStrict</a></li>\n<li><a href="#allowsyntheticdefaultimports">allowSyntheticDefaultImports</a></li>\n<li><a href="#allowunreachablecode">allowUnreachableCode</a></li>\n<li><a href="#allowunusedlabels">allowUnusedLabels</a></li>\n<li><a href="#baseurl">baseUrl</a></li>\n<li><a href="#checkjs">checkJs</a></li>\n<li><a href="#composite">composite</a></li>\n<li><a href="#declaration">declaration</a></li>\n<li><a href="#declarationdir">declarationDir</a></li>\n<li><a href="#declarationmap">declarationMap</a></li>\n<li><a href="#emitbom">emitBOM</a></li>\n<li><a href="#emitdeclarationonly">emitDeclarationOnly</a></li>\n<li><a href="#esmoduleinterop">esModuleInterop</a></li>\n<li><a href="#exactoptionalpropertytypes">exactOptionalPropertyTypes</a></li>\n<li><a href="#forceconsistentcasinginfilenames">forceConsistentCasingInFileNames</a></li>\n<li><a href="#incremental">incremental</a></li>\n<li><a href="#inlinesourcemap">inlineSourceMap</a></li>\n<li><a href="#inlinesources">inlineSources</a></li>\n<li><a href="#isolatedmodules">isolatedModules</a></li>\n<li><a href="#jsx">jsx</a></li>\n<li><a href="#lib">lib</a></li>\n<li><a href="#listemittedfiles">listEmittedFiles</a></li>\n<li><a href="#listfiles">listFiles</a></li>\n<li><a href="#maproot">mapRoot</a></li>\n<li><a href="#module">module</a></li>\n<li><a href="#moduleresolution">moduleResolution</a></li>\n<li><a href="#modulesuffixes">moduleSuffixes</a></li>\n<li><a href="#newline">newLine</a></li>\n<li><a href="#noemit">noEmit</a></li>\n<li><a href="#noemithelpers">noEmitHelpers</a></li>\n<li><a href="#noemitonerror">noEmitOnError</a></li>\n<li><a href="#nofallthroughcasesinswitch">noFallthroughCasesInSwitch</a></li>\n<li><a href="#noimplicitany">noImplicitAny</a></li>\n<li><a href="#noimplicitreturns">noImplicitReturns</a></li>\n<li><a href="#noimplicitthis">noImplicitThis</a></li>\n<li><a href="#nounusedlocals">noUnusedLocals</a></li>\n<li><a href="#nounusedparameters">noUnusedParameters</a></li>\n<li><a href="#outdir">outDir</a></li>\n<li><a href="#outfile">outFile</a></li>\n<li><a href="#paths">paths</a></li>\n<li><a href="#preserveconstenums">preserveConstEnums</a></li>\n<li><a href="#pretty">pretty</a></li>\n<li><a href="#removecomments">removeComments</a></li>\n<li><a href="#resolvejsonmodule">resolveJsonModule</a></li>\n<li><a href="#rootdir">rootDir</a></li>\n<li><a href="#rootdirs">rootDirs</a></li>\n<li><a href="#sourcemap">sourceMap</a></li>\n<li><a href="#sourceroot">sourceRoot</a></li>\n<li><a href="#strict">strict</a></li>\n<li><a href="#strictbindcallapply">strictBindCallApply</a></li>\n<li><a href="#strictfunctiontypes">strictFunctionTypes</a></li>\n<li><a href="#strictnullchecks">strictNullChecks</a></li>\n<li><a href="#strictpropertyinitialization">strictPropertyInitialization</a></li>\n<li><a href="#suppressexcesspropertyerrors">suppressExcessPropertyErrors</a></li>\n<li><a href="#target">target</a></li>\n<li><a href="#traceresolution">traceResolution</a></li>\n<li><a href="#typeroots">typeRoots</a></li>\n<li><a href="#types">types</a></li>\n<li><a href="#usedefineforclassfields">useDefineForClassFields</a></li>\n<li><a href="#useunknownincatchvariables">useUnknownInCatchVariables</a></li>\n</ul>\n</li>\n<li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li>\n</ul>\n'}</script><script src="assets/js/app.js"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-111269443-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-111269443-1")</script><script>var _hmt=_hmt||[];(()=>{var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?5eec262881855af3dede6a71234571f6",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)})()</script><script>var disqus_config=function(){var t=window.location,e=t.protocol+"//"+t.host+(t.port?":"+t.port:"")+t.pathname;this.page.url=e,this.page.identifier=t.pathname};(()=>{var t=document,e=t.createElement("script");e.src="https://wangdoc-typescript.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)})()</script><!--script src="assets/js/social-share.min.js"--><!--/script--><script>var shareDesc="我正在阅读《tsconfig.json》，出自网道（WangDoc.com）的《TypeScript 教程》。",shareOpts={url:window.location.href,source:shareDesc,title:shareDesc,description:"",image:"",sites:["weibo","wechat","qq","qzone","twitter","facebook"],origin:"WangDoc_com",disabled:[],wechatQrcodeTitle:"微信",wechatQrcodeHelper:"扫一下二维码，分享到微信。"};socialShare(".social-share",shareOpts)</script></body></html>