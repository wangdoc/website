<!DOCTYPE html><html lang="zh-CN" prefix="og: http://ogp.me/ns#" data-theme="light"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>TypeScript 的 class 类型 - TypeScript 教程 - 网道</title><!-- link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" --><link rel="stylesheet" href="assets/css/app.min.css"><link rel="stylesheet" href="https://apps.bdimg.com/libs/fontawesome/4.4.0/css/font-awesome.css"><!-- link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css"--><!-- link rel="stylesheet" href="assets/css/share.min.css" --><meta property="og:type" content="article"><meta property="og:title" content="TypeScript 的 class 类型"><link rel="apple-touch-icon" href="assets/icons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="192x192" href="assets/icons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="assets/icons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="assets/icons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="assets/icons/favicon-16x16.png"><link rel="manifest" href="assets/icons/manifest.json"></head><body><nav class="navbar is-light" role="navigation" id="navbar" aria-label="main navigation"><div class="container"><div class="navbar-brand"><a href="/" class="navbar-item title has-text-grey has-text-weight-light is-5">网道 / WangDoc.com </a><a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false"><span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span></a></div><div class="navbar-menu" id="navMenu"><div class="navbar-end"><div class="navbar-item"><form action="https://sourcegraph.com/search" target="_blank" method="get" onsubmit='this.q.value="repo:^github.com/wangdoc/typescript-tutorial$ "+this.origin.value'><p class="control has-icons-right"><input class="input" type="text" name="origin" placeholder="搜索..."> <span class="icon is-small is-right"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"><path fill="#ddd" d="M23.822 20.88l-6.353-6.354c.93-1.465 1.467-3.2 1.467-5.059.001-5.219-4.247-9.467-9.468-9.467s-9.468 4.248-9.468 9.468c0 5.221 4.247 9.469 9.468 9.469 1.768 0 3.421-.487 4.839-1.333l6.396 6.396 3.119-3.12zm-20.294-11.412c0-3.273 2.665-5.938 5.939-5.938 3.275 0 5.94 2.664 5.94 5.938 0 3.275-2.665 5.939-5.94 5.939-3.274 0-5.939-2.664-5.939-5.939z"/></svg></span></p><input type="hidden" name="q" value=""> <input type="hidden" name="patternType" value="literal"></form></div><a class="navbar-item is-hidden-desktop-only" target="_blank" href="https://github.com/wangdoc/typescript-tutorial"><span class="icon" style="color: #333;"><i class="fa fa-lg fa-github"></i></span></a></div></div></div></nav><section class="section main article"><div class="container"><div class="columns"><div class="column is-8 is-6-widescreen is-offset-1-widescreen"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="index.html"><span class="icon"><i class="fa fa-home"></i></span> &nbsp;TypeScript 教程</a></li><li class="is-active"><a class="has-text-grey" href="class.html">类</a></li></ul></nav><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="interface.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> interface</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="generics.html">泛型 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><article class="content"><h1 class="title">TypeScript 的 class 类型</h1><div class="page-meta"><p>网道（WangDoc.com），互联网文档计划</p></div><h2 id="简介">简介 <a class="markdownIt-Anchor" href="#简介">#</a></h2><p>类（class）是面向对象编程的基本构件，封装了属性和方法，TypeScript 给予了全面支持。</p><h3 id="属性的类型">属性的类型 <a class="markdownIt-Anchor" href="#属性的类型">#</a></h3><p>类的属性可以在顶层声明，也可以在构造方法内部声明。</p><p>对于顶层声明的属性，可以在声明时同时给出类型。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {
  <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>;
}
</code></pre><p>上面声明中，属性<code>x</code>和<code>y</code>的类型都是<code>number</code>。</p><p>如果不给出类型，TypeScript 会认为<code>x</code>和<code>y</code>的类型都是<code>any</code>。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {
  x;
  y;
}
</code></pre><p>上面示例中，<code>x</code>和<code>y</code>的类型都是<code>any</code>。</p><p>如果声明时给出初值，可以不写类型，TypeScript 会自行推断属性的类型。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {
  x = <span class="hljs-number">0</span>;
  y = <span class="hljs-number">0</span>;
}
</code></pre><p>上面示例中，属性<code>x</code>和<code>y</code>的类型都会被推断为 number。</p><p>TypeScript 有一个配置项<code>strictPropertyInitialization</code>，只要打开（默认是打开的），就会检查属性是否设置了初值，如果没有就报错。</p><pre class="hljs"><code><span class="hljs-comment">// 打开 strictPropertyInitialization</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 报错</span>
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 报错</span>
}
</code></pre><p>上面示例中，如果类的顶层属性不赋值，就会报错。如果不希望出现报错，可以使用非空断言。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {
  x!: <span class="hljs-built_in">number</span>;
  y!: <span class="hljs-built_in">number</span>;
}
</code></pre><p>上面示例中，属性<code>x</code>和<code>y</code>没有初值，但是属性名后面添加了感叹号，表示这两个属性肯定不会为空，所以 TypeScript 就不报错了，详见《类型断言》一章。</p><h3 id="readonly-修饰符">readonly 修饰符 <a class="markdownIt-Anchor" href="#readonly-修饰符">#</a></h3><p>属性名前面加上 readonly 修饰符，就表示该属性是只读的。实例对象不能修改这个属性。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-keyword">readonly</span> id = <span class="hljs-string">&#x27;foo&#x27;</span>;
}

<span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();
a.<span class="hljs-property">id</span> = <span class="hljs-string">&#x27;bar&#x27;</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，<code>id</code>属性前面有 readonly 修饰符，实例对象修改这个属性就会报错。</p><p>readonly 属性的初始值，可以写在顶层属性，也可以写在构造方法里面。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">id</span>:<span class="hljs-built_in">string</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = <span class="hljs-string">&#x27;bar&#x27;</span>; <span class="hljs-comment">// 正确</span>
  }
}
</code></pre><p>上面示例中，构造方法内部设置只读属性的初值，这是可以的。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">id</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;foo&#x27;</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = <span class="hljs-string">&#x27;bar&#x27;</span>; <span class="hljs-comment">// 正确</span>
  }
}
</code></pre><p>上面示例中，构造方法修改只读属性的值也是可以的。或者说，如果两个地方都设置了只读属性的值，以构造方法为准。在其他方法修改只读属性都会报错。</p><h3 id="方法的类型">方法的类型 <a class="markdownIt-Anchor" href="#方法的类型">#</a></h3><p>类的方法就是普通函数，类型声明方式与函数一致。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {
  <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;
  }

  <span class="hljs-title function_">add</span>(<span class="hljs-params"><span class="hljs-attr">point</span>:<span class="hljs-title class_">Point</span></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> + point.<span class="hljs-property">x</span>,
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> + point.<span class="hljs-property">y</span>
    );
  }
}
</code></pre><p>上面示例中，构造方法<code>constructor()</code>和普通方法<code>add()</code>都注明了参数类型，但是省略了返回值类型，因为 TypeScript 可以自己推断出来。</p><p>类的方法跟普通函数一样，可以使用参数默认值，以及函数重载。</p><p>下面是参数默认值的例子。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;
  }
}
</code></pre><p>上面示例中，如果新建实例时，不提供属性<code>x</code>和<code>y</code>的值，它们都等于默认值<code>0</code>。</p><p>下面是函数重载的例子。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>:<span class="hljs-built_in">string</span></span>);
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">s</span>:<span class="hljs-built_in">string</span></span>);
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">xs</span>:<span class="hljs-built_in">number</span>|<span class="hljs-built_in">string</span>, <span class="hljs-attr">y</span>?:<span class="hljs-built_in">string</span></span>) {
    <span class="hljs-comment">// ...</span>
  }
}
</code></pre><p>上面示例中，构造方法可以接受一个参数，也可以接受两个参数，采用函数重载进行类型声明。</p><p>另外，构造方法不能声明返回值类型，否则报错，因为它总是返回实例对象。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>):<span class="hljs-built_in">object</span> { <span class="hljs-comment">// 报错</span>
    <span class="hljs-comment">// ...</span>
  }
}
</code></pre><p>上面示例中，构造方法声明了返回值类型<code>object</code>，导致报错。</p><h3 id="存取器方法">存取器方法 <a class="markdownIt-Anchor" href="#存取器方法">#</a></h3><p>存取器（accessor）是特殊的类方法，包括取值器（getter）和存值器（setter）两种方法。</p><p>它们用于读写某个属性，取值器用来读取属性，存值器用来写入属性。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  _name = <span class="hljs-string">&#x27;&#x27;</span>;
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span>;
  }
  <span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span> = value;
  }
}
</code></pre><p>上面示例中，<code>get name()</code>是取值器，其中<code>get</code>是关键词，<code>name</code>是属性名。外部读取<code>name</code>属性时，实例对象会自动调用这个方法，该方法的返回值就是<code>name</code>属性的值。</p><p><code>set name()</code>是存值器，其中<code>set</code>是关键词，<code>name</code>是属性名。外部写入<code>name</code>属性时，实例对象会自动调用这个方法，并将所赋的值作为函数参数传入。</p><p>TypeScript 对存取器有以下规则。</p><p>（1）如果某个属性只有<code>get</code>方法，没有<code>set</code>方法，那么该属性自动成为只读属性。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  _name = <span class="hljs-string">&#x27;foo&#x27;</span>;

  <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span>;
  }
}

<span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();
c.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;bar&#x27;</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，<code>name</code>属性没有<code>set</code>方法，对该属性赋值就会报错。</p><p>（2）TypeScript 5.1 版之前，<code>set</code>方法的参数类型，必须兼容<code>get</code>方法的返回值类型，否则报错。</p><pre class="hljs"><code><span class="hljs-comment">// TypeScript 5.1 版之前</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  _name = <span class="hljs-string">&#x27;&#x27;</span>;
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>():<span class="hljs-built_in">string</span> {  <span class="hljs-comment">// 报错</span>
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span>;
  }
  <span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params"><span class="hljs-attr">value</span>:<span class="hljs-built_in">number</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span> = <span class="hljs-title class_">String</span>(value);
  }
}
</code></pre><p>上面示例中，<code>get</code>方法的返回值类型是字符串，与<code>set</code>方法的参数类型<code>number</code>不兼容，导致报错。改成下面这样，就不会报错。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  _name = <span class="hljs-string">&#x27;&#x27;</span>;
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>():<span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span>;
  }
  <span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params"><span class="hljs-attr">value</span>:<span class="hljs-built_in">number</span>|<span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span> = <span class="hljs-title class_">String</span>(value);
  }
}
</code></pre><p>上面示例中，<code>set</code>方法的参数类型（<code>number|string</code>）兼容<code>get</code>方法的返回值类型（<code>string</code>），这是允许的。</p><p>TypeScript 5.1 版做出了<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html#unrelated-types-for-getters-and-setters" target="_blank" rel="noopener">改变</a>，现在两者可以不兼容。</p><p>（3）<code>get</code>方法与<code>set</code>方法的可访问性必须一致，要么都为公开方法，要么都为私有方法。</p><h3 id="属性索引">属性索引 <a class="markdownIt-Anchor" href="#属性索引">#</a></h3><p>类允许定义属性索引。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
  [<span class="hljs-attr">s</span>:<span class="hljs-built_in">string</span>]: <span class="hljs-built_in">boolean</span> |
    (<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">s</span>:<span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span>);

  <span class="hljs-title function_">get</span>(<span class="hljs-params"><span class="hljs-attr">s</span>:<span class="hljs-built_in">string</span></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>[s] <span class="hljs-keyword">as</span> <span class="hljs-built_in">boolean</span>;
  }
}
</code></pre><p>上面示例中，<code>[s:string]</code>表示所有属性名类型为字符串的属性，它们的属性值要么是布尔值，要么是返回布尔值的函数。</p><p>注意，由于类的方法是一种特殊属性（属性值为函数的属性），所以属性索引的类型定义也涵盖了方法。如果一个对象同时定义了属性索引和方法，那么前者必须包含后者的类型。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
  [<span class="hljs-attr">s</span>:<span class="hljs-built_in">string</span>]: <span class="hljs-built_in">boolean</span>;
  <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) { <span class="hljs-comment">// 报错</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
}
</code></pre><p>上面示例中，属性索引的类型里面不包括方法，导致后面的方法<code>f()</code>定义直接报错。正确的写法是下面这样。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
  [<span class="hljs-attr">s</span>:<span class="hljs-built_in">string</span>]: <span class="hljs-built_in">boolean</span> | (<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">boolean</span>);
  <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
}
</code></pre><p>属性存取器视同属性。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
  [<span class="hljs-attr">s</span>:<span class="hljs-built_in">string</span>]: <span class="hljs-built_in">boolean</span>;

  <span class="hljs-keyword">get</span> <span class="hljs-title function_">isInstance</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
}
</code></pre><p>上面示例中，属性<code>isInstance</code>的读取器虽然是一个函数方法，但是视同属性，所以属性索引虽然没有涉及方法类型，但是不会报错。</p><h2 id="类的-interface-接口">类的 interface 接口 <a class="markdownIt-Anchor" href="#类的-interface-接口">#</a></h2><h3 id="implements-关键字">implements 关键字 <a class="markdownIt-Anchor" href="#implements-关键字">#</a></h3><p>interface 接口或 type 别名，可以用对象的形式，为 class 指定一组检查条件。然后，类使用 implements 关键字，表示当前类满足这些外部类型条件的限制。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Country</span> {
  <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span>;
  <span class="hljs-attr">capital</span>:<span class="hljs-built_in">string</span>;
}
<span class="hljs-comment">// 或者</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Country</span> = {
  <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span>;
  <span class="hljs-attr">capital</span>:<span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCountry</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Country</span> {
  name = <span class="hljs-string">&#x27;&#x27;</span>;
  capital = <span class="hljs-string">&#x27;&#x27;</span>;
}
</code></pre><p>上面示例中，<code>interface</code>或<code>type</code>都可以定义一个对象类型。类<code>MyCountry</code>使用<code>implements</code>关键字，表示该类的实例对象满足这个外部类型。</p><p>interface 只是指定检查条件，如果不满足这些条件就会报错。它并不能代替 class 自身的类型声明。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> A {
  <span class="hljs-title function_">get</span>(<span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">implements</span> A {
  <span class="hljs-title function_">get</span>(<span class="hljs-params">s</span>) { <span class="hljs-comment">// s 的类型是 any</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
}
</code></pre><p>上面示例中，类<code>B</code>实现了接口<code>A</code>，但是后者并不能代替<code>B</code>的类型声明。因此，<code>B</code>的<code>get()</code>方法的参数<code>s</code>的类型是<code>any</code>，而不是<code>string</code>。<code>B</code>类依然需要声明参数<code>s</code>的类型。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">implements</span> A {
  <span class="hljs-title function_">get</span>(<span class="hljs-params"><span class="hljs-attr">s</span>:<span class="hljs-built_in">string</span></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
}
</code></pre><p>下面是另一个例子。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> A {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>?: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">implements</span> A {
  x = <span class="hljs-number">0</span>;
}

<span class="hljs-keyword">const</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>();
b.<span class="hljs-property">y</span> = <span class="hljs-number">10</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，接口<code>A</code>有一个可选属性<code>y</code>，类<code>B</code>没有声明这个属性，所以可以通过类型检查。但是，如果给<code>B</code>的实例对象的属性<code>y</code>赋值，就会报错。所以，<code>B</code>类还是需要声明可选属性<code>y</code>。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">implements</span> A {
  x = <span class="hljs-number">0</span>;
  <span class="hljs-attr">y</span>?: <span class="hljs-built_in">number</span>;
}
</code></pre><p>同理，类可以定义接口没有声明的方法和属性。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPoint</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Point</span> {
  x = <span class="hljs-number">1</span>;
  y = <span class="hljs-number">1</span>;
  <span class="hljs-attr">z</span>:<span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>;
}
</code></pre><p>上面示例中，<code>MyPoint</code>类实现了<code>Point</code>接口，但是内部还定义了一个额外的属性<code>z</code>，这是允许的，表示除了满足接口给出的条件，类还有额外的条件。</p><p><code>implements</code>关键字后面，不仅可以是接口，也可以是另一个类。这时，后面的类将被当作接口。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> {
  <span class="hljs-attr">id</span>:<span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>;
  <span class="hljs-title function_">move</span>():<span class="hljs-built_in">void</span> {};
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Car</span> {
  id = <span class="hljs-number">2</span>; <span class="hljs-comment">// 不可省略</span>
  <span class="hljs-title function_">move</span>():<span class="hljs-built_in">void</span> {};   <span class="hljs-comment">// 不可省略</span>
}
</code></pre><p>上面示例中，<code>implements</code>后面是类<code>Car</code>，这时 TypeScript 就把<code>Car</code>视为一个接口，要求<code>MyCar</code>实现<code>Car</code>里面的每一个属性和方法，否则就会报错。所以，这时不能因为<code>Car</code>类已经实现过一次，而在<code>MyCar</code>类省略属性或方法。</p><p>注意，interface 描述的是类的对外接口，也就是实例的公开属性和公开方法，不能定义私有的属性和方法。这是因为 TypeScript 设计者认为，私有属性是类的内部实现，接口作为模板，不应该涉及类的内部代码写法。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">member</span>:{}; <span class="hljs-comment">// 报错</span>
}
</code></pre><p>上面示例中，接口<code>Foo</code>有一个私有属性，结果就报错了。</p><h3 id="实现多个接口">实现多个接口 <a class="markdownIt-Anchor" href="#实现多个接口">#</a></h3><p>类可以实现多个接口（其实是接受多重限制），每个接口之间使用逗号分隔。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MotorVehicle</span>, <span class="hljs-title class_">Flyable</span>, <span class="hljs-title class_">Swimmable</span> {
  <span class="hljs-comment">// ...</span>
}
</code></pre><p>上面示例中，<code>Car</code>类同时实现了<code>MotorVehicle</code>、<code>Flyable</code>、<code>Swimmable</code>三个接口。这意味着，它必须部署这三个接口声明的所有属性和方法，满足它们的所有条件。</p><p>但是，同时实现多个接口并不是一个好的写法，容易使得代码难以管理，可以使用两种方法替代。</p><p>第一种方法是类的继承。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MotorVehicle</span> {
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SecretCar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyable</span>, <span class="hljs-title class_">Swimmable</span> {
}
</code></pre><p>上面示例中，<code>Car</code>类实现了<code>MotorVehicle</code>，而<code>SecretCar</code>类继承了<code>Car</code>类，然后再实现<code>Flyable</code>和<code>Swimmable</code>两个接口，相当于<code>SecretCar</code>类同时实现了三个接口。</p><p>第二种方法是接口的继承。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> A {
  <span class="hljs-attr">a</span>:<span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">interface</span> B <span class="hljs-keyword">extends</span> A {
  <span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span>;
}
</code></pre><p>上面示例中，接口<code>B</code>继承了接口<code>A</code>，类只要实现接口<code>B</code>，就相当于实现<code>A</code>和<code>B</code>两个接口。</p><p>前一个例子可以用接口继承改写。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MotorVehicle</span> {
  <span class="hljs-comment">// ...</span>
}
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flyable</span> {
  <span class="hljs-comment">// ...</span>
}
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Swimmable</span> {
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">SuperCar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MotorVehicle</span>,<span class="hljs-title class_">Flyable</span>, <span class="hljs-title class_">Swimmable</span> {
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SecretCar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SuperCar</span> {
  <span class="hljs-comment">// ...</span>
}
</code></pre><p>上面示例中，类<code>SecretCar</code>通过<code>SuperCar</code>接口，就间接实现了多个接口。</p><p>注意，发生多重实现时（即一个接口同时实现多个接口），不同接口不能有互相冲突的属性。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flyable</span> {
  <span class="hljs-attr">foo</span>:<span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Swimmable</span> {
  <span class="hljs-attr">foo</span>:<span class="hljs-built_in">string</span>;
}
</code></pre><p>上面示例中，属性<code>foo</code>在两个接口里面的类型不同，如果同时实现这两个接口，就会报错。</p><h3 id="类与接口的合并">类与接口的合并 <a class="markdownIt-Anchor" href="#类与接口的合并">#</a></h3><p>TypeScript 不允许两个同名的类，但是如果一个类和一个接口同名，那么接口会被合并进类。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>;
}

<span class="hljs-keyword">interface</span> A {
  <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();
a.<span class="hljs-property">y</span> = <span class="hljs-number">10</span>;

a.<span class="hljs-property">x</span> <span class="hljs-comment">// 1</span>
a.<span class="hljs-property">y</span> <span class="hljs-comment">// 10</span>
</code></pre><p>上面示例中，类<code>A</code>与接口<code>A</code>同名，后者会被合并进前者的类型定义。</p><p>注意，合并进类的非空属性（上例的<code>y</code>），如果在赋值之前读取，会返回<code>undefined</code>。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>;
}

<span class="hljs-keyword">interface</span> A {
  <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();
a.<span class="hljs-property">y</span> <span class="hljs-comment">// undefined</span>
</code></pre><p>上面示例中，根据类型定义，<code>y</code>应该是一个非空属性。但是合并后，<code>y</code>有可能是<code>undefined</code>。</p><h2 id="class-类型">Class 类型 <a class="markdownIt-Anchor" href="#class-类型">#</a></h2><h3 id="实例类型">实例类型 <a class="markdownIt-Anchor" href="#实例类型">#</a></h3><p>TypeScript 的类本身就是一种类型，但是它代表该类的实例类型，而不是 class 的自身类型。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> {
  <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">green</span>:<span class="hljs-title class_">Color</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-string">&#x27;green&#x27;</span>);
</code></pre><p>上面示例中，定义了一个类<code>Color</code>。它的类名就代表一种类型，实例对象<code>green</code>就属于该类型。</p><p>对于引用实例对象的变量来说，既可以声明类型为 Class，也可以声明类型为 Interface，因为两者都代表实例对象的类型。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MotorVehicle</span> {
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MotorVehicle</span> {
}

<span class="hljs-comment">// 写法一</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">c1</span>:<span class="hljs-title class_">Car</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();
<span class="hljs-comment">// 写法二</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">c2</span>:<span class="hljs-title class_">MotorVehicle</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();
</code></pre><p>上面示例中，变量的类型可以写成类<code>Car</code>，也可以写成接口<code>MotorVehicle</code>。它们的区别是，如果类<code>Car</code>有接口<code>MotorVehicle</code>没有的属性和方法，那么只有变量<code>c1</code>可以调用这些属性和方法。</p><p>作为类型使用时，类名只能表示实例的类型，不能表示类的自身类型。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {
  <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;
  }
}

<span class="hljs-comment">// 错误</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createPoint</span>(<span class="hljs-params">
  <span class="hljs-title class_">PointClass</span>:<span class="hljs-title class_">Point</span>,
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>
</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PointClass</span>(x, y);
}
</code></pre><p>上面示例中，函数<code>createPoint()</code>的第一个参数<code>PointClass</code>，需要传入 Point 这个类，但是如果把参数的类型写成<code>Point</code>就会报错，因为<code>Point</code>描述的是实例类型，而不是 Class 的自身类型。</p><p>由于类名作为类型使用，实际上代表一个对象，因此可以把类看作为对象类型起名。事实上，TypeScript 有三种方法可以为对象类型起名：type、interface 和 class。</p><h3 id="类的自身类型">类的自身类型 <a class="markdownIt-Anchor" href="#类的自身类型">#</a></h3><p>要获得一个类的自身类型，一个简便的方法就是使用 typeof 运算符。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">createPoint</span>(<span class="hljs-params">
  <span class="hljs-title class_">PointClass</span>:<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Point</span>,
  <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>,
  <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>
</span>):<span class="hljs-title class_">Point</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PointClass</span>(x, y);
}
</code></pre><p>上面示例中，<code>createPoint()</code>的第一个参数<code>PointClass</code>是<code>Point</code>类自身，要声明这个参数的类型，简便的方法就是使用<code>typeof Point</code>。因为<code>Point</code>类是一个值，<code>typeof Point</code>返回这个值的类型。注意，<code>createPoint()</code>的返回值类型是<code>Point</code>，代表实例类型。</p><p>JavaScript 语言中，类只是构造函数的一种语法糖，本质上是构造函数的另一种写法。所以，类的自身类型可以写成构造函数的形式。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">createPoint</span>(<span class="hljs-params">
  <span class="hljs-title class_">PointClass</span>: <span class="hljs-keyword">new</span> (x:<span class="hljs-built_in">number</span>, y:<span class="hljs-built_in">number</span>) =&gt; <span class="hljs-title class_">Point</span>,
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>
</span>):<span class="hljs-title class_">Point</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PointClass</span>(x, y);
}
</code></pre><p>上面示例中，参数<code>PointClass</code>的类型写成了一个构造函数，这时就可以把<code>Point</code>类传入。</p><p>构造函数也可以写成对象形式，所以参数<code>PointClass</code>的类型还有另一种写法。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">createPoint</span>(<span class="hljs-params">
  <span class="hljs-title class_">PointClass</span>: {
    <span class="hljs-keyword">new</span> (x:<span class="hljs-built_in">number</span>, y:<span class="hljs-built_in">number</span>): Point
  },
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>
</span>):<span class="hljs-title class_">Point</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PointClass</span>(x, y);
}
</code></pre><p>根据上面的写法，可以把构造函数提取出来，单独定义一个接口（interface），这样可以大大提高代码的通用性。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PointConstructor</span> {
  <span class="hljs-title function_">new</span>(<span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>):<span class="hljs-title class_">Point</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">createPoint</span>(<span class="hljs-params">
  <span class="hljs-title class_">PointClass</span>: <span class="hljs-title class_">PointConstructor</span>,
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>
</span>):<span class="hljs-title class_">Point</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PointClass</span>(x, y);
}
</code></pre><p>总结一下，类的自身类型就是一个构造函数，可以单独定义一个接口来表示。</p><h3 id="结构类型原则">结构类型原则 <a class="markdownIt-Anchor" href="#结构类型原则">#</a></h3><p>Class 也遵循“结构类型原则”。一个对象只要满足 Class 的实例结构，就跟该 Class 属于同一个类型。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  id!:<span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"><span class="hljs-attr">arg</span>:<span class="hljs-title class_">Foo</span></span>) {
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-keyword">const</span> bar = {
  <span class="hljs-attr">id</span>: <span class="hljs-number">10</span>,
  <span class="hljs-attr">amount</span>: <span class="hljs-number">100</span>,
};

<span class="hljs-title function_">fn</span>(bar); <span class="hljs-comment">// 正确</span>
</code></pre><p>上面示例中，对象<code>bar</code>满足类<code>Foo</code>的实例结构，只是多了一个属性<code>amount</code>。所以，它可以当作参数，传入函数<code>fn()</code>。</p><p>如果两个类的实例结构相同，那么这两个类就是兼容的，可以用在对方的使用场合。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">cust</span>:<span class="hljs-title class_">Customer</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
</code></pre><p>上面示例中，<code>Person</code>和<code>Customer</code>是两个结构相同的类，TypeScript 将它们视为相同类型，因此<code>Person</code>可以用在类型为<code>Customer</code>的场合。</p><p>现在修改一下代码，<code>Person</code>类添加一个属性。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">cust</span>:<span class="hljs-title class_">Customer</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
</code></pre><p>上面示例中，<code>Person</code>类添加了一个属性<code>age</code>，跟<code>Customer</code>类的结构不再相同。但是这种情况下，TypeScript 依然认为，<code>Person</code>属于<code>Customer</code>类型。</p><p>这是因为根据“结构类型原则”，只要<code>Person</code>类具有<code>name</code>属性，就满足<code>Customer</code>类型的实例结构，所以可以代替它。反过来就不行，如果<code>Customer</code>类多出一个属性，就会报错。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-comment">// 报错</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">cust</span>:<span class="hljs-title class_">Customer</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
</code></pre><p>上面示例中，<code>Person</code>类比<code>Customer</code>类少一个属性<code>age</code>，它就不满足<code>Customer</code>类型的实例结构，就报错了。因为在使用<code>Customer</code>类型的情况下，可能会用到它的<code>age</code>属性，而<code>Person</code>类就没有这个属性。</p><p>总之，只要 A 类具有 B 类的结构，哪怕还有额外的属性和方法，TypeScript 也认为 A 兼容 B 的类型。</p><p>不仅是类，如果某个对象跟某个 class 的实例结构相同，TypeScript 也认为两者的类型相同。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> };
<span class="hljs-keyword">const</span> <span class="hljs-attr">p</span>:<span class="hljs-title class_">Person</span> = obj; <span class="hljs-comment">// 正确</span>
</code></pre><p>上面示例中，对象<code>obj</code>并不是<code>Person</code>的实例，但是赋值给变量<code>p</code>不会报错，TypeScript 认为<code>obj</code>也属于<code>Person</code>类型，因为它们的属性相同。</p><p>由于这种情况，运算符<code>instanceof</code>不适用于判断某个对象是否跟某个 class 属于同一类型。</p><pre class="hljs"><code>obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span> <span class="hljs-comment">// false</span>
</code></pre><p>上面示例中，运算符<code>instanceof</code>确认变量<code>obj</code>不是 Person 的实例，但是两者的类型是相同的。</p><p>空类不包含任何成员，任何其他类都可以看作与空类结构相同。因此，凡是类型为空类的地方，所有类（包括对象）都可以使用。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Empty</span> {}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"><span class="hljs-attr">x</span>:<span class="hljs-title class_">Empty</span></span>) {
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-title function_">fn</span>({});
<span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">window</span>);
<span class="hljs-title function_">fn</span>(fn);
</code></pre><p>上面示例中，函数<code>fn()</code>的参数是一个空类，这意味着任何对象都可以用作<code>fn()</code>的参数。</p><p>注意，确定两个类的兼容关系时，只检查实例成员，不考虑静态成员和构造方法。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-attr">t</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span></span>) {}
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Position</span> {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">z</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">x</span>:<span class="hljs-built_in">string</span></span>) {}
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">point</span>:<span class="hljs-title class_">Point</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Position</span>(<span class="hljs-string">&#x27;&#x27;</span>);
</code></pre><p>上面示例中，<code>Point</code>与<code>Position</code>的静态属性和构造方法都不一样，但因为<code>Point</code>的实例成员与<code>Position</code>相同，所以<code>Position</code>兼容<code>Point</code>。</p><p>如果类中存在私有成员（private）或保护成员（protected），那么确定兼容关系时，TypeScript 要求私有成员和保护成员来自同一个类，这意味着两个类需要存在继承关系。</p><pre class="hljs"><code><span class="hljs-comment">// 情况一</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-keyword">private</span> name = <span class="hljs-string">&#x27;a&#x27;</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> {
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>:A = <span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>();

<span class="hljs-comment">// 情况二</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-keyword">protected</span> name = <span class="hljs-string">&#x27;a&#x27;</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> {
  <span class="hljs-keyword">protected</span> name = <span class="hljs-string">&#x27;b&#x27;</span>;
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>:A = <span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>();
</code></pre><p>上面示例中，<code>A</code>和<code>B</code>都有私有成员（或保护成员）<code>name</code>，这时只有在<code>B</code>继承<code>A</code>的情况下（<code>class B extends A</code>），<code>B</code>才兼容<code>A</code>。</p><h2 id="类的继承">类的继承 <a class="markdownIt-Anchor" href="#类的继承">#</a></h2><p>类（这里又称“子类”）可以使用 extends 关键字继承另一个类（这里又称“基类”）的所有属性和方法。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, world!&#x27;</span>);
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> {
}

<span class="hljs-keyword">const</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>();
b.<span class="hljs-title function_">greet</span>() <span class="hljs-comment">// &quot;Hello, world!&quot;</span>
</code></pre><p>上面示例中，子类<code>B</code>继承了基类<code>A</code>，因此就拥有了<code>greet()</code>方法，不需要再次在类的内部定义这个方法了。</p><p>根据结构类型原则，子类也可以用于类型为基类的场合。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>:A = b;
a.<span class="hljs-title function_">greet</span>()
</code></pre><p>上面示例中，变量<code>a</code>的类型是基类，但是可以赋值为子类的实例。</p><p>子类可以覆盖基类的同名方法。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> {
  <span class="hljs-title function_">greet</span>(<span class="hljs-params"><span class="hljs-attr">name</span>?: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-keyword">if</span> (name === <span class="hljs-literal">undefined</span>) {
      <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">greet</span>();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">${name}</span>`</span>);
    }
  }
}
</code></pre><p>上面示例中，子类<code>B</code>定义了一个方法<code>greet()</code>，覆盖了基类<code>A</code>的同名方法。其中，参数<code>name</code>省略时，就调用基类<code>A</code>的<code>greet()</code>方法，这里可以写成<code>super.greet()</code>，使用<code>super</code>关键字指代基类是常见做法。</p><p>但是，子类的同名方法不能与基类的类型定义相冲突。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, world!&#x27;</span>);
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> {
  <span class="hljs-comment">// 报错</span>
  <span class="hljs-title function_">greet</span>(<span class="hljs-params"><span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">${name}</span>`</span>);
  }
}
</code></pre><p>上面示例中，子类<code>B</code>的<code>greet()</code>有一个<code>name</code>参数，跟基类<code>A</code>的<code>greet()</code>定义不兼容，因此就报错了。</p><p>如果基类包括保护成员（<code>protected</code>修饰符），子类可以将该成员的可访问性设置为公开（<code>public</code>修饰符），也可以保持保护成员不变，但是不能改用私有成员（<code>private</code>修饰符），详见后文。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-keyword">protected</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span>;
  <span class="hljs-keyword">protected</span> <span class="hljs-attr">y</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span>;
  <span class="hljs-keyword">protected</span> <span class="hljs-attr">z</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> {
  <span class="hljs-comment">// 正确</span>
  <span class="hljs-keyword">public</span> <span class="hljs-attr">x</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span>;

  <span class="hljs-comment">// 正确</span>
  <span class="hljs-keyword">protected</span> <span class="hljs-attr">y</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span>;

  <span class="hljs-comment">// 报错</span>
  <span class="hljs-keyword">private</span> <span class="hljs-attr">z</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span>;
}
</code></pre><p>上面示例中，子类<code>B</code>将基类<code>A</code>的受保护成员改成私有成员，就会报错。</p><p>注意，<code>extends</code>关键字后面不一定是类名，可以是一个表达式，只要它的类型是构造函数就可以了。</p><pre class="hljs"><code><span class="hljs-comment">// 例一</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; {}

<span class="hljs-comment">// 例二</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Error</span> {}

<span class="hljs-comment">// 例三</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-title function_">greeting</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello from A&#x27;</span>;
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> {
  <span class="hljs-title function_">greeting</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello from B&#x27;</span>;
  }
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Greeter</span> {
  <span class="hljs-title function_">greeting</span>(): <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">GreeterConstructor</span> {
  <span class="hljs-title function_">new</span> (): <span class="hljs-title class_">Greeter</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">getGreeterBase</span>(<span class="hljs-params"></span>):<span class="hljs-title class_">GreeterConstructor</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &gt;= <span class="hljs-number">0.5</span> ? A : B;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">getGreeterBase</span>() {
  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">greeting</span>());
  }
}
</code></pre><p>上面示例中，例一和例二的<code>extends</code>关键字后面都是构造函数，例三的<code>extends</code>关键字后面是一个表达式，执行后得到的也是一个构造函数。</p><h2 id="override-关键字">override 关键字 <a class="markdownIt-Anchor" href="#override-关键字">#</a></h2><p>子类继承父类时，可以覆盖父类的同名方法。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// ...</span>
  }
  <span class="hljs-title function_">hide</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// ...</span>
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> {
  <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// ...</span>
  }
  <span class="hljs-title function_">hide</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// ...</span>
  }
}
</code></pre><p>上面示例中，B 类定义了自己的<code>show()</code>方法和<code>hide()</code>方法，覆盖了 A 类的同名方法。</p><p>但是有些时候，我们继承他人的类，可能会在不知不觉中，就覆盖了他人的方法。为了防止这种情况，TypeScript 4.3 引入了 <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html#override-and-the---noimplicitoverride-flag" target="_blank" rel="noopener">override 关键字</a>。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> {
  <span class="hljs-keyword">override</span> <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// ...</span>
  }
  <span class="hljs-keyword">override</span> <span class="hljs-title function_">hide</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// ...</span>
  }
}
</code></pre><p>上面示例中，B 类的<code>show()</code>方法和<code>hide()</code>方法前面加了 override 关键字，明确表明作者的意图，就是要覆盖 A 类里面的这两个同名方法。这时，如果 A 类没有定义自己的<code>show()</code>方法和<code>hide()</code>方法，就会报错。</p><p>但是，这依然没有解决，子类无意中覆盖父类同名方法的问题。因此，TypeScript 又提供了一个编译参数<code>noImplicitOverride</code>。一旦打开这个参数，子类覆盖父类的同名方法就会报错，除非使用了 override 关键字。</p><h2 id="可访问性修饰符">可访问性修饰符 <a class="markdownIt-Anchor" href="#可访问性修饰符">#</a></h2><p>类的内部成员的外部可访问性，由三个可访问性修饰符（access modifiers）控制：<code>public</code>、<code>private</code>和<code>protected</code>。</p><p>这三个修饰符的位置，都写在属性或方法的最前面。</p><h3 id="public">public <a class="markdownIt-Anchor" href="#public">#</a></h3><p><code>public</code>修饰符表示这是公开成员，外部可以自由访问。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greeter</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hi!&quot;</span>);
  }
}

<span class="hljs-keyword">const</span> g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Greeter</span>();
g.<span class="hljs-title function_">greet</span>();
</code></pre><p>上面示例中，<code>greet()</code>方法前面的<code>public</code>修饰符，表示该方法可以在类的外部调用，即外部实例可以调用。</p><p><code>public</code>修饰符是默认修饰符，如果省略不写，实际上就带有该修饰符。因此，类的属性和方法默认都是外部可访问的。</p><p>正常情况下，除非为了醒目和代码可读性，<code>public</code>都是省略不写的。</p><h3 id="private">private <a class="markdownIt-Anchor" href="#private">#</a></h3><p><code>private</code>修饰符表示私有成员，只能用在当前类的内部，类的实例和子类都不能使用该成员。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;
}

<span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();
a.<span class="hljs-property">x</span> <span class="hljs-comment">// 报错</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> {
  <span class="hljs-title function_">showX</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>); <span class="hljs-comment">// 报错</span>
  }
}
</code></pre><p>上面示例中，属性<code>x</code>前面有<code>private</code>修饰符，表示这是私有成员。因此，实例对象和子类使用该成员，都会报错。</p><p>注意，子类不能定义父类私有成员的同名成员。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-keyword">private</span> x = <span class="hljs-number">0</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> {
  x = <span class="hljs-number">1</span>; <span class="hljs-comment">// 报错</span>
}
</code></pre><p>上面示例中，<code>A</code>类有一个私有属性<code>x</code>，子类<code>B</code>就不能定义自己的属性<code>x</code>了。</p><p>如果在类的内部，当前类的实例可以获取私有成员。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-keyword">private</span> x = <span class="hljs-number">10</span>;

  <span class="hljs-title function_">f</span>(<span class="hljs-params"><span class="hljs-attr">obj</span>:A</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">x</span>);
  }
}

<span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();
a.<span class="hljs-title function_">f</span>(a) <span class="hljs-comment">// 10</span>
</code></pre><p>上面示例中，在类<code>A</code>内部，<code>A</code>的实例对象可以获取私有成员<code>x</code>。</p><p>严格地说，<code>private</code>定义的私有成员，并不是真正意义的私有成员。一方面，编译成 JavaScript 后，<code>private</code>关键字就被剥离了，这时外部访问该成员就不会报错。另一方面，由于前一个原因，TypeScript 对于访问<code>private</code>成员没有严格禁止，使用方括号写法（<code>[]</code>）或者<code>in</code>运算符，实例对象就能访问该成员。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-keyword">private</span> x = <span class="hljs-number">1</span>;
}

<span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();
a[<span class="hljs-string">&#x27;x&#x27;</span>] <span class="hljs-comment">// 1</span>

<span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;x&#x27;</span> <span class="hljs-keyword">in</span> a) { <span class="hljs-comment">// 正确</span>
  <span class="hljs-comment">// ...</span>
}
</code></pre><p>上面示例中，<code>A</code>类的属性<code>x</code>是私有属性，但是实例使用方括号，就可以读取这个属性，或者使用<code>in</code>运算符检查这个属性是否存在，都可以正确执行。</p><p>由于<code>private</code>存在这些问题，加上它是 ES2022 标准发布前出台的，而 ES2022 引入了自己的私有成员写法<code>#propName</code>。因此建议不使用<code>private</code>，改用 ES2022 的写法，获得真正意义的私有成员。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  #x = <span class="hljs-number">1</span>;
}

<span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();
a[<span class="hljs-string">&#x27;x&#x27;</span>] <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，采用了 ES2022 的私有成员写法（属性名前加<code>#</code>），TypeScript 就正确识别了实例对象没有属性<code>x</code>，从而报错。</p><p>构造方法也可以是私有的，这就直接防止了使用<code>new</code>命令生成实例对象，只能在类的内部创建实例对象。</p><p>这时一般会有一个静态方法，充当工厂函数，强制所有实例都通过该方法生成。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-attr">instance</span>?: <span class="hljs-title class_">Singleton</span>;

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {}

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getInstance</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Singleton</span>.<span class="hljs-property">instance</span>) {
      <span class="hljs-title class_">Singleton</span>.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();
    }
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Singleton</span>.<span class="hljs-property">instance</span>;
  }
}

<span class="hljs-keyword">const</span> s = <span class="hljs-title class_">Singleton</span>.<span class="hljs-title function_">getInstance</span>();
</code></pre><p>上面示例使用私有构造方法，实现了单例模式。想要获得 Singleton 的实例，不能使用<code>new</code>命令，只能使用<code>getInstance()</code>方法。</p><h3 id="protected">protected <a class="markdownIt-Anchor" href="#protected">#</a></h3><p><code>protected</code>修饰符表示该成员是保护成员，只能在类的内部使用该成员，实例无法使用该成员，但是子类内部可以使用。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-keyword">protected</span> x = <span class="hljs-number">1</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> {
  <span class="hljs-title function_">getX</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>;
  }
}

<span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();
<span class="hljs-keyword">const</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>();

a.<span class="hljs-property">x</span> <span class="hljs-comment">// 报错</span>
b.<span class="hljs-title function_">getX</span>() <span class="hljs-comment">// 1</span>
</code></pre><p>上面示例中，类<code>A</code>的属性<code>x</code>是保护成员，直接从实例读取该属性（<code>a.x</code>）会报错，但是子类<code>B</code>内部可以读取该属性。</p><p>子类不仅可以拿到父类的保护成员，还可以定义同名成员。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-keyword">protected</span> x = <span class="hljs-number">1</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> {
  x = <span class="hljs-number">2</span>;
}
</code></pre><p>上面示例中，子类<code>B</code>定义了父类<code>A</code>的同名成员<code>x</code>，并且父类的<code>x</code>是保护成员，子类将其改成了公开成员。<code>B</code>类的<code>x</code>属性前面没有修饰符，等同于修饰符是<code>public</code>，外界可以读取这个属性。</p><p>在类的外部，实例对象不能读取保护成员，但是在类的内部可以。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-keyword">protected</span> x = <span class="hljs-number">1</span>;

  <span class="hljs-title function_">f</span>(<span class="hljs-params"><span class="hljs-attr">obj</span>:A</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">x</span>);
  }
}

<span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();

a.<span class="hljs-property">x</span> <span class="hljs-comment">// 报错</span>
a.<span class="hljs-title function_">f</span>(a) <span class="hljs-comment">// 1</span>
</code></pre><p>上面示例中，属性<code>x</code>是类<code>A</code>的保护成员，在类的外部，实例对象<code>a</code>拿不到这个属性。但是，实例对象<code>a</code>传入类<code>A</code>的内部，就可以从<code>a</code>拿到<code>x</code>。</p><h3 id="实例属性的简写形式">实例属性的简写形式 <a class="markdownIt-Anchor" href="#实例属性的简写形式">#</a></h3><p>实际开发中，很多实例属性的值，是通过构造方法传入的。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {
  <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;
  }
}
</code></pre><p>上面实例中，属性<code>x</code>和<code>y</code>的值是通过构造方法的参数传入的。</p><p>这样的写法等于对同一个属性要声明两次类型，一次在类的头部，另一次在构造方法的参数里面。这有些累赘，TypeScript 就提供了一种简写形式。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">
    <span class="hljs-keyword">public</span> <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>,
    <span class="hljs-keyword">public</span> <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>
  </span>) {}
}

<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);
p.<span class="hljs-property">x</span> <span class="hljs-comment">// 10</span>
p.<span class="hljs-property">y</span> <span class="hljs-comment">// 10</span>
</code></pre><p>上面示例中，构造方法的参数<code>x</code>前面有<code>public</code>修饰符，这时 TypeScript 就会自动声明一个公开属性<code>x</code>，不必在构造方法里面写任何代码，同时还会设置<code>x</code>的值为构造方法的参数值。注意，这里的<code>public</code>不能省略。</p><p>除了<code>public</code>修饰符，构造方法的参数名只要有<code>private</code>、<code>protected</code>、<code>readonly</code>修饰符，都会自动声明对应修饰符的实例属性。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">
    <span class="hljs-keyword">public</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>,
    <span class="hljs-keyword">protected</span> <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>,
    <span class="hljs-keyword">private</span> <span class="hljs-attr">c</span>: <span class="hljs-built_in">number</span>,
    <span class="hljs-keyword">readonly</span> <span class="hljs-attr">d</span>: <span class="hljs-built_in">number</span>
  </span>) {}
}

<span class="hljs-comment">// 编译结果</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
    a;
    b;
    c;
    d;
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">a, b, c, d</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = a;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span> = b;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">c</span> = c;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">d</span> = d;
    }
}
</code></pre><p>上面示例中，从编译结果可以看到，构造方法的<code>a</code>、<code>b</code>、<code>c</code>、<code>d</code>会生成对应的实例属性。</p><p><code>readonly</code>还可以与其他三个可访问性修饰符，一起使用。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>,
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>,
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">z</span>:<span class="hljs-built_in">number</span>
  </span>) {}
}
</code></pre><h2 id="顶层属性的处理方法">顶层属性的处理方法 <a class="markdownIt-Anchor" href="#顶层属性的处理方法">#</a></h2><p>对于类的顶层属性，TypeScript 早期的处理方法，与后来的 ES2022 标准不一致。这会导致某些代码的运行结果不一样。</p><p>类的顶层属性在 TypeScript 里面，有两种写法。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-comment">// 写法一</span>
  age = <span class="hljs-number">25</span>;

  <span class="hljs-comment">// 写法二</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-attr">currentYear</span>: <span class="hljs-built_in">number</span></span>) {}
}
</code></pre><p>上面示例中，写法一是直接声明一个实例属性<code>age</code>，并初始化；写法二是顶层属性的简写形式，直接将构造方法的参数<code>currentYear</code>声明为实例属性。</p><p>TypeScript 早期的处理方法是，先在顶层声明属性，但不进行初始化，等到运行构造方法时，再完成所有初始化。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  age = <span class="hljs-number">25</span>;
}

<span class="hljs-comment">// TypeScript 的早期处理方法</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">25</span>;
  }
}
</code></pre><p>上面示例中，TypeScript 早期会先声明顶层属性<code>age</code>，然后等到运行构造函数时，再将其初始化为<code>25</code>。</p><p>ES2022 标准里面的处理方法是，先进行顶层属性的初始化，再运行构造方法。这在某些情况下，会使得同一段代码在 TypeScript 和 JavaScript 下运行结果不一致。</p><p>这种不一致一般发生在两种情况。第一种情况是，顶层属性的初始化依赖于其他实例属性。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  age = <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentYear</span> - <span class="hljs-number">1998</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-attr">currentYear</span>: <span class="hljs-built_in">number</span></span>) {
    <span class="hljs-comment">// 输出结果将不一致</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Current age:&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);
  }
}

<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">2023</span>);
</code></pre><p>上面示例中，顶层属性<code>age</code>的初始化值依赖于实例属性<code>this.currentYear</code>。按照 TypeScript 的处理方法，初始化是在构造方法里面完成的，会输出结果为<code>25</code>。但是，按照 ES2022 标准的处理方法，初始化在声明顶层属性时就会完成，这时<code>this.currentYear</code>还等于<code>undefined</code>，所以<code>age</code>的初始化结果为<code>NaN</code>，因此最后输出的也是<code>NaN</code>。</p><p>第二种情况与类的继承有关，子类声明的顶层属性在父类完成初始化。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-attr">animalStuff</span>: <span class="hljs-built_in">any</span>;
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-attr">dogStuff</span>: <span class="hljs-built_in">any</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimalHouse</span> {
  <span class="hljs-attr">resident</span>: <span class="hljs-title class_">Animal</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">animal</span>:<span class="hljs-title class_">Animal</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">resident</span> = animal;
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">DogHouse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">AnimalHouse</span> {
  <span class="hljs-attr">resident</span>: <span class="hljs-title class_">Dog</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">dog</span>:<span class="hljs-title class_">Dog</span></span>) {
    <span class="hljs-variable language_">super</span>(dog);
  }
}
</code></pre><p>上面示例中，类<code>DogHouse</code>继承自<code>AnimalHouse</code>。它声明了顶层属性<code>resident</code>，但是该属性的初始化是在父类<code>AnimalHouse</code>完成的。不同的设置运行下面的代码，结果将不一致。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> dog = {
  <span class="hljs-attr">animalStuff</span>: <span class="hljs-string">&#x27;animal&#x27;</span>,
  <span class="hljs-attr">dogStuff</span>: <span class="hljs-string">&#x27;dog&#x27;</span>
};

<span class="hljs-keyword">const</span> dogHouse = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DogHouse</span>(dog);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dogHouse.<span class="hljs-property">resident</span>) <span class="hljs-comment">// 输出结果将不一致</span>
</code></pre><p>上面示例中，TypeScript 的处理方法，会使得<code>resident</code>属性能够初始化，所以输出参数对象的值。但是，ES2022 标准的处理方法是，顶层属性的初始化先于构造方法的运行。这使得<code>resident</code>属性不会得到赋值，因此输出为<code>undefined</code>。</p><p>为了解决这个问题，同时保证以前代码的行为一致，TypeScript 从3.7版开始，引入了编译设置<code>useDefineForClassFields</code>。这个设置设为<code>true</code>，则采用 ES2022 标准的处理方法，否则采用 TypeScript 早期的处理方法。</p><p>它的默认值与<code>target</code>属性有关，如果输出目标设为<code>ES2022</code>或者更高，那么<code>useDefineForClassFields</code>的默认值为<code>true</code>，否则为<code>false</code>。关于这个设置的详细说明，参见官方 3.7 版本的<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#the-usedefineforclassfields-flag-and-the-declare-property-modifier" target="_blank" rel="noopener">发布说明</a>。</p><p>如果希望避免这种不一致，让代码在不同设置下的行为都一样，那么可以将所有顶层属性的初始化，都放到构造方法里面。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>  {
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-attr">currentYear</span>: <span class="hljs-built_in">number</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentYear</span> - <span class="hljs-number">1998</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Current age:&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);
  }
}

<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">2023</span>);
</code></pre><p>上面示例中，顶层属性<code>age</code>的初始化就放在构造方法里面，那么任何情况下，代码行为都是一致的。</p><p>对于类的继承，还有另一种解决方法，就是使用<code>declare</code>命令，去声明子类顶层属性的类型，告诉 TypeScript 这些属性的初始化由父类实现。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">DogHouse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">AnimalHouse</span> {
  <span class="hljs-keyword">declare</span> <span class="hljs-attr">resident</span>: <span class="hljs-title class_">Dog</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">dog</span>:<span class="hljs-title class_">Dog</span></span>) {
    <span class="hljs-variable language_">super</span>(dog);
  }
}
</code></pre><p>上面示例中，<code>resident</code>属性的类型声明前面用了<code>declare</code>命令。这种情况下，这一行代码在编译成 JavaScript 后就不存在，那么也就不会有行为不一致，无论是否设置<code>useDefineForClassFields</code>，输出结果都是一样的。</p><h2 id="静态成员">静态成员 <a class="markdownIt-Anchor" href="#静态成员">#</a></h2><p>类的内部可以使用<code>static</code>关键字，定义静态成员。</p><p>静态成员是只能通过类本身使用的成员，不能通过实例对象使用。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
  <span class="hljs-keyword">static</span> x = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">printX</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">MyClass</span>.<span class="hljs-property">x</span>);
  }
}

<span class="hljs-title class_">MyClass</span>.<span class="hljs-property">x</span> <span class="hljs-comment">// 0</span>
<span class="hljs-title class_">MyClass</span>.<span class="hljs-title function_">printX</span>() <span class="hljs-comment">// 0</span>
</code></pre><p>上面示例中，<code>x</code>是静态属性，<code>printX()</code>是静态方法。它们都必须通过<code>MyClass</code>获取，而不能通过实例对象调用。</p><p><code>static</code>关键字前面可以使用 public、private、protected 修饰符。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> x = <span class="hljs-number">0</span>;
}

<span class="hljs-title class_">MyClass</span>.<span class="hljs-property">x</span> <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，静态属性<code>x</code>前面有<code>private</code>修饰符，表示只能在<code>MyClass</code>内部使用，如果在外部调用这个属性就会报错。</p><p>静态私有属性也可以用 ES6 语法的<code>#</code>前缀表示，上面示例可以改写如下。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
  <span class="hljs-keyword">static</span> #x = <span class="hljs-number">0</span>;
}
</code></pre><p><code>public</code>和<code>protected</code>的静态成员可以被继承。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> x = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> y = <span class="hljs-number">1</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getY</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> B.<span class="hljs-property">y</span>;
  }
}

B.<span class="hljs-property">x</span> <span class="hljs-comment">// 1</span>
B.<span class="hljs-title function_">getY</span>() <span class="hljs-comment">// 1</span>
</code></pre><p>上面示例中，类<code>A</code>的静态属性<code>x</code>和<code>y</code>都被<code>B</code>继承，公开成员<code>x</code>可以在<code>B</code>的外部获取，保护成员<code>y</code>只能在<code>B</code>的内部获取。</p><h2 id="泛型类">泛型类 <a class="markdownIt-Anchor" href="#泛型类">#</a></h2><p>类也可以写成泛型，使用类型参数。关于泛型的详细介绍，请看《泛型》一章。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>&lt;<span class="hljs-title class_">Type</span>&gt; {
  <span class="hljs-attr">contents</span>: <span class="hljs-title class_">Type</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">value</span>:<span class="hljs-title class_">Type</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">contents</span> = value;
  }
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">b</span>:<span class="hljs-title class_">Box</span>&lt;<span class="hljs-built_in">string</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>(<span class="hljs-string">&#x27;hello!&#x27;</span>);
</code></pre><p>上面示例中，类<code>Box</code>有类型参数<code>Type</code>，因此属于泛型类。新建实例时，变量的类型声明需要带有类型参数的值，不过本例等号左边的<code>Box&lt;string&gt;</code>可以省略不写，因为可以从等号右边推断得到。</p><p>注意，静态成员不能使用泛型的类型参数。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>&lt;<span class="hljs-title class_">Type</span>&gt; {
  <span class="hljs-keyword">static</span> <span class="hljs-attr">defaultContents</span>: <span class="hljs-title class_">Type</span>; <span class="hljs-comment">// 报错</span>
}
</code></pre><p>上面示例中，静态属性<code>defaultContents</code>的类型写成类型参数<code>Type</code>会报错。因为这意味着调用时必须给出类型参数（即写成<code>Box&lt;string&gt;.defaultContents</code>），并且类型参数发生变化，这个属性也会跟着变，这并不是好的做法。</p><h2 id="抽象类抽象成员">抽象类，抽象成员 <a class="markdownIt-Anchor" href="#抽象类抽象成员">#</a></h2><p>TypeScript 允许在类的定义前面，加上关键字<code>abstract</code>，表示该类不能被实例化，只能当作其他类的模板。这种类就叫做“抽象类”（abstract class）。</p><pre class="hljs"><code><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  id = <span class="hljs-number">1</span>;
}

<span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>(); <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，直接新建抽象类的实例，会报错。</p><p>抽象类只能当作基类使用，用来在它的基础上定义子类。</p><pre class="hljs"><code><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  id = <span class="hljs-number">1</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> {
  amount = <span class="hljs-number">100</span>;
}

<span class="hljs-keyword">const</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>();

b.<span class="hljs-property">id</span> <span class="hljs-comment">// 1</span>
b.<span class="hljs-property">amount</span> <span class="hljs-comment">// 100</span>
</code></pre><p>上面示例中，<code>A</code>是一个抽象类，<code>B</code>是<code>A</code>的子类，继承了<code>A</code>的所有成员，并且可以定义自己的成员和实例化。</p><p>抽象类的子类也可以是抽象类，也就是说，抽象类可以继承其他抽象类。</p><pre class="hljs"><code><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-attr">foo</span>:<span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> {
  <span class="hljs-attr">bar</span>:<span class="hljs-built_in">string</span>;
}
</code></pre><p>抽象类的内部可以有已经实现好的属性和方法，也可以有还未实现的属性和方法。后者就叫做“抽象成员”（abstract member），即属性名和方法名有<code>abstract</code>关键字，表示该方法需要子类实现。如果子类没有实现抽象成员，就会报错。</p><pre class="hljs"><code><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-keyword">abstract</span> <span class="hljs-attr">foo</span>:<span class="hljs-built_in">string</span>;
  <span class="hljs-attr">bar</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> {
  foo = <span class="hljs-string">&#x27;b&#x27;</span>;
}
</code></pre><p>上面示例中，抽象类<code>A</code>定义了抽象属性<code>foo</code>，子类<code>B</code>必须实现这个属性，否则会报错。</p><p>下面是抽象方法的例子。如果抽象类的方法前面加上<code>abstract</code>，就表明子类必须给出该方法的实现。</p><pre class="hljs"><code><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">execute</span>():<span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> {
  <span class="hljs-title function_">execute</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`B executed`</span>;
  }
}
</code></pre><p>这里有几个注意点。</p><p>（1）抽象成员只能存在于抽象类，不能存在于普通类。</p><p>（2）抽象成员不能有具体实现的代码。也就是说，已经实现好的成员前面不能加<code>abstract</code>关键字。</p><p>（3）抽象成员前也不能有<code>private</code>修饰符，否则无法在子类中实现该成员。</p><p>（4）一个子类最多只能继承一个抽象类。</p><p>总之，抽象类的作用是，确保各种相关的子类都拥有跟基类相同的接口，可以看作是模板。其中的抽象成员都是必须由子类实现的成员，非抽象成员则表示基类已经实现的、由所有子类共享的成员。</p><h2 id="this-问题">this 问题 <a class="markdownIt-Anchor" href="#this-问题">#</a></h2><p>类的方法经常用到<code>this</code>关键字，它表示该方法当前所在的对象。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  name = <span class="hljs-string">&#x27;A&#x27;</span>;

  <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;
  }
}

<span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();
a.<span class="hljs-title function_">getName</span>() <span class="hljs-comment">// &#x27;A&#x27;</span>

<span class="hljs-keyword">const</span> b = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;b&#x27;</span>,
  <span class="hljs-attr">getName</span>: a.<span class="hljs-property">getName</span>
};
b.<span class="hljs-title function_">getName</span>() <span class="hljs-comment">// &#x27;b&#x27;</span>
</code></pre><p>上面示例中，变量<code>a</code>和<code>b</code>的<code>getName()</code>是同一个方法，但是执行结果不一样，原因就是它们内部的<code>this</code>指向不一样的对象。如果<code>getName()</code>在变量<code>a</code>上运行，<code>this</code>指向<code>a</code>；如果在<code>b</code>上运行，<code>this</code>指向<code>b</code>。</p><p>有些场合需要给出<code>this</code>类型，但是 JavaScript 函数通常不带有<code>this</code>参数，这时 TypeScript 允许函数增加一个名为<code>this</code>的参数，放在参数列表的第一位，用来描述函数内部的<code>this</code>关键字的类型。</p><pre class="hljs"><code><span class="hljs-comment">// 编译前</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">
  <span class="hljs-attr">this</span>: <span class="hljs-title class_">SomeType</span>,
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>
</span>) {
  <span class="hljs-comment">/* ... */</span>
}

<span class="hljs-comment">// 编译后</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-comment">/* ... */</span>
}
</code></pre><p>上面示例中，函数<code>fn()</code>的第一个参数是<code>this</code>，用来声明函数内部的<code>this</code>的类型。编译时，TypeScript 一旦发现函数的第一个参数名为<code>this</code>，则会去除这个参数，即编译结果不会带有该参数。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  name = <span class="hljs-string">&#x27;A&#x27;</span>;

  <span class="hljs-title function_">getName</span>(<span class="hljs-params"><span class="hljs-attr">this</span>: A</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;
  }
}

<span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>();
<span class="hljs-keyword">const</span> b = a.<span class="hljs-property">getName</span>;

<span class="hljs-title function_">b</span>() <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，类<code>A</code>的<code>getName()</code>添加了<code>this</code>参数，如果直接调用这个方法，<code>this</code>的类型就会跟声明的类型不一致，从而报错。</p><p><code>this</code>参数的类型可以声明为各种对象。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">
  <span class="hljs-attr">this</span>: { name: <span class="hljs-built_in">string</span> }
</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Jack&#x27;</span>;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// 报错</span>
}

foo.<span class="hljs-title function_">call</span>({ <span class="hljs-attr">name</span>: <span class="hljs-number">123</span> }); <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，参数<code>this</code>的类型是一个带有<code>name</code>属性的对象，不符合这个条件的<code>this</code>都会报错。</p><p>TypeScript 提供了一个<code>noImplicitThis</code>编译选项。如果打开了这个设置项，如果<code>this</code>的值推断为<code>any</code>类型，就会报错。</p><pre class="hljs"><code><span class="hljs-comment">// noImplicitThis 打开</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">
    <span class="hljs-keyword">public</span> <span class="hljs-attr">width</span>:<span class="hljs-built_in">number</span>,
    <span class="hljs-keyword">public</span> <span class="hljs-attr">height</span>:<span class="hljs-built_in">number</span>
  </span>) {}

  <span class="hljs-title function_">getAreaFunction</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span>; <span class="hljs-comment">// 报错</span>
    };
  }
}
</code></pre><p>上面示例中，<code>getAreaFunction()</code>方法返回一个函数，这个函数里面用到了<code>this</code>，但是这个<code>this</code>跟<code>Rectangle</code>这个类没关系，它的类型推断为<code>any</code>，所以就报错了。</p><p>在类的内部，<code>this</code>本身也可以当作类型使用，表示当前类的实例对象。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span> {
  <span class="hljs-attr">contents</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span>;

  <span class="hljs-title function_">set</span>(<span class="hljs-attr">value</span>:<span class="hljs-built_in">string</span>):<span class="hljs-variable language_">this</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">contents</span> = value;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
  }
}
</code></pre><p>上面示例中，<code>set()</code>方法的返回值类型就是<code>this</code>，表示当前的实例对象。</p><p>注意，<code>this</code>类型不允许应用于静态成员。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-attr">a</span>:<span class="hljs-variable language_">this</span>; <span class="hljs-comment">// 报错</span>
}
</code></pre><p>上面示例中，静态属性<code>a</code>的返回值类型是<code>this</code>，就报错了。原因是<code>this</code>类型表示实例对象，但是静态成员拿不到实例对象。</p><p>有些方法返回一个布尔值，表示当前的<code>this</code>是否属于某种类型。这时，这些方法的返回值类型可以写成<code>this is Type</code>的形式，其中用到了<code>is</code>运算符。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystemObject</span> {
  <span class="hljs-title function_">isFile</span>(): <span class="hljs-variable language_">this</span> is <span class="hljs-title class_">FileRep</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">FileRep</span>;
  }

  <span class="hljs-title function_">isDirectory</span>(): <span class="hljs-variable language_">this</span> is <span class="hljs-title class_">Directory</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Directory</span>;
  }

  <span class="hljs-comment">// ...</span>
}
</code></pre><p>上面示例中，两个方法的返回值类型都是布尔值，写成<code>this is Type</code>的形式，可以精确表示返回值。<code>is</code>运算符的介绍详见《类型断言》一章。</p><h2 id="参考链接">参考链接 <a class="markdownIt-Anchor" href="#参考链接">#</a></h2><ul><li><a href="http://fritzthecat-blog.blogspot.com/2018/06/typescript-constructor-in-interface.html" target="_blank" rel="noopener">TypeScript Constructor in Interface</a></li><li><a href="https://angular.schule/blog/2022-11-use-define-for-class-fields" target="_blank" rel="noopener">TypeScript: useDefineForClassFields – How to avoid future Breaking Changes</a></li></ul></article><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="interface.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> interface</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="generics.html">泛型 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><div class="page-info"><p>本教程采用<a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh" target="_blank">知识共享 署名-相同方式共享 3.0协议</a>。</p><p>分享本文 <span class="social-share"></span></p></div></div><div class="column is-3 is-offset-1"><nav class="panel panel-menu is-light"><p class="panel-heading"><i class="fa fa-book" aria-hidden="true"></i> TypeScript 教程</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="intro.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">简介</span></a></li><li><a href="basic.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">基本用法</span></a></li><li><a href="any.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">any 类型</span></a></li><li><a href="types.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型系统</span></a></li><li><a href="array.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">数组</span></a></li><li><a href="tuple.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">元组</span></a></li><li><a href="symbol.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">symbol 类型</span></a></li><li><a href="function.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">函数</span></a></li><li><a href="object.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">对象</span></a></li><li><a href="interface.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">interface</span></a></li><li><a href="class.html" class="is-active"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类</span></a></li><li><a href="generics.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">泛型</span></a></li><li><a href="enum.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Enum 类型</span></a></li><li><a href="assert.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型断言</span></a></li><li><a href="module.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">模块</span></a></li><li><a href="namespace.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">namespace</span></a></li><li><a href="decorator.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">装饰器</span></a></li><li><a href="decorator-legacy.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">装饰器（旧语法）</span></a></li><li><a href="declare.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">declare 关键字</span></a></li><li><a href="d.ts.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">d.ts 类型声明文件</span></a></li><li><a href="operator.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型运算符</span></a></li><li><a href="mapping.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型映射</span></a></li><li><a href="utility.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型工具</span></a></li><li><a href="comment.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">注释指令</span></a></li><li><a href="tsconfig.json.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">tsconfig.json 文件</span></a></li><li><a href="tsc.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">tsc 命令</span></a></li></ul></aside></div></nav><nav class="panel panel-info is-light"><p class="panel-heading"><i class="fa fa-link" aria-hidden="true"></i> 链接</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="https://raw.githubusercontent.com/wangdoc/typescript-tutorial/main/docs/class.md" target="_blank"><span class="icon"></span><i class="fa fa-code" aria-hidden="true" style="width: 14px;"></i>&nbsp;本文源码</a></li><li><a href="https://github.com/wangdoc/typescript-tutorial" target="_blank"><span class="icon"></span><i class="fa fa-hdd-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;代码仓库</a></li><li><a href="https://github.com/wangdoc/typescript-tutorial/issues" target="_blank"><span class="icon"></span><i class="fa fa-flag-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;反馈</a></li></ul></aside></div></nav></div></div><div class="columns"><div class="column is-8 is-6-widescreen is-offset-1-widescreen"><div id="disqus_thread"></div></div></div></div></section><footer class="footer"><div class="container"><div class="content has-text-centered"><p>联系：contact@wangdoc.com</p></div></div></footer><script>var LOPPO={current_path:"class.md",relative_root_path:"",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E7%AE%80%E4%BB%8B">简介</a>\n<ul>\n<li><a href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E7%B1%BB%E5%9E%8B">属性的类型</a></li>\n<li><a href="#readonly-%E4%BF%AE%E9%A5%B0%E7%AC%A6">readonly 修饰符</a></li>\n<li><a href="#%E6%96%B9%E6%B3%95%E7%9A%84%E7%B1%BB%E5%9E%8B">方法的类型</a></li>\n<li><a href="#%E5%AD%98%E5%8F%96%E5%99%A8%E6%96%B9%E6%B3%95">存取器方法</a></li>\n<li><a href="#%E5%B1%9E%E6%80%A7%E7%B4%A2%E5%BC%95">属性索引</a></li>\n</ul>\n</li>\n<li><a href="#%E7%B1%BB%E7%9A%84-interface-%E6%8E%A5%E5%8F%A3">类的 interface 接口</a>\n<ul>\n<li><a href="#implements-%E5%85%B3%E9%94%AE%E5%AD%97">implements 关键字</a></li>\n<li><a href="#%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3">实现多个接口</a></li>\n<li><a href="#%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%90%88%E5%B9%B6">类与接口的合并</a></li>\n</ul>\n</li>\n<li><a href="#class-%E7%B1%BB%E5%9E%8B">Class 类型</a>\n<ul>\n<li><a href="#%E5%AE%9E%E4%BE%8B%E7%B1%BB%E5%9E%8B">实例类型</a></li>\n<li><a href="#%E7%B1%BB%E7%9A%84%E8%87%AA%E8%BA%AB%E7%B1%BB%E5%9E%8B">类的自身类型</a></li>\n<li><a href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%88%99">结构类型原则</a></li>\n</ul>\n</li>\n<li><a href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF">类的继承</a></li>\n<li><a href="#override-%E5%85%B3%E9%94%AE%E5%AD%97">override 关键字</a></li>\n<li><a href="#%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6">可访问性修饰符</a>\n<ul>\n<li><a href="#public">public</a></li>\n<li><a href="#private">private</a></li>\n<li><a href="#protected">protected</a></li>\n<li><a href="#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E7%9A%84%E7%AE%80%E5%86%99%E5%BD%A2%E5%BC%8F">实例属性的简写形式</a></li>\n</ul>\n</li>\n<li><a href="#%E9%A1%B6%E5%B1%82%E5%B1%9E%E6%80%A7%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95">顶层属性的处理方法</a></li>\n<li><a href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98">静态成员</a></li>\n<li><a href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB">泛型类</a></li>\n<li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%8A%BD%E8%B1%A1%E6%88%90%E5%91%98">抽象类，抽象成员</a></li>\n<li><a href="#this-%E9%97%AE%E9%A2%98">this 问题</a></li>\n<li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li>\n</ul>\n'}</script><script src="assets/js/app.js"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-111269443-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-111269443-1")</script><script>var _hmt=_hmt||[];(()=>{var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?5eec262881855af3dede6a71234571f6",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)})()</script><script>var disqus_config=function(){var t=window.location,e=t.protocol+"//"+t.host+(t.port?":"+t.port:"")+t.pathname;this.page.url=e,this.page.identifier=t.pathname};(()=>{var t=document,e=t.createElement("script");e.src="https://wangdoc-typescript.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)})()</script><!--script src="assets/js/social-share.min.js"--><!--/script--><script>var shareDesc="我正在阅读《TypeScript 的 class 类型》，出自网道（WangDoc.com）的《TypeScript 教程》。",shareOpts={url:window.location.href,source:shareDesc,title:shareDesc,description:"",image:"",sites:["weibo","wechat","qq","qzone","twitter","facebook"],origin:"WangDoc_com",disabled:[],wechatQrcodeTitle:"微信",wechatQrcodeHelper:"扫一下二维码，分享到微信。"};socialShare(".social-share",shareOpts)</script></body></html>