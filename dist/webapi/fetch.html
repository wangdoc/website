<!DOCTYPE html><html lang="zh-CN" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Fetch API 教程 - Web API 教程 - 网道</title><!-- link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" --><link rel="stylesheet" href="assets/css/app.min.css"><link rel="stylesheet" href="https://apps.bdimg.com/libs/fontawesome/4.4.0/css/font-awesome.css"><!-- link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css"--><!-- link rel="stylesheet" href="assets/css/share.min.css" --><meta property="og:type" content="article"><meta property="og:title" content="Fetch API 教程"><link rel="apple-touch-icon" sizes="57x57" href="assets/icons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="assets/icons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="assets/icons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="assets/icons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="assets/icons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="assets/icons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="assets/icons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="assets/icons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="assets/icons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="assets/icons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="assets/icons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="assets/icons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="assets/icons/favicon-16x16.png"><link rel="manifest" href="assets/icons/manifest.json"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="assets/icons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"></head><body><nav class="navbar is-light" role="navigation" id="navbar" aria-label="main navigation"><div class="container"><div class="navbar-brand"><a href="/" class="navbar-item title has-text-grey has-text-weight-light is-5">网道 / WangDoc.com </a><a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false"><span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span></a></div><div class="navbar-menu" id="navMenu"><div class="navbar-end"><div class="navbar-item"><form action="https://sourcegraph.com/search" target="_blank" method="get" onsubmit='this.q.value="repo:^github.com/wangdoc/webapi-tutorial$ "+this.origin.value'><p class="control has-icons-right"><input class="input" type="text" name="origin" placeholder="搜索..."> <span class="icon is-small is-right"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"><path fill="#ddd" d="M23.822 20.88l-6.353-6.354c.93-1.465 1.467-3.2 1.467-5.059.001-5.219-4.247-9.467-9.468-9.467s-9.468 4.248-9.468 9.468c0 5.221 4.247 9.469 9.468 9.469 1.768 0 3.421-.487 4.839-1.333l6.396 6.396 3.119-3.12zm-20.294-11.412c0-3.273 2.665-5.938 5.939-5.938 3.275 0 5.94 2.664 5.94 5.938 0 3.275-2.665 5.939-5.94 5.939-3.274 0-5.939-2.664-5.939-5.939z"/></svg></span></p><input type="hidden" name="q" value=""> <input type="hidden" name="patternType" value="literal"></form></div><a class="navbar-item is-hidden-desktop-only" target="_blank" href="https://github.com/wangdoc/webapi-tutorial"><span class="icon" style="color: #333;"><i class="fa fa-lg fa-github"></i></span></a></div></div></div></nav><section class="section main article"><div class="container"><div class="columns"><div class="column is-8 is-6-widescreen is-offset-1-widescreen"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="index.html"><span class="icon"><i class="fa fa-home"></i></span> &nbsp;Web API 教程</a></li><li class="is-active"><a class="has-text-grey" href="fetch.html">Fetch API</a></li></ul></nav><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="clipboard.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> Clipboard API</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="fontface.html">FontFace API <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><article class="content"><h1 class="title">Fetch API 教程</h1><div class="page-meta"><p>网道（WangDoc.com），互联网文档计划</p></div><p><code>fetch()</code>是 XMLHttpRequest 的升级版，用于在 JavaScript 脚本里面发出 HTTP 请求。</p><p>浏览器原生提供这个对象。本章详细介绍它的用法。</p><h2 id="基本用法">基本用法 <a class="markdownIt-Anchor" href="#基本用法">#</a></h2><p><code>fetch()</code>的功能与 XMLHttpRequest 基本相同，但有三个主要的差异。</p><p>（1）<code>fetch()</code>使用 Promise，不使用回调函数，因此大大简化了写法，写起来更简洁。</p><p>（2）<code>fetch()</code>采用模块化设计，API 分散在多个对象上（Response 对象、Request 对象、Headers 对象），更合理一些；相比之下，XMLHttpRequest 的 API 设计并不是很好，输入、输出、状态都在同一个接口管理，容易写出非常混乱的代码。</p><p>（3）<code>fetch()</code>通过数据流（Stream 对象）处理数据，可以分块读取，有利于提高网站性能表现，减少内存占用，对于请求大文件或者网速慢的场景相当有用。XMLHTTPRequest 对象不支持数据流，所有的数据必须放在缓存里，不支持分块读取，必须等待全部拿到后，再一次性吐出来。</p><p>在用法上，<code>fetch()</code>接受一个 URL 字符串作为参数，默认向该网址发出 GET 请求，返回一个 Promise 对象。它的基本用法如下。</p><pre class="hljs"><code>fetch(url)
  .then(...)
  .catch(...)
</code></pre><p>下面是一个例子，从服务器获取 JSON 数据。</p><pre class="hljs"><code>fetch(<span class="hljs-string">&#x27;https://api.github.com/users/ruanyf&#x27;</span>)
  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())
  .then(<span class="hljs-function"><span class="hljs-params">json</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(json))
  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Request Failed&#x27;</span>, err)); 
</code></pre><p>上面示例中，<code>fetch()</code>接收到的<code>response</code>是一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Streams_API" target="_blank" rel="noopener">Stream 对象</a>，<code>response.json()</code>是一个异步操作，取出所有内容，并将其转为 JSON 对象。</p><p>Promise 可以使用 await 语法改写，使得语义更清晰。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getJSON</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> url = <span class="hljs-string">&#x27;https://api.github.com/users/ruanyf&#x27;</span>;
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(url);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> response.json();
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Request Failed&#x27;</span>, error);
  }
}
</code></pre><p>上面示例中，<code>await</code>语句必须放在<code>try...catch</code>里面，这样才能捕捉异步操作中可能发生的错误。</p><p>后文都采用<code>await</code>的写法，不使用<code>.then()</code>的写法。</p><h2 id="response-对象处理-http-回应">Response 对象：处理 HTTP 回应 <a class="markdownIt-Anchor" href="#response-对象处理-http-回应">#</a></h2><h3 id="response-对象的同步属性">Response 对象的同步属性 <a class="markdownIt-Anchor" href="#response-对象的同步属性">#</a></h3><p><code>fetch()</code>请求成功以后，得到的是一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response" target="_blank" rel="noopener">Response 对象</a>。它对应服务器的 HTTP 回应。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(url);
</code></pre><p>前面说过，Response 包含的数据通过 Stream 接口异步读取，但是它还包含一些同步属性，对应 HTTP 回应的标头信息（Headers），可以立即读取。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchText</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;/readme.txt&#x27;</span>);
  <span class="hljs-built_in">console</span>.log(response.status);
  <span class="hljs-built_in">console</span>.log(response.statusText);
}
</code></pre><p>上面示例中，<code>response.status</code>和<code>response.statusText</code>就是 Response 的同步属性，可以立即读取。</p><p>标头信息属性有下面这些。</p><p><strong>Response.ok</strong></p><p><code>Response.ok</code>属性返回一个布尔值，表示请求是否成功，<code>true</code>对应 HTTP 请求的状态码 200 到 299，<code>false</code>对应其他的状态码。</p><p><strong>Response.status</strong></p><p><code>Response.status</code>属性返回一个数字，表示 HTTP 回应的状态码（例如200，表示成功请求）。</p><p><strong>Response.statusText</strong></p><p><code>Response.statusText</code>属性返回一个字符串，表示 HTTP 回应的状态信息（例如请求成功以后，服务器返回“OK”）。</p><p><strong>Response.url</strong></p><p><code>Response.url</code>属性返回请求的 URL。如果 URL 存在跳转，该属性返回的是最终 URL。</p><p><strong>Response.type</strong></p><p><code>Response.type</code>属性返回请求的类型。可能的值如下：</p><ul><li><code>basic</code>：普通请求，即同源请求。</li><li><code>cors</code>：跨源请求。</li><li><code>error</code>：网络错误，主要用于 Service Worker。</li><li><code>opaque</code>：如果<code>fetch()</code>请求的<code>type</code>属性设为<code>no-cors</code>，就会返回这个值，详见请求部分。表示发出的是简单的跨源请求，类似<code>&lt;form&gt;</code>表单的那种跨源请求。</li><li><code>opaqueredirect</code>：如果<code>fetch()</code>请求的<code>redirect</code>属性设为<code>manual</code>，就会返回这个值，详见请求部分。</li></ul><p><strong>Response.redirected</strong></p><p><code>Response.redirected</code>属性返回一个布尔值，表示请求是否发生过跳转。</p><h3 id="判断请求是否成功">判断请求是否成功 <a class="markdownIt-Anchor" href="#判断请求是否成功">#</a></h3><p><code>fetch()</code>发出请求以后，有一个很重要的注意点：只有网络错误，或者无法连接时，<code>fetch()</code>才会报错，其他情况都不会报错，而是认为请求成功。</p><p>这就是说，即使服务器返回的状态码是 4xx 或 5xx，<code>fetch()</code>也不会报错（即 Promise 不会变为 <code>rejected</code>状态）。</p><p>只有通过<code>Response.status</code>属性，得到 HTTP 回应的真实状态码，才能判断请求是否成功。请看下面的例子。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchText</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;/readme.txt&#x27;</span>);
  <span class="hljs-keyword">if</span> (response.status &gt;= <span class="hljs-number">200</span> &amp;&amp; response.status &lt; <span class="hljs-number">300</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> response.text();
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(response.statusText);
  }
}
</code></pre><p>上面示例中，<code>response.status</code>属性只有等于 2xx （200~299），才能认定请求成功。这里不用考虑网址跳转（状态码为 3xx），因为<code>fetch()</code>会将跳转的状态码自动转为 200。</p><p>另一种方法是判断<code>response.ok</code>是否为<code>true</code>。</p><pre class="hljs"><code><span class="hljs-keyword">if</span> (response.ok) {
  <span class="hljs-comment">// 请求成功</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// 请求失败</span>
}
</code></pre><h3 id="responseheaders-属性">Response.headers 属性 <a class="markdownIt-Anchor" href="#responseheaders-属性">#</a></h3><p>Response 对象还有一个<code>Response.headers</code>属性，指向一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Headers" target="_blank" rel="noopener">Headers 对象</a>，对应 HTTP 回应的所有标头。</p><p>Headers 对象可以使用<code>for...of</code>循环进行遍历。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(url);

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> response.headers) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${key}</span> : <span class="hljs-subst">${value}</span>`</span>);
}

<span class="hljs-comment">// 或者</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> response.headers.entries()) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${key}</span> : <span class="hljs-subst">${value}</span>`</span>);
}
</code></pre><p>Headers 对象提供了以下方法，用来操作标头。</p><blockquote><ul><li><code>Headers.get()</code>：根据指定的键名，返回键值。</li><li><code>Headers.has()</code>： 返回一个布尔值，表示是否包含某个标头。</li><li><code>Headers.set()</code>：将指定的键名设置为新的键值，如果该键名不存在则会添加。</li><li><code>Headers.append()</code>：添加标头。</li><li><code>Headers.delete()</code>：删除标头。</li><li><code>Headers.keys()</code>：返回一个遍历器，可以依次遍历所有键名。</li><li><code>Headers.values()</code>：返回一个遍历器，可以依次遍历所有键值。</li><li><code>Headers.entries()</code>：返回一个遍历器，可以依次遍历所有键值对（<code>[key, value]</code>）。</li><li><code>Headers.forEach()</code>：依次遍历标头，每个标头都会执行一次参数函数。</li></ul></blockquote><p>上面的有些方法可以修改标头，那是因为继承自 Headers 接口。对于 HTTP 回应来说，修改标头意义不大，况且很多标头是只读的，浏览器不允许修改。</p><p>这些方法中，最常用的是<code>response.headers.get()</code>，用于读取某个标头的值。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> response =  <span class="hljs-keyword">await</span>  fetch(url);
response.headers.get(<span class="hljs-string">&#x27;Content-Type&#x27;</span>)
<span class="hljs-comment">// application/json; charset=utf-8</span>
</code></pre><p><code>Headers.keys()</code>和<code>Headers.values()</code>方法用来分别遍历标头的键名和键值。</p><pre class="hljs"><code><span class="hljs-comment">// 键名</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> myHeaders.keys()) {
  <span class="hljs-built_in">console</span>.log(key);
}

<span class="hljs-comment">// 键值</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> myHeaders.values()) {
  <span class="hljs-built_in">console</span>.log(value);
}
</code></pre><p><code>Headers.forEach()</code>方法也可以遍历所有的键值和键名。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(url);
response.headers.forEach(
  <span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(key, <span class="hljs-string">&#x27;:&#x27;</span>, value)
);
</code></pre><h3 id="读取内容的方法">读取内容的方法 <a class="markdownIt-Anchor" href="#读取内容的方法">#</a></h3><p><code>Response</code>对象根据服务器返回的不同类型的数据，提供了不同的读取方法。</p><blockquote><ul><li><code>response.text()</code>：得到文本字符串。</li><li><code>response.json()</code>：得到 JSON 对象。</li><li><code>response.blob()</code>：得到二进制 Blob 对象。</li><li><code>response.formData()</code>：得到 FormData 表单对象。</li><li><code>response.arrayBuffer()</code>：得到二进制 ArrayBuffer 对象。</li></ul></blockquote><p>上面5个读取方法都是异步的，返回的都是 Promise 对象。必须等到异步操作结束，才能得到服务器返回的完整数据。</p><p><strong>response.text()</strong></p><p><code>response.text()</code>可以用于获取文本数据，比如 HTML 文件。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;/users.html&#x27;</span>);
<span class="hljs-keyword">const</span> body = <span class="hljs-keyword">await</span> response.text();
<span class="hljs-built_in">document</span>.body.innerHTML = body
</code></pre><p><strong>response.json()</strong></p><p><code>response.json()</code>主要用于获取服务器返回的 JSON 数据，前面已经举过例子了。</p><p><strong>response.formData()</strong></p><p><code>response.formData()</code>主要用在 Service Worker 里面，拦截用户提交的表单，修改某些数据以后，再提交给服务器。</p><p><strong>response.blob()</strong></p><p><code>response.blob()</code>用于获取二进制文件。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;flower.jpg&#x27;</span>);
<span class="hljs-keyword">const</span> myBlob = <span class="hljs-keyword">await</span> response.blob();
<span class="hljs-keyword">const</span> objectURL = URL.createObjectURL(myBlob);

<span class="hljs-keyword">const</span> myImage = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;img&#x27;</span>);
myImage.src = objectURL;
</code></pre><p>上面示例读取图片文件<code>flower.jpg</code>，显示在网页上。</p><p><strong>response.arrayBuffer()</strong></p><p><code>response.arrayBuffer()</code>主要用于获取流媒体文件。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> audioCtx = <span class="hljs-keyword">new</span> <span class="hljs-built_in">window</span>.AudioContext();
<span class="hljs-keyword">const</span> source = audioCtx.createBufferSource();

<span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;song.ogg&#x27;</span>);
<span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">await</span> response.arrayBuffer();

<span class="hljs-keyword">const</span> decodeData = <span class="hljs-keyword">await</span> audioCtx.decodeAudioData(buffer);
source.buffer = buffer;
source.connect(audioCtx.destination);
source.loop = <span class="hljs-literal">true</span>;
</code></pre><p>上面示例是<code>response.arrayBuffer()</code>获取音频文件<code>song.ogg</code>，然后在线播放的例子。</p><h3 id="responseclone">Response.clone() <a class="markdownIt-Anchor" href="#responseclone">#</a></h3><p>Stream 对象只能读取一次，读取完就没了。这意味着，前一节的五个读取方法，只能使用一个，否则会报错。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> text =  <span class="hljs-keyword">await</span> response.text();
<span class="hljs-keyword">let</span> json =  <span class="hljs-keyword">await</span> response.json();  <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例先使用了<code>response.text()</code>，就把 Stream 读完了。后面再调用<code>response.json()</code>，就没有内容可读了，所以报错。</p><p>Response 对象提供<code>Response.clone()</code>方法，创建<code>Response</code>对象的副本，实现多次读取。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> response1 = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;flowers.jpg&#x27;</span>);
<span class="hljs-keyword">const</span> response2 = response1.clone();

<span class="hljs-keyword">const</span> myBlob1 = <span class="hljs-keyword">await</span> response1.blob();
<span class="hljs-keyword">const</span> myBlob2 = <span class="hljs-keyword">await</span> response2.blob();

image1.src = URL.createObjectURL(myBlob1);
image2.src = URL.createObjectURL(myBlob2);
</code></pre><p>上面示例中，<code>response.clone()</code>复制了一份 Response 对象，然后将同一张图片读取了两次。</p><p>Response 对象还有一个<code>Response.redirect()</code>方法，用于将 Response 结果重定向到指定的 URL。该方法一般只用在 Service Worker 里面，这里就不介绍了。</p><h3 id="responsebody-属性">Response.body 属性 <a class="markdownIt-Anchor" href="#responsebody-属性">#</a></h3><p><code>Response.body</code>属性是 Response 对象暴露出的底层接口，返回一个 ReadableStream 对象，供用户操作。</p><p>它可以用来分块读取内容，应用之一就是显示下载的进度。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;flower.jpg&#x27;</span>);
<span class="hljs-keyword">const</span> reader = response.body.getReader();

<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">const</span> {done, value} = <span class="hljs-keyword">await</span> reader.read();

  <span class="hljs-keyword">if</span> (done) {
    <span class="hljs-keyword">break</span>;
  }

  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Received <span class="hljs-subst">${value.length}</span> bytes`</span>)
}
</code></pre><p>上面示例中，<code>response.body.getReader()</code>方法返回一个遍历器。这个遍历器的<code>read()</code>方法每次返回一个对象，表示本次读取的内容块。</p><p>这个对象的<code>done</code>属性是一个布尔值，用来判断有没有读完；<code>value</code>属性是一个 arrayBuffer 数组，表示内容块的内容，而<code>value.length</code>属性是当前块的大小。</p><h2 id="fetch的第二个参数定制-http-请求"><code>fetch()</code>的第二个参数：定制 HTTP 请求 <a class="markdownIt-Anchor" href="#fetch的第二个参数定制-http-请求">#</a></h2><p><code>fetch()</code>的第一个参数是 URL，还可以接受第二个参数，作为配置对象，定制发出的 HTTP 请求。</p><pre class="hljs"><code>fetch(url, optionObj)
</code></pre><p>上面命令的<code>optionObj</code>就是第二个参数。</p><p>HTTP 请求的方法、标头、数据体都在这个对象里面设置。下面是一些示例。</p><p><strong>（1）POST 请求</strong></p><pre class="hljs"><code><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(url, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,
  <span class="hljs-attr">headers</span>: {
    <span class="hljs-string">&quot;Content-type&quot;</span>: <span class="hljs-string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>,
  },
  <span class="hljs-attr">body</span>: <span class="hljs-string">&#x27;foo=bar&amp;lorem=ipsum&#x27;</span>,
});

<span class="hljs-keyword">const</span> json = <span class="hljs-keyword">await</span> response.json();
</code></pre><p>上面示例中，配置对象用到了三个属性。</p><blockquote><ul><li><code>method</code>：HTTP 请求的方法，<code>POST</code>、<code>DELETE</code>、<code>PUT</code>都在这个属性设置。</li><li><code>headers</code>：一个对象，用来定制 HTTP 请求的标头。</li><li><code>body</code>：POST 请求的数据体。</li></ul></blockquote><p>注意，有些标头不能通过<code>headers</code>属性设置，比如<code>Content-Length</code>、<code>Cookie</code>、<code>Host</code>等等。它们是由浏览器自动生成，无法修改。</p><p><strong>（2）提交 JSON 数据</strong></p><pre class="hljs"><code><span class="hljs-keyword">const</span> user =  { <span class="hljs-attr">name</span>:  <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-attr">surname</span>:  <span class="hljs-string">&#x27;Smith&#x27;</span>  };
<span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;/article/fetch/post/user&#x27;</span>, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,
  <span class="hljs-attr">headers</span>: {
   <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json;charset=utf-8&#x27;</span>
  }, 
  <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(user) 
});
</code></pre><p>上面示例中，标头<code>Content-Type</code>要设成<code>'application/json;charset=utf-8'</code>。因为默认发送的是纯文本，<code>Content-Type</code>的默认值是<code>'text/plain;charset=UTF-8'</code>。</p><p><strong>（3）提交表单</strong></p><pre class="hljs"><code><span class="hljs-keyword">const</span> form = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;form&#x27;</span>);

<span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;/users&#x27;</span>, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,
  <span class="hljs-attr">body</span>: <span class="hljs-keyword">new</span> FormData(form)
})
</code></pre><p><strong>（4）文件上传</strong></p><p>如果表单里面有文件选择器，可以用前一个例子的写法，上传的文件包含在整个表单里面，一起提交。</p><p>另一种方法是用脚本添加文件，构造出一个表单，进行上传，请看下面的例子。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> input = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;input[type=&quot;file&quot;]&#x27;</span>);

<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">new</span> FormData();
data.append(<span class="hljs-string">&#x27;file&#x27;</span>, input.files[<span class="hljs-number">0</span>]);
data.append(<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;foo&#x27;</span>);

fetch(<span class="hljs-string">&#x27;/avatars&#x27;</span>, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,
  <span class="hljs-attr">body</span>: data
});
</code></pre><p>上传二进制文件时，不用修改标头的<code>Content-Type</code>，浏览器会自动设置。</p><p><strong>（5）直接上传二进制数据</strong></p><p><code>fetch()</code>也可以直接上传二进制数据，将 Blob 或 arrayBuffer 数据放在<code>body</code>属性里面。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> blob = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span>
  canvasElem.toBlob(resolve,  <span class="hljs-string">&#x27;image/png&#x27;</span>)
);

<span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;/article/fetch/post/image&#x27;</span>, {
  <span class="hljs-attr">method</span>:  <span class="hljs-string">&#x27;POST&#x27;</span>,
  <span class="hljs-attr">body</span>: blob
});
</code></pre><h2 id="fetch配置对象的完整-api"><code>fetch()</code>配置对象的完整 API <a class="markdownIt-Anchor" href="#fetch配置对象的完整-api">#</a></h2><p><code>fetch()</code>第二个参数的完整 API 如下。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> response = fetch(url, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;GET&quot;</span>,
  <span class="hljs-attr">headers</span>: {
    <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;text/plain;charset=UTF-8&quot;</span>
  },
  <span class="hljs-attr">body</span>: <span class="hljs-literal">undefined</span>,
  <span class="hljs-attr">referrer</span>: <span class="hljs-string">&quot;about:client&quot;</span>,
  <span class="hljs-attr">referrerPolicy</span>: <span class="hljs-string">&quot;no-referrer-when-downgrade&quot;</span>,
  <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;cors&quot;</span>,
  <span class="hljs-attr">credentials</span>: <span class="hljs-string">&quot;same-origin&quot;</span>,
  <span class="hljs-attr">cache</span>: <span class="hljs-string">&quot;default&quot;</span>,
  <span class="hljs-attr">redirect</span>: <span class="hljs-string">&quot;follow&quot;</span>,
  <span class="hljs-attr">integrity</span>: <span class="hljs-string">&quot;&quot;</span>,
  <span class="hljs-attr">keepalive</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">signal</span>: <span class="hljs-literal">undefined</span>
});
</code></pre><p><code>fetch()</code>请求的底层用的是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request/Request" target="_blank" rel="noopener">Request() 对象</a>的接口，参数完全一样，因此上面的 API 也是<code>Request()</code>的 API。</p><p>这些属性里面，<code>headers</code>、<code>body</code>、<code>method</code>前面已经给过示例了，下面是其他属性的介绍。</p><p><strong>cache</strong></p><p><code>cache</code>属性指定如何处理缓存。可能的取值如下：</p><ul><li><code>default</code>：默认值，先在缓存里面寻找匹配的请求。</li><li><code>no-store</code>：直接请求远程服务器，并且不更新缓存。</li><li><code>reload</code>：直接请求远程服务器，并且更新缓存。</li><li><code>no-cache</code>：将服务器资源跟本地缓存进行比较，有新的版本才使用服务器资源，否则使用缓存。</li><li><code>force-cache</code>：缓存优先，只有不存在缓存的情况下，才请求远程服务器。</li><li><code>only-if-cached</code>：只检查缓存，如果缓存里面不存在，将返回504错误。</li></ul><p><strong>mode</strong></p><p><code>mode</code>属性指定请求的模式。可能的取值如下：</p><ul><li><code>cors</code>：默认值，允许跨源请求。</li><li><code>same-origin</code>：只允许同源请求。</li><li><code>no-cors</code>：请求方法只限于 GET、POST 和 HEAD，并且只能使用有限的几个简单标头，不能添加跨源的复杂标头，相当于提交表单、<code>&lt;script&gt;</code>加载脚本、<code>&lt;img&gt;</code>加载图片等传统的跨源请求方法。</li></ul><p><strong>credentials</strong></p><p><code>credentials</code>属性指定是否发送 Cookie。可能的取值如下：</p><ul><li><code>same-origin</code>：默认值，同源请求时发送 Cookie，跨源请求时不发送。</li><li><code>include</code>：不管同源请求，还是跨源请求，一律发送 Cookie。</li><li><code>omit</code>：一律不发送。</li></ul><p>跨源请求发送 Cookie，需要将<code>credentials</code>属性设为<code>include</code>。</p><pre class="hljs"><code>fetch(<span class="hljs-string">&#x27;http://another.com&#x27;</span>, {
  <span class="hljs-attr">credentials</span>: <span class="hljs-string">&quot;include&quot;</span>
});
</code></pre><p><strong>signal</strong></p><p><code>signal</code>属性指定一个 AbortSignal 实例，用于取消<code>fetch()</code>请求，详见下一节。</p><p><strong>keepalive</strong></p><p><code>keepalive</code>属性用于页面卸载时，告诉浏览器在后台保持连接，继续发送数据。</p><p>一个典型的场景就是，用户离开网页时，脚本向服务器提交一些用户行为的统计信息。这时，如果不用<code>keepalive</code>属性，数据可能无法发送，因为浏览器已经把页面卸载了。</p><pre class="hljs"><code><span class="hljs-built_in">window</span>.onunload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  fetch(<span class="hljs-string">&#x27;/analytics&#x27;</span>, {
    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,
    <span class="hljs-attr">headers</span>: {
      <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>
    },
    <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify({
      <span class="hljs-attr">some</span>: <span class="hljs-string">&#x27;data&#x27;</span>
    }),
    <span class="hljs-attr">keepalive</span>: <span class="hljs-literal">true</span>
  });
};
</code></pre><p><strong>redirect</strong></p><p><code>redirect</code>属性指定 HTTP 跳转的处理方法。可能的取值如下：</p><ul><li><code>follow</code>：默认值，<code>fetch()</code>跟随 HTTP 跳转。</li><li><code>error</code>：如果发生跳转，<code>fetch()</code>就报错。</li><li><code>manual</code>：<code>fetch()</code>不跟随 HTTP 跳转，但是<code>response.url</code>属性会指向新的 URL，<code>response.redirected</code>属性会变为<code>true</code>，由开发者自己决定后续如何处理跳转。</li></ul><p><strong>integrity</strong></p><p><code>integrity</code>属性指定一个哈希值，用于检查 HTTP 回应传回的数据是否等于这个预先设定的哈希值。</p><p>比如，下载文件时，检查文件的 SHA-256 哈希值是否相符，确保没有被篡改。</p><pre class="hljs"><code>fetch(<span class="hljs-string">&#x27;http://site.com/file&#x27;</span>, {
  <span class="hljs-attr">integrity</span>: <span class="hljs-string">&#x27;sha256-abcdef&#x27;</span>
});
</code></pre><p><strong>referrer</strong></p><p><code>referrer</code>属性用于设定<code>fetch()</code>请求的<code>referer</code>标头。</p><p>这个属性可以为任意字符串，也可以设为空字符串（即不发送<code>referer</code>标头）。</p><pre class="hljs"><code>fetch(<span class="hljs-string">&#x27;/page&#x27;</span>, {
  <span class="hljs-attr">referrer</span>: <span class="hljs-string">&#x27;&#x27;</span>
});
</code></pre><p><strong>referrerPolicy</strong></p><p><code>referrerPolicy</code>属性用于设定<code>Referer</code>标头的规则。可能的取值如下：</p><ul><li><code>no-referrer-when-downgrade</code>：默认值，总是发送<code>Referer</code>标头，除非从 HTTPS 页面请求 HTTP 资源时不发送。</li><li><code>no-referrer</code>：不发送<code>Referer</code>标头。</li><li><code>origin</code>：<code>Referer</code>标头只包含域名，不包含完整的路径。</li><li><code>origin-when-cross-origin</code>：同源请求<code>Referer</code>标头包含完整的路径，跨源请求只包含域名。</li><li><code>same-origin</code>：跨源请求不发送<code>Referer</code>，同源请求发送。</li><li><code>strict-origin</code>：<code>Referer</code>标头只包含域名，HTTPS 页面请求 HTTP 资源时不发送<code>Referer</code>标头。</li><li><code>strict-origin-when-cross-origin</code>：同源请求时<code>Referer</code>标头包含完整路径，跨源请求时只包含域名，HTTPS 页面请求 HTTP 资源时不发送该标头。</li><li><code>unsafe-url</code>：不管什么情况，总是发送<code>Referer</code>标头。</li></ul><h2 id="取消fetch请求">取消<code>fetch()</code>请求 <a class="markdownIt-Anchor" href="#取消fetch请求">#</a></h2><p><code>fetch()</code>请求发送以后，如果中途想要取消，需要使用<code>AbortController</code>对象。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> controller = <span class="hljs-keyword">new</span> AbortController();
<span class="hljs-keyword">let</span> signal = controller.signal;

fetch(url, {
  <span class="hljs-attr">signal</span>: controller.signal
});

signal.addEventListener(<span class="hljs-string">&#x27;abort&#x27;</span>,
  <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;abort!&#x27;</span>)
);

controller.abort(); <span class="hljs-comment">// 取消</span>

<span class="hljs-built_in">console</span>.log(signal.aborted); <span class="hljs-comment">// true</span>
</code></pre><p>上面示例中，首先新建 AbortController 实例，然后发送<code>fetch()</code>请求，配置对象的<code>signal</code>属性必须指定接收 AbortController 实例发送的信号<code>controller.signal</code>。</p><p><code>controller.abort()</code>方法用于发出取消信号。这时会触发<code>abort</code>事件，这个事件可以监听，也可以通过<code>controller.signal.aborted</code>属性判断取消信号是否已经发出。</p><p>下面是一个1秒后自动取消请求的例子。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> controller = <span class="hljs-keyword">new</span> AbortController();
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> controller.abort(), <span class="hljs-number">1000</span>);

<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;/long-operation&#x27;</span>, {
    <span class="hljs-attr">signal</span>: controller.signal
  });
} <span class="hljs-keyword">catch</span>(err) {
  <span class="hljs-keyword">if</span> (err.name == <span class="hljs-string">&#x27;AbortError&#x27;</span>) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Aborted!&#x27;</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> err;
  }
}
</code></pre><h2 id="参考链接">参考链接 <a class="markdownIt-Anchor" href="#参考链接">#</a></h2><ul><li><a href="https://javascript.info/fetch" target="_blank" rel="noopener">Network requests: Fetch</a></li><li><a href="https://github.com/node-fetch/node-fetch" target="_blank" rel="noopener">node-fetch</a></li><li><a href="https://developers.google.com/web/updates/2015/03/introduction-to-fetch" target="_blank" rel="noopener">Introduction to fetch()</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" target="_blank" rel="noopener">Using Fetch</a></li><li><a href="https://developerhowto.com/2019/09/14/javascript-fetch-api/" target="_blank" rel="noopener">Javascript Fetch API: The XMLHttpRequest evolution</a></li><li><a href="https://www.sitepen.com/blog/2017/10/02/a-guide-to-faster-web-app-io-and-data-operations-with-streams/" target="_blank" rel="noopener">A Guide to Faster Web App I/O and Data Operations with Streams</a></li></ul></article><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="clipboard.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> Clipboard API</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="fontface.html">FontFace API <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><div class="page-info"><p>本教程采用<a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh" target="_blank">知识共享 署名-相同方式共享 3.0协议</a>。</p><p>分享本文 <span class="social-share"></span></p></div></div><div class="column is-3 is-offset-1"><nav class="panel panel-menu"><p class="panel-heading"><i class="fa fa-book" aria-hidden="true"></i> Web API 教程</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="canvas.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Canvas API</span></a></li><li><a href="clipboard.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Clipboard API</span></a></li><li><a href="fetch.html" class="is-active"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Fetch API</span></a></li><li><a href="fontface.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">FontFace API</span></a></li><li><a href="geolocation.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Geolocation API</span></a></li><li><a href="intersectionObserver.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">IntersectionObserver</span></a></li><li><a href="intl-relativetimeformat.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Intl.RelativeTimeFormat</span></a></li><li><a href="page-lifecycle.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Page Lifecycle API</span></a></li><li><a href="page-visibility.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Page Visibility API</span></a></li><li><a href="server-sent-events.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Server-Sent Events</span></a></li><li><a href="svg.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">SVG 图像</span></a></li><li><a href="websocket.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">WebSocket</span></a></li><li><a href="web-share-api.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Web Share API</span></a></li></ul></aside></div></nav><nav class="panel panel-info"><p class="panel-heading"><i class="fa fa-link" aria-hidden="true"></i> 链接</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="https://raw.githubusercontent.com/wangdoc/webapi-tutorial/master/docs/fetch.md" target="_blank"><span class="icon"></span><i class="fa fa-code" aria-hidden="true" style="width: 14px;"></i>&nbsp;本文源码</a></li><li><a href="https://github.com/wangdoc/webapi-tutorial" target="_blank"><span class="icon"></span><i class="fa fa-hdd-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;代码仓库</a></li><li><a href="https://github.com/wangdoc/webapi-tutorial/issues" target="_blank"><span class="icon"></span><i class="fa fa-flag-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;反馈</a></li></ul></aside></div></nav></div></div><div class="columns"><div class="column is-8 is-6-widescreen is-offset-1-widescreen"><div id="disqus_thread"></div></div></div></div></section><footer class="footer"><div class="container"><div class="content has-text-centered"><p>联系：contact@wangdoc.com</p></div></div></footer><script>var LOPPO={current_path:"fetch.md",relative_root_path:"",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</a></li>\n<li><a href="#response-%E5%AF%B9%E8%B1%A1%E5%A4%84%E7%90%86-http-%E5%9B%9E%E5%BA%94">Response 对象：处理 HTTP 回应</a>\n<ul>\n<li><a href="#response-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8C%E6%AD%A5%E5%B1%9E%E6%80%A7">Response 对象的同步属性</a></li>\n<li><a href="#%E5%88%A4%E6%96%AD%E8%AF%B7%E6%B1%82%E6%98%AF%E5%90%A6%E6%88%90%E5%8A%9F">判断请求是否成功</a></li>\n<li><a href="#responseheaders-%E5%B1%9E%E6%80%A7">Response.headers 属性</a></li>\n<li><a href="#%E8%AF%BB%E5%8F%96%E5%86%85%E5%AE%B9%E7%9A%84%E6%96%B9%E6%B3%95">读取内容的方法</a></li>\n<li><a href="#responseclone">Response.clone()</a></li>\n<li><a href="#responsebody-%E5%B1%9E%E6%80%A7">Response.body 属性</a></li>\n</ul>\n</li>\n<li><a href="#fetch%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%E5%AE%9A%E5%88%B6-http-%E8%AF%B7%E6%B1%82"><code>fetch()</code>的第二个参数：定制 HTTP 请求</a></li>\n<li><a href="#fetch%E9%85%8D%E7%BD%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%8C%E6%95%B4-api"><code>fetch()</code>配置对象的完整 API</a></li>\n<li><a href="#%E5%8F%96%E6%B6%88fetch%E8%AF%B7%E6%B1%82">取消<code>fetch()</code>请求</a></li>\n<li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li>\n</ul>\n'}</script><script src="assets/js/app.js"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-111269443-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-111269443-1")</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?5eec262881855af3dede6a71234571f6",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)}()</script><script>var disqus_config=function(){var t=window.location,e=t.protocol+"//"+t.host+(t.port?":"+t.port:"")+t.pathname;this.page.url=e,this.page.identifier=t.pathname};!function(){var t=document,e=t.createElement("script");e.src="https://wangdoc-webapi.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><!--script src="assets/js/social-share.min.js"--><!--/script--><script>var shareDesc="我正在阅读《Fetch API 教程》，出自网道（WangDoc.com）的《Web API 教程》。",shareOpts={url:window.location.href,source:shareDesc,title:shareDesc,description:"",image:"",sites:["weibo","wechat","qq","qzone","twitter","facebook"],origin:"WangDoc_com",disabled:[],wechatQrcodeTitle:"微信",wechatQrcodeHelper:"扫一下二维码，分享到微信。"};socialShare(".social-share",shareOpts)</script></body></html>