<!DOCTYPE html><html lang="zh-CN" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>async 函数 - ES6 教程 - 网道</title><!-- link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" --><link rel="stylesheet" href="assets/css/app.min.css"><link rel="stylesheet" href="https://apps.bdimg.com/libs/fontawesome/4.4.0/css/font-awesome.css"><!-- link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css"--><!-- link rel="stylesheet" href="assets/css/share.min.css" --><meta property="og:type" content="article"><meta property="og:title" content="async 函数"><link rel="apple-touch-icon" sizes="57x57" href="assets/icons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="assets/icons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="assets/icons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="assets/icons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="assets/icons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="assets/icons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="assets/icons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="assets/icons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="assets/icons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="assets/icons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="assets/icons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="assets/icons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="assets/icons/favicon-16x16.png"><link rel="manifest" href="assets/icons/manifest.json"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="assets/icons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"></head><body><nav class="navbar is-light" role="navigation" id="navbar" aria-label="main navigation"><div class="container"><div class="navbar-brand"><a href="/" class="navbar-item title has-text-grey has-text-weight-light is-5">网道 / WangDoc.com </a><a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false"><span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span></a></div><div class="navbar-menu" id="navMenu"><div class="navbar-end"><div class="navbar-item"><form action="https://sourcegraph.com/search" target="_blank" method="get" onsubmit='this.q.value="repo:^github.com/wangdoc/es6-tutorial$ "+this.origin.value'><p class="control has-icons-right"><input class="input" type="text" name="origin" placeholder="搜索..."> <span class="icon is-small is-right"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"><path fill="#ddd" d="M23.822 20.88l-6.353-6.354c.93-1.465 1.467-3.2 1.467-5.059.001-5.219-4.247-9.467-9.468-9.467s-9.468 4.248-9.468 9.468c0 5.221 4.247 9.469 9.468 9.469 1.768 0 3.421-.487 4.839-1.333l6.396 6.396 3.119-3.12zm-20.294-11.412c0-3.273 2.665-5.938 5.939-5.938 3.275 0 5.94 2.664 5.94 5.938 0 3.275-2.665 5.939-5.94 5.939-3.274 0-5.939-2.664-5.939-5.939z"/></svg></span></p><input type="hidden" name="q" value=""> <input type="hidden" name="patternType" value="literal"></form></div><a class="navbar-item is-hidden-desktop-only" target="_blank" href="https://github.com/wangdoc/es6-tutorial"><span class="icon" style="color: #333;"><i class="fa fa-lg fa-github"></i></span></a></div></div></div></nav><section class="section main article"><div class="container"><div class="columns"><div class="column is-8"><nav class="breadcrumb is-size-5-desktop" aria-label="breadcrumbs"><ul><li><a href="index.html"><span class="icon"><i class="fa fa-home"></i></span> &nbsp;ES6 教程</a></li><li class="is-active"><a class="has-text-grey" href="async.html">async 函数</a></li></ul></nav><nav class="level level-previous-next is-size-5 is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="generator-async.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> Generator 函数的异步应用</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="class.html">Class 的基本语法 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><article class="content is-size-4-desktop"><h1 class="title">async 函数</h1><div class="page-meta"><p>网道（WangDoc.com），互联网文档计划</p></div><h2 id="含义">含义 <a class="markdownIt-Anchor" href="#含义">#</a></h2><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p><p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p><p>前文有一个 Generator 函数，依次读取两个文件。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);

<span class="hljs-keyword">const</span> readFile = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fileName</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
    fs.readFile(fileName, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, data</span>) </span>{
      <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> reject(error);
      resolve(data);
    });
  });
};

<span class="hljs-keyword">const</span> gen = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> f1 = <span class="hljs-keyword">yield</span> readFile(<span class="hljs-string">&#x27;/etc/fstab&#x27;</span>);
  <span class="hljs-keyword">const</span> f2 = <span class="hljs-keyword">yield</span> readFile(<span class="hljs-string">&#x27;/etc/shells&#x27;</span>);
  <span class="hljs-built_in">console</span>.log(f1.toString());
  <span class="hljs-built_in">console</span>.log(f2.toString());
};
</code></pre><p>上面代码的函数<code>gen</code>可以写成<code>async</code>函数，就是下面这样。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> asyncReadFile = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> f1 = <span class="hljs-keyword">await</span> readFile(<span class="hljs-string">&#x27;/etc/fstab&#x27;</span>);
  <span class="hljs-keyword">const</span> f2 = <span class="hljs-keyword">await</span> readFile(<span class="hljs-string">&#x27;/etc/shells&#x27;</span>);
  <span class="hljs-built_in">console</span>.log(f1.toString());
  <span class="hljs-built_in">console</span>.log(f2.toString());
};
</code></pre><p>一比较就会发现，<code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p><p><code>async</code>函数对 Generator 函数的改进，体现在以下四点。</p><p>（1）内置执行器。</p><p>Generator 函数的执行必须靠执行器，所以才有了<code>co</code>模块，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。</p><pre class="hljs"><code>asyncReadFile();
</code></pre><p>上面的代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能真正执行，得到最后结果。</p><p>（2）更好的语义。</p><p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p><p>（3）更广的适用性。</p><p><code>co</code>模块约定，<code>yield</code>命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p><p>（4）返回值是 Promise。</p><p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p><p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p><h2 id="基本用法">基本用法 <a class="markdownIt-Anchor" href="#基本用法">#</a></h2><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p><p>下面是一个例子。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStockPriceByName</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">const</span> symbol = <span class="hljs-keyword">await</span> getStockSymbol(name);
  <span class="hljs-keyword">const</span> stockPrice = <span class="hljs-keyword">await</span> getStockPrice(symbol);
  <span class="hljs-keyword">return</span> stockPrice;
}

getStockPriceByName(<span class="hljs-string">&#x27;goog&#x27;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
  <span class="hljs-built_in">console</span>.log(result);
});
</code></pre><p>上面代码是一个获取股票报价的函数，函数前面的<code>async</code>关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个<code>Promise</code>对象。</p><p>下面是另一个例子，指定多少毫秒后输出一个值。</p><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeout</span>(<span class="hljs-params">ms</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(resolve, ms);
  });
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncPrint</span>(<span class="hljs-params">value, ms</span>) </span>{
  <span class="hljs-keyword">await</span> timeout(ms);
  <span class="hljs-built_in">console</span>.log(value);
}

asyncPrint(<span class="hljs-string">&#x27;hello world&#x27;</span>, <span class="hljs-number">50</span>);
</code></pre><p>上面代码指定 50 毫秒以后，输出<code>hello world</code>。</p><p>由于<code>async</code>函数返回的是 Promise 对象，可以作为<code>await</code>命令的参数。所以，上面的例子也可以写成下面的形式。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeout</span>(<span class="hljs-params">ms</span>) </span>{
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(resolve, ms);
  });
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncPrint</span>(<span class="hljs-params">value, ms</span>) </span>{
  <span class="hljs-keyword">await</span> timeout(ms);
  <span class="hljs-built_in">console</span>.log(value);
}

asyncPrint(<span class="hljs-string">&#x27;hello world&#x27;</span>, <span class="hljs-number">50</span>);
</code></pre><p>async 函数有多种使用形式。</p><pre class="hljs"><code><span class="hljs-comment">// 函数声明</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{}

<span class="hljs-comment">// 函数表达式</span>
<span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{};

<span class="hljs-comment">// 对象的方法</span>
<span class="hljs-keyword">let</span> obj = { <span class="hljs-keyword">async</span> foo() {} };
obj.foo().then(...)

<span class="hljs-comment">// Class 的方法</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Storage</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-built_in">this</span>.cachePromise = caches.open(<span class="hljs-string">&#x27;avatars&#x27;</span>);
  }

  <span class="hljs-keyword">async</span> getAvatar(name) {
    <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.cachePromise;
    <span class="hljs-keyword">return</span> cache.match(<span class="hljs-string">`/avatars/<span class="hljs-subst">${name}</span>.jpg`</span>);
  }
}

<span class="hljs-keyword">const</span> storage = <span class="hljs-keyword">new</span> Storage();
storage.getAvatar(<span class="hljs-string">&#x27;jake&#x27;</span>).then(…);

<span class="hljs-comment">// 箭头函数</span>
<span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">async</span> () =&gt; {};
</code></pre><h2 id="语法">语法 <a class="markdownIt-Anchor" href="#语法">#</a></h2><p><code>async</code>函数的语法规则总体上比较简单，难点是错误处理机制。</p><h3 id="返回-promise-对象">返回 Promise 对象 <a class="markdownIt-Anchor" href="#返回-promise-对象">#</a></h3><p><code>async</code>函数返回一个 Promise 对象。</p><p><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world&#x27;</span>;
}

f().then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v))
<span class="hljs-comment">// &quot;hello world&quot;</span>
</code></pre><p>上面代码中，函数<code>f</code>内部<code>return</code>命令返回的值，会被<code>then</code>方法回调函数接收到。</p><p><code>async</code>函数内部抛出错误，会导致返回的 Promise 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;出错了&#x27;</span>);
}

f().then(
  <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;resolve&#x27;</span>, v),
  <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;reject&#x27;</span>, e)
)
<span class="hljs-comment">//reject Error: 出错了</span>
</code></pre><h3 id="promise-对象的状态变化">Promise 对象的状态变化 <a class="markdownIt-Anchor" href="#promise-对象的状态变化">#</a></h3><p><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</p><p>下面是一个例子。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTitle</span>(<span class="hljs-params">url</span>) </span>{
  <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(url);
  <span class="hljs-keyword">let</span> html = <span class="hljs-keyword">await</span> response.text();
  <span class="hljs-keyword">return</span> html.match(<span class="hljs-regexp">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span>)[<span class="hljs-number">1</span>];
}
getTitle(<span class="hljs-string">&#x27;https://tc39.github.io/ecma262/&#x27;</span>).then(<span class="hljs-built_in">console</span>.log)
<span class="hljs-comment">// &quot;ECMAScript 2017 Language Specification&quot;</span>
</code></pre><p>上面代码中，函数<code>getTitle</code>内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行<code>then</code>方法里面的<code>console.log</code>。</p><h3 id="await-命令">await 命令 <a class="markdownIt-Anchor" href="#await-命令">#</a></h3><p>正常情况下，<code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 等同于</span>
  <span class="hljs-comment">// return 123;</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-number">123</span>;
}

f().then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v))
<span class="hljs-comment">// 123</span>
</code></pre><p>上面代码中，<code>await</code>命令的参数是数值<code>123</code>，这时等同于<code>return 123</code>。</p><p>另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义了<code>then</code>方法的对象），那么<code>await</code>会将其等同于 Promise 对象。</p><pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sleep</span> </span>{
  <span class="hljs-keyword">constructor</span>(timeout) {
    <span class="hljs-built_in">this</span>.timeout = timeout;
  }
  then(resolve, reject) {
    <span class="hljs-keyword">const</span> startTime = <span class="hljs-built_in">Date</span>.now();
    <span class="hljs-built_in">setTimeout</span>(
      <span class="hljs-function">() =&gt;</span> resolve(<span class="hljs-built_in">Date</span>.now() - startTime),
      <span class="hljs-built_in">this</span>.timeout
    );
  }
}

(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> sleepTime = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> Sleep(<span class="hljs-number">1000</span>);
  <span class="hljs-built_in">console</span>.log(sleepTime);
})();
<span class="hljs-comment">// 1000</span>
</code></pre><p>上面代码中，<code>await</code>命令后面是一个<code>Sleep</code>对象的实例。这个实例不是 Promise 对象，但是因为定义了<code>then</code>方法，<code>await</code>会将其视为<code>Promise</code>处理。</p><p>这个例子还演示了如何实现休眠效果。JavaScript 一直没有休眠的语法，但是借助<code>await</code>命令就可以让程序停顿指定的时间。下面给出了一个简化的<code>sleep</code>实现。</p><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">interval</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(resolve, interval);
  })
}

<span class="hljs-comment">// 用法</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">one2FiveInAsync</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) {
    <span class="hljs-built_in">console</span>.log(i);
    <span class="hljs-keyword">await</span> sleep(<span class="hljs-number">1000</span>);
  }
}

one2FiveInAsync();
</code></pre><p><code>await</code>命令后面的 Promise 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">&#x27;出错了&#x27;</span>);
}

f()
.then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v))
.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(e))
<span class="hljs-comment">// 出错了</span>
</code></pre><p>注意，上面代码中，<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。</p><p>任何一个<code>await</code>语句后面的 Promise 对象变为<code>reject</code>状态，那么整个<code>async</code>函数都会中断执行。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">&#x27;出错了&#x27;</span>);
  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&#x27;hello world&#x27;</span>); <span class="hljs-comment">// 不会执行</span>
}
</code></pre><p>上面代码中，第二个<code>await</code>语句是不会执行的，因为第一个<code>await</code>语句状态变成了<code>reject</code>。</p><p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">&#x27;出错了&#x27;</span>);
  } <span class="hljs-keyword">catch</span>(e) {
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&#x27;hello world&#x27;</span>);
}

f()
.then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v))
<span class="hljs-comment">// hello world</span>
</code></pre><p>另一种方法是<code>await</code>后面的 Promise 对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">&#x27;出错了&#x27;</span>)
    .catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(e));
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&#x27;hello world&#x27;</span>);
}

f()
.then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v))
<span class="hljs-comment">// 出错了</span>
<span class="hljs-comment">// hello world</span>
</code></pre><h3 id="错误处理">错误处理 <a class="markdownIt-Anchor" href="#错误处理">#</a></h3><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;出错了&#x27;</span>);
  });
}

f()
.then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v))
.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(e))
<span class="hljs-comment">// Error：出错了</span>
</code></pre><p>上面代码中，<code>async</code>函数<code>f</code>执行后，<code>await</code>后面的 Promise 对象会抛出一个错误对象，导致<code>catch</code>方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。</p><p>防止出错的方法，也是将其放在<code>try...catch</code>代码块之中。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;出错了&#x27;</span>);
    });
  } <span class="hljs-keyword">catch</span>(e) {
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>);
}
</code></pre><p>如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> val1 = <span class="hljs-keyword">await</span> firstStep();
    <span class="hljs-keyword">const</span> val2 = <span class="hljs-keyword">await</span> secondStep(val1);
    <span class="hljs-keyword">const</span> val3 = <span class="hljs-keyword">await</span> thirdStep(val1, val2);

    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Final: &#x27;</span>, val3);
  }
  <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-built_in">console</span>.error(err);
  }
}
</code></pre><p>下面的例子使用<code>try...catch</code>结构，实现多次重复尝试。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;superagent&#x27;</span>);
<span class="hljs-keyword">const</span> NUM_RETRIES = <span class="hljs-number">3</span>;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> i;
  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NUM_RETRIES; ++i) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">await</span> superagent.get(<span class="hljs-string">&#x27;http://google.com/this-throws-an-error&#x27;</span>);
      <span class="hljs-keyword">break</span>;
    } <span class="hljs-keyword">catch</span>(err) {}
  }
  <span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// 3</span>
}

test();
</code></pre><p>上面代码中，如果<code>await</code>操作成功，就会使用<code>break</code>语句退出循环；如果失败，会被<code>catch</code>语句捕捉，然后进入下一轮循环。</p><h3 id="使用注意点">使用注意点 <a class="markdownIt-Anchor" href="#使用注意点">#</a></h3><p>第一点，前面已经说过，<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> somethingThatReturnsAPromise();
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-built_in">console</span>.log(err);
  }
}

<span class="hljs-comment">// 另一种写法</span>

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">await</span> somethingThatReturnsAPromise()
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
    <span class="hljs-built_in">console</span>.log(err);
  });
}
</code></pre><p>第二点，多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> foo = <span class="hljs-keyword">await</span> getFoo();
<span class="hljs-keyword">let</span> bar = <span class="hljs-keyword">await</span> getBar();
</code></pre><p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。</p><pre class="hljs"><code><span class="hljs-comment">// 写法一</span>
<span class="hljs-keyword">let</span> [foo, bar] = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([getFoo(), getBar()]);

<span class="hljs-comment">// 写法二</span>
<span class="hljs-keyword">let</span> fooPromise = getFoo();
<span class="hljs-keyword">let</span> barPromise = getBar();
<span class="hljs-keyword">let</span> foo = <span class="hljs-keyword">await</span> fooPromise;
<span class="hljs-keyword">let</span> bar = <span class="hljs-keyword">await</span> barPromise;
</code></pre><p>上面两种写法，<code>getFoo</code>和<code>getBar</code>都是同时触发，这样就会缩短程序的执行时间。</p><p>第三点，<code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dbFuc</span>(<span class="hljs-params">db</span>) </span>{
  <span class="hljs-keyword">let</span> docs = [{}, {}, {}];

  <span class="hljs-comment">// 报错</span>
  docs.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc</span>) </span>{
    <span class="hljs-keyword">await</span> db.post(doc);
  });
}
</code></pre><p>上面代码会报错，因为<code>await</code>用在普通函数之中了。但是，如果将<code>forEach</code>方法的参数改成<code>async</code>函数，也有问题。</p><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dbFuc</span>(<span class="hljs-params">db</span>) </span>{ <span class="hljs-comment">//这里不需要 async</span>
  <span class="hljs-keyword">let</span> docs = [{}, {}, {}];

  <span class="hljs-comment">// 可能得到错误结果</span>
  docs.forEach(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc</span>) </span>{
    <span class="hljs-keyword">await</span> db.post(doc);
  });
}
</code></pre><p>上面代码可能不会正常工作，原因是这时三个<code>db.post()</code>操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用<code>for</code>循环。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dbFuc</span>(<span class="hljs-params">db</span>) </span>{
  <span class="hljs-keyword">let</span> docs = [{}, {}, {}];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> doc <span class="hljs-keyword">of</span> docs) {
    <span class="hljs-keyword">await</span> db.post(doc);
  }
}
</code></pre><p>另一种方法是使用数组的<code>reduce()</code>方法。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dbFuc</span>(<span class="hljs-params">db</span>) </span>{
  <span class="hljs-keyword">let</span> docs = [{}, {}, {}];

  <span class="hljs-keyword">await</span> docs.reduce(<span class="hljs-keyword">async</span> (_, doc) =&gt; {
    <span class="hljs-keyword">await</span> _;
    <span class="hljs-keyword">await</span> db.post(doc);
  }, <span class="hljs-literal">undefined</span>);
}
</code></pre><p>上面例子中，<code>reduce()</code>方法的第一个参数是<code>async</code>函数，导致该函数的第一个参数是前一步操作返回的 Promise 对象，所以必须使用<code>await</code>等待它操作结束。另外，<code>reduce()</code>方法返回的是<code>docs</code>数组最后一个成员的<code>async</code>函数的执行结果，也是一个 Promise 对象，导致在它前面也必须加上<code>await</code>。</p><p>上面的<code>reduce()</code>的参数函数里面没有<code>return</code>语句，原因是这个函数的主要目的是<code>db.post()</code>操作，不是返回值。而且<code>async</code>函数不管有没有<code>return</code>语句，总是返回一个 Promise 对象，所以这里的<code>return</code>是不必要的。</p><p>如果确实希望多个请求并发执行，可以使用<code>Promise.all</code>方法。当三个请求都会<code>resolved</code>时，下面两种写法效果相同。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dbFuc</span>(<span class="hljs-params">db</span>) </span>{
  <span class="hljs-keyword">let</span> docs = [{}, {}, {}];
  <span class="hljs-keyword">let</span> promises = docs.map(<span class="hljs-function">(<span class="hljs-params">doc</span>) =&gt;</span> db.post(doc));

  <span class="hljs-keyword">let</span> results = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(promises);
  <span class="hljs-built_in">console</span>.log(results);
}

<span class="hljs-comment">// 或者使用下面的写法</span>

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dbFuc</span>(<span class="hljs-params">db</span>) </span>{
  <span class="hljs-keyword">let</span> docs = [{}, {}, {}];
  <span class="hljs-keyword">let</span> promises = docs.map(<span class="hljs-function">(<span class="hljs-params">doc</span>) =&gt;</span> db.post(doc));

  <span class="hljs-keyword">let</span> results = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> promise <span class="hljs-keyword">of</span> promises) {
    results.push(<span class="hljs-keyword">await</span> promise);
  }
  <span class="hljs-built_in">console</span>.log(results);
}
</code></pre><p>第四点，async 函数可以保留运行堆栈。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> a = <span class="hljs-function">() =&gt;</span> {
  b().then(<span class="hljs-function">() =&gt;</span> c());
};
</code></pre><p>上面代码中，函数<code>a</code>内部运行了一个异步任务<code>b()</code>。当<code>b()</code>运行的时候，函数<code>a()</code>不会中断，而是继续执行。等到<code>b()</code>运行结束，可能<code>a()</code>早就运行结束了，<code>b()</code>所在的上下文环境已经消失了。如果<code>b()</code>或<code>c()</code>报错，错误堆栈将不包括<code>a()</code>。</p><p>现在将这个例子改成<code>async</code>函数。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> a = <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> b();
  c();
};
</code></pre><p>上面代码中，<code>b()</code>运行的时候，<code>a()</code>是暂停执行，上下文环境都保存着。一旦<code>b()</code>或<code>c()</code>报错，错误堆栈将包括<code>a()</code>。</p><h2 id="async-函数的实现原理">async 函数的实现原理 <a class="markdownIt-Anchor" href="#async-函数的实现原理">#</a></h2><p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">args</span>) </span>{
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">// 等同于</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">args</span>) </span>{
  <span class="hljs-keyword">return</span> spawn(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// ...</span>
  });
}
</code></pre><p>所有的<code>async</code>函数都可以写成上面的第二种形式，其中的<code>spawn</code>函数就是自动执行器。</p><p>下面给出<code>spawn</code>函数的实现，基本就是前文自动执行器的翻版。</p><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">spawn</span>(<span class="hljs-params">genF</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
    <span class="hljs-keyword">const</span> gen = genF();
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step</span>(<span class="hljs-params">nextF</span>) </span>{
      <span class="hljs-keyword">let</span> next;
      <span class="hljs-keyword">try</span> {
        next = nextF();
      } <span class="hljs-keyword">catch</span>(e) {
        <span class="hljs-keyword">return</span> reject(e);
      }
      <span class="hljs-keyword">if</span>(next.done) {
        <span class="hljs-keyword">return</span> resolve(next.value);
      }
      <span class="hljs-built_in">Promise</span>.resolve(next.value).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{
        step(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> gen.next(v); });
      }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
        step(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> gen.throw(e); });
      });
    }
    step(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> gen.next(<span class="hljs-literal">undefined</span>); });
  });
}
</code></pre><h2 id="与其他异步处理方法的比较">与其他异步处理方法的比较 <a class="markdownIt-Anchor" href="#与其他异步处理方法的比较">#</a></h2><p>我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。</p><p>假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p><p>首先是 Promise 的写法。</p><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">chainAnimationsPromise</span>(<span class="hljs-params">elem, animations</span>) </span>{

  <span class="hljs-comment">// 变量ret用来保存上一个动画的返回值</span>
  <span class="hljs-keyword">let</span> ret = <span class="hljs-literal">null</span>;

  <span class="hljs-comment">// 新建一个空的Promise</span>
  <span class="hljs-keyword">let</span> p = <span class="hljs-built_in">Promise</span>.resolve();

  <span class="hljs-comment">// 使用then方法，添加所有动画</span>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> anim <span class="hljs-keyword">of</span> animations) {
    p = p.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>{
      ret = val;
      <span class="hljs-keyword">return</span> anim(elem);
    });
  }

  <span class="hljs-comment">// 返回一个部署了错误捕捉机制的Promise</span>
  <span class="hljs-keyword">return</span> p.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
    <span class="hljs-comment">/* 忽略错误，继续执行 */</span>
  }).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> ret;
  });

}
</code></pre><p>虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（<code>then</code>、<code>catch</code>等等），操作本身的语义反而不容易看出来。</p><p>接着是 Generator 函数的写法。</p><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">chainAnimationsGenerator</span>(<span class="hljs-params">elem, animations</span>) </span>{

  <span class="hljs-keyword">return</span> spawn(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> ret = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> anim <span class="hljs-keyword">of</span> animations) {
        ret = <span class="hljs-keyword">yield</span> anim(elem);
      }
    } <span class="hljs-keyword">catch</span>(e) {
      <span class="hljs-comment">/* 忽略错误，继续执行 */</span>
    }
    <span class="hljs-keyword">return</span> ret;
  });

}
</code></pre><p>上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在<code>spawn</code>函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的<code>spawn</code>函数就是自动执行器，它返回一个 Promise 对象，而且必须保证<code>yield</code>语句后面的表达式，必须返回一个 Promise。</p><p>最后是 async 函数的写法。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">chainAnimationsAsync</span>(<span class="hljs-params">elem, animations</span>) </span>{
  <span class="hljs-keyword">let</span> ret = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> anim <span class="hljs-keyword">of</span> animations) {
      ret = <span class="hljs-keyword">await</span> anim(elem);
    }
  } <span class="hljs-keyword">catch</span>(e) {
    <span class="hljs-comment">/* 忽略错误，继续执行 */</span>
  }
  <span class="hljs-keyword">return</span> ret;
}
</code></pre><p>可以看到 Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 Generator 写法，自动执行器需要用户自己提供。</p><h2 id="实例：按顺序完成异步操作">实例：按顺序完成异步操作 <a class="markdownIt-Anchor" href="#实例：按顺序完成异步操作">#</a></h2><p>实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。</p><p>Promise 的写法如下。</p><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logInOrder</span>(<span class="hljs-params">urls</span>) </span>{
  <span class="hljs-comment">// 远程读取所有URL</span>
  <span class="hljs-keyword">const</span> textPromises = urls.map(<span class="hljs-function"><span class="hljs-params">url</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> fetch(url).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.text());
  });

  <span class="hljs-comment">// 按次序输出</span>
  textPromises.reduce(<span class="hljs-function">(<span class="hljs-params">chain, textPromise</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> chain.then(<span class="hljs-function">() =&gt;</span> textPromise)
      .then(<span class="hljs-function"><span class="hljs-params">text</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(text));
  }, <span class="hljs-built_in">Promise</span>.resolve());
}
</code></pre><p>上面代码使用<code>fetch</code>方法，同时远程读取一组 URL。每个<code>fetch</code>操作都返回一个 Promise 对象，放入<code>textPromises</code>数组。然后，<code>reduce</code>方法依次处理每个 Promise 对象，然后使用<code>then</code>，将所有 Promise 对象连起来，因此就可以依次输出结果。</p><p>这种写法不太直观，可读性比较差。下面是 async 函数实现。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logInOrder</span>(<span class="hljs-params">urls</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> url <span class="hljs-keyword">of</span> urls) {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(url);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> response.text());
  }
}
</code></pre><p>上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logInOrder</span>(<span class="hljs-params">urls</span>) </span>{
  <span class="hljs-comment">// 并发读取远程URL</span>
  <span class="hljs-keyword">const</span> textPromises = urls.map(<span class="hljs-keyword">async</span> url =&gt; {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(url);
    <span class="hljs-keyword">return</span> response.text();
  });

  <span class="hljs-comment">// 按次序输出</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> textPromise <span class="hljs-keyword">of</span> textPromises) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> textPromise);
  }
}
</code></pre><p>上面代码中，虽然<code>map</code>方法的参数是<code>async</code>函数，但它是并发执行的，因为只有<code>async</code>函数内部是继发执行，外部不受影响。后面的<code>for..of</code>循环内部使用了<code>await</code>，因此实现了按顺序输出。</p><h2 id="顶层-await">顶层 await <a class="markdownIt-Anchor" href="#顶层-await">#</a></h2><p>根据语法规格，<code>await</code>命令只能出现在 async 函数内部，否则都会报错。</p><pre class="hljs"><code><span class="hljs-comment">// 报错</span>
<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;https://api.example.com&#x27;</span>);
</code></pre><p>上面代码中，<code>await</code>命令独立使用，没有放在 async 函数里面，就会报错。</p><p>目前，有一个<a href="https://github.com/tc39/proposal-top-level-await" target="_blank" rel="noopener">语法提案</a>，允许在模块的顶层独立使用<code>await</code>命令，使得上面那行代码不会报错了。这个提案的目的，是借用<code>await</code>解决模块异步加载的问题。</p><pre class="hljs"><code><span class="hljs-comment">// awaiting.js</span>
<span class="hljs-keyword">let</span> output;
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> dynamic = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(someMission);
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> fetch(url);
  output = someProcess(dynamic.default, data);
}
main();
<span class="hljs-keyword">export</span> { output };
</code></pre><p>上面代码中，模块<code>awaiting.js</code>的输出值<code>output</code>，取决于异步操作。我们把异步操作包装在一个 async 函数里面，然后调用这个函数，只有等里面的异步操作都执行，变量<code>output</code>才会有值，否则就返回<code>undefined</code>。</p><p>上面的代码也可以写成立即执行函数的形式。</p><pre class="hljs"><code><span class="hljs-comment">// awaiting.js</span>
<span class="hljs-keyword">let</span> output;
(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> dynamic = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(someMission);
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> fetch(url);
  output = someProcess(dynamic.default, data);
})();
<span class="hljs-keyword">export</span> { output };
</code></pre><p>下面是加载这个模块的写法。</p><pre class="hljs"><code><span class="hljs-comment">// usage.js</span>
<span class="hljs-keyword">import</span> { output } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./awaiting.js&quot;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outputPlusValue</span>(<span class="hljs-params">value</span>) </span>{ <span class="hljs-keyword">return</span> output + value }

<span class="hljs-built_in">console</span>.log(outputPlusValue(<span class="hljs-number">100</span>));
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(outputPlusValue(<span class="hljs-number">100</span>), <span class="hljs-number">1000</span>);
</code></pre><p>上面代码中，<code>outputPlusValue()</code>的执行结果，完全取决于执行的时间。如果<code>awaiting.js</code>里面的异步操作没执行完，加载进来的<code>output</code>的值就是<code>undefined</code>。</p><p>目前的解决方法，就是让原始模块输出一个 Promise 对象，从这个 Promise 对象判断异步操作有没有结束。</p><pre class="hljs"><code><span class="hljs-comment">// awaiting.js</span>
<span class="hljs-keyword">let</span> output;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> dynamic = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(someMission);
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> fetch(url);
  output = someProcess(dynamic.default, data);
})();
<span class="hljs-keyword">export</span> { output };
</code></pre><p>上面代码中，<code>awaiting.js</code>除了输出<code>output</code>，还默认输出一个 Promise 对象（async 函数立即执行后，返回一个 Promise 对象），从这个对象判断异步操作是否结束。</p><p>下面是加载这个模块的新的写法。</p><pre class="hljs"><code><span class="hljs-comment">// usage.js</span>
<span class="hljs-keyword">import</span> promise, { output } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./awaiting.js&quot;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outputPlusValue</span>(<span class="hljs-params">value</span>) </span>{ <span class="hljs-keyword">return</span> output + value }

promise.then(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(outputPlusValue(<span class="hljs-number">100</span>));
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(outputPlusValue(<span class="hljs-number">100</span>), <span class="hljs-number">1000</span>);
});
</code></pre><p>上面代码中，将<code>awaiting.js</code>对象的输出，放在<code>promise.then()</code>里面，这样就能保证异步操作完成以后，才去读取<code>output</code>。</p><p>这种写法比较麻烦，等于要求模块的使用者遵守一个额外的使用协议，按照特殊的方法使用这个模块。一旦你忘了要用 Promise 加载，只使用正常的加载方法，依赖这个模块的代码就可能出错。而且，如果上面的<code>usage.js</code>又有对外的输出，等于这个依赖链的所有模块都要使用 Promise 加载。</p><p>顶层的<code>await</code>命令，就是为了解决这个问题。它保证只有异步操作完成，模块才会输出值。</p><pre class="hljs"><code><span class="hljs-comment">// awaiting.js</span>
<span class="hljs-keyword">const</span> dynamic = <span class="hljs-keyword">import</span>(someMission);
<span class="hljs-keyword">const</span> data = fetch(url);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> output = someProcess((<span class="hljs-keyword">await</span> dynamic).default, <span class="hljs-keyword">await</span> data);
</code></pre><p>上面代码中，两个异步操作在输出的时候，都加上了<code>await</code>命令。只有等到异步操作完成，这个模块才会输出值。</p><p>加载这个模块的写法如下。</p><pre class="hljs"><code><span class="hljs-comment">// usage.js</span>
<span class="hljs-keyword">import</span> { output } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./awaiting.js&quot;</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outputPlusValue</span>(<span class="hljs-params">value</span>) </span>{ <span class="hljs-keyword">return</span> output + value }

<span class="hljs-built_in">console</span>.log(outputPlusValue(<span class="hljs-number">100</span>));
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(outputPlusValue(<span class="hljs-number">100</span>), <span class="hljs-number">1000</span>);
</code></pre><p>上面代码的写法，与普通的模块加载完全一样。也就是说，模块的使用者完全不用关心，依赖模块的内部有没有异步操作，正常加载即可。</p><p>这时，模块的加载会等待依赖模块（上例是<code>awaiting.js</code>）的异步操作完成，才执行后面的代码，有点像暂停在那里。所以，它总是会得到正确的<code>output</code>，不会因为加载时机的不同，而得到不一样的值。</p><p>注意，顶层<code>await</code>只能用在 ES6 模块，不能用在 CommonJS 模块。这是因为 CommonJS 模块的<code>require()</code>是同步加载，如果有顶层<code>await</code>，就没法处理加载了。</p><p>下面是顶层<code>await</code>的一些使用场景。</p><pre class="hljs"><code><span class="hljs-comment">// import() 方法加载</span>
<span class="hljs-keyword">const</span> strings = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">`/i18n/<span class="hljs-subst">${navigator.language}</span>`</span>);

<span class="hljs-comment">// 数据库操作</span>
<span class="hljs-keyword">const</span> connection = <span class="hljs-keyword">await</span> dbConnector();

<span class="hljs-comment">// 依赖回滚</span>
<span class="hljs-keyword">let</span> jQuery;
<span class="hljs-keyword">try</span> {
  jQuery = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;https://cdn-a.com/jQuery&#x27;</span>);
} <span class="hljs-keyword">catch</span> {
  jQuery = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;https://cdn-b.com/jQuery&#x27;</span>);
}
</code></pre><p>注意，如果加载多个包含顶层<code>await</code>命令的模块，加载命令是同步执行的。</p><pre class="hljs"><code><span class="hljs-comment">// x.js</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;X1&quot;</span>);
<span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(r, <span class="hljs-number">1000</span>));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;X2&quot;</span>);

<span class="hljs-comment">// y.js</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Y&quot;</span>);

<span class="hljs-comment">// z.js</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./x.js&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./y.js&quot;</span>;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Z&quot;</span>);
</code></pre><p>上面代码有三个模块，最后的<code>z.js</code>加载<code>x.js</code>和<code>y.js</code>，打印结果是<code>X1</code>、<code>Y</code>、<code>X2</code>、<code>Z</code>。这说明，<code>z.js</code>并没有等待<code>x.js</code>加载完成，再去加载<code>y.js</code>。</p><p>顶层的<code>await</code>命令有点像，交出代码的执行权给其他的模块加载，等异步操作完成后，再拿回执行权，继续向下执行。</p></article><nav class="level level-previous-next is-size-5 is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="generator-async.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> Generator 函数的异步应用</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="class.html">Class 的基本语法 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><div class="page-info is-size-5-desktop"><p>本教程采用<a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh" target="_blank">知识共享 署名-相同方式共享 3.0协议</a>。</p><p>分享本文 <span class="social-share"></span></p></div></div><div class="column is-3 is-offset-1"><nav class="panel panel-menu"><p class="panel-heading"><i class="fa fa-book" aria-hidden="true"></i> ES6 教程</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="intro.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">ECMAScript 6 简介</span></a></li><li><a href="let.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">let 和 const 命令</span></a></li><li><a href="destructuring.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">变量的解构赋值</span></a></li><li><a href="string.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">字符串的扩展</span></a></li><li><a href="string-methods.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">字符串的新增方法</span></a></li><li><a href="regex.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">正则的扩展</span></a></li><li><a href="number.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">数值的扩展</span></a></li><li><a href="function.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">函数的扩展</span></a></li><li><a href="array.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">数组的扩展</span></a></li><li><a href="object.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">对象的扩展</span></a></li><li><a href="object-methods.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">对象的新增方法</span></a></li><li><a href="symbol.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Symbol</span></a></li><li><a href="set-map.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Set 和 Map 数据结构</span></a></li><li><a href="proxy.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Proxy</span></a></li><li><a href="reflect.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Reflect</span></a></li><li><a href="promise.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Promise 对象</span></a></li><li><a href="iterator.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Iterator 和 for...of 循环</span></a></li><li><a href="generator.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Generator 函数的语法</span></a></li><li><a href="generator-async.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Generator 函数的异步应用</span></a></li><li><a href="async.html" class="is-active"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">async 函数</span></a></li><li><a href="class.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Class 的基本语法</span></a></li><li><a href="class-extends.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Class 的继承</span></a></li><li><a href="module.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Module 的语法</span></a></li><li><a href="module-loader.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Module 的加载实现</span></a></li><li><a href="style.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">编程风格</span></a></li><li><a href="spec.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">读懂规格</span></a></li><li><a href="async-iterator.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">异步遍历器</span></a></li><li><a href="arraybuffer.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">ArrayBuffer</span></a></li><li><a href="proposals.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">最新提案</span></a></li><li><a href="decorator.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Decorator</span></a></li><li><a href="reference.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">参考链接</span></a></li></ul></aside></div></nav><nav class="panel panel-info"><p class="panel-heading"><i class="fa fa-link" aria-hidden="true"></i> 链接</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="https://raw.githubusercontent.com/wangdoc/es6-tutorial/master/docs/async.md" target="_blank"><span class="icon"></span><i class="fa fa-code" aria-hidden="true" style="width: 14px;"></i>&nbsp;本文源码</a></li><li><a href="https://github.com/wangdoc/es6-tutorial" target="_blank"><span class="icon"></span><i class="fa fa-hdd-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;代码仓库</a></li><li><a href="https://github.com/wangdoc/es6-tutorial/issues" target="_blank"><span class="icon"></span><i class="fa fa-flag-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;反馈</a></li></ul></aside></div></nav></div></div><div class="columns"><div class="column is-8"><div id="disqus_thread"></div></div></div></div></section><footer class="footer is-size-5-desktop"><div class="container"><div class="content has-text-centered"><p>联系：contact@wangdoc.com</p></div></div></footer><script>var LOPPO={current_path:"async.md",relative_root_path:"",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E5%90%AB%E4%B9%89">含义</a></li>\n<li><a href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</a></li>\n<li><a href="#%E8%AF%AD%E6%B3%95">语法</a>\n<ul>\n<li><a href="#%E8%BF%94%E5%9B%9E-promise-%E5%AF%B9%E8%B1%A1">返回 Promise 对象</a></li>\n<li><a href="#promise-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96">Promise 对象的状态变化</a></li>\n<li><a href="#await-%E5%91%BD%E4%BB%A4">await 命令</a></li>\n<li><a href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误处理</a></li>\n<li><a href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9">使用注意点</a></li>\n</ul>\n</li>\n<li><a href="#async-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">async 函数的实现原理</a></li>\n<li><a href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83">与其他异步处理方法的比较</a></li>\n<li><a href="#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E6%8C%89%E9%A1%BA%E5%BA%8F%E5%AE%8C%E6%88%90%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C">实例：按顺序完成异步操作</a></li>\n<li><a href="#%E9%A1%B6%E5%B1%82-await">顶层 await</a></li>\n</ul>\n'}</script><script src="assets/js/app.js"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-111269443-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-111269443-1")</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?5eec262881855af3dede6a71234571f6";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/

var disqus_config = function () {
const l = window.location;
const url = l.protocol + '//' + l.host + (l.port ? ':' + l.port : '') + l.pathname;
this.page.url = url;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = l.pathname; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://wangdoc-es6.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();</script><!--script src="assets/js/social-share.min.js"--><!--/script--><script>var shareDesc="我正在阅读《async 函数》，出自网道（WangDoc.com）的《ES6 教程》。",shareOpts={url:window.location.href,source:shareDesc,title:shareDesc,description:"",image:"",sites:["weibo","wechat","qq","qzone","twitter","facebook"],origin:"WangDoc_com",disabled:[],wechatQrcodeTitle:"微信",wechatQrcodeHelper:"扫一下二维码，分享到微信。"};socialShare(".social-share",shareOpts)</script></body></html>